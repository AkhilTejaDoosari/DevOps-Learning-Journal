# **04. File Operations — Creating, Moving, and Managing Files**
> From creation to deletion, do it confidently

---

## What We'll Cover

- [1. Why File Operations Are Your Daily Bread](#1-why-file-operations-are-your-daily-bread)
- [2. Creating and Inspecting Files](#2-creating-and-inspecting-files)
- [3. Copying Files Without Breaking Things](#3-copying-files-without-breaking-things)
- [4. Moving and Renaming (The Safe Way)](#4-moving-and-renaming)
- [5. Deleting Files (And Not Regretting It)](#5-deleting-files)
- [6. Viewing File Contents](#6-viewing-file-contents)
- [7. Wildcards and Pattern Matching](#7-wildcards-and-pattern-matching)
- [8. Links: When and Why](#8-links-when-and-why)
- [9. Real Production Scenarios](#9-real-production-scenarios)
- [10. Quick Command Reference](#10-quick-command-reference)

---

<details>
<summary><strong>1. Why File Operations Are Your Daily Bread</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Every Task Involves Files

**Deploying code?** Copying files.  
**Managing configs?** Editing and backing up files.  
**Debugging?** Reading log files.  
**Setting up services?** Creating and moving files.

**You manipulate files dozens of times per day.**

---

## The Scenarios You'll Face

**At 2 AM:**
- "I need to check the nginx logs NOW"
- "Copy this config to staging before I break production"
- "Delete these temp files without nuking the whole directory"
- "Watch this log file as the deployment happens"

**Fast, confident file operations = fast incident resolution.**

---

## What Most People Get Wrong

They know the commands exist. But they don't know:
- **When to use cp -i vs cp -r**
- **How to safely delete files** (rm -rf horror stories)
- **Wildcards** that match exactly what you want
- **Links** (hard vs symbolic, when to use which)

**After this file, you'll handle files like a pro.**

</div>

</details>

---

<details>
<summary><strong>2. Creating and Inspecting Files</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Creating Empty Files

```bash
touch file.txt
```

**What it does:**
- Creates empty file if it doesn't exist
- Updates timestamp if it does exist

**When you'd use it:**
- Create placeholder files
- Test permissions
- Reset modification time

---

## Creating Files With Content

```bash
echo "Hello World" > file.txt
```

**Instant file with content.**

```bash
cat > file.txt << EOF
Line 1
Line 2
Line 3
EOF
```

**Multi-line content, type until you hit EOF.**

---

## What Type of File Is This?

```bash
file myfile
```

**Example outputs:**

```bash
$ file script.sh
script.sh: Bourne-Again shell script, ASCII text

$ file image.jpg
image.jpg: JPEG image data

$ file /bin/ls
/bin/ls: ELF 64-bit LSB executable
```

**Why this matters:** Some files look like text but aren't. `file` tells you the truth.

---

## Detailed File Info

```bash
stat file.txt
```

**Shows:**
- Size
- Permissions
- Timestamps (accessed, modified, changed)
- Inode number

**When debugging, you need to know:** "When was this file last modified?"

```bash
stat nginx.conf | grep Modify
# Modify: 2025-01-15 10:30:45
```

**Boom. Now you know it changed today at 10:30.**

---

## Key Takeaway

**touch** creates empty files  
**echo >** creates files with content  
**file** identifies file type  
**stat** shows detailed metadata

</div>

</details>

---

<details>
<summary><strong>3. Copying Files Without Breaking Things</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Basic Copy

```bash
cp source.txt destination.txt
```

**Simple. But dangerous if destination exists—it overwrites without warning.**

---

## Interactive Mode: Ask Before Overwriting

```bash
cp -i config.yaml config.yaml.backup
```

**If destination exists, prompts:** `overwrite 'config.yaml.backup'? (y/n)`

**Use this when you're not 100% sure.**

---

## Verbose Mode: See What's Happening

```bash
cp -v file.txt backup/
# Output: 'file.txt' -> 'backup/file.txt'
```

**Great for scripts—confirms the copy actually happened.**

---

## Recursive: Copy Directories

```bash
cp -r src/ backup/
```

**Copies entire directory tree.**

**Without -r:**
```bash
$ cp src/ backup/
cp: -r not specified; omitting directory 'src/'
```

---

## The Best Practice Combo

```bash
cp -iv source.txt destination.txt
```

**Interactive + Verbose = safe + visible**

```bash
cp -rv directory/ backup/
```

**Recursive + Verbose = see every file copied**

---

## Real Scenario: Backup Before Editing

```bash
# Before touching production config:
sudo cp -iv /etc/nginx/nginx.conf /etc/nginx/nginx.conf.backup

# Now edit safely:
sudo nano /etc/nginx/nginx.conf

# If you break it:
sudo cp -iv /etc/nginx/nginx.conf.backup /etc/nginx/nginx.conf
```

**You always have a backup.**

---

## Key Takeaway

**Always use -i** when you might overwrite  
**Always use -r** for directories  
**Use -v** when you want confirmation

**Safe copying = sleep at night.**

</div>

</details>

---

<details>
<summary><strong>4. Moving and Renaming (The Safe Way)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## mv Does Two Things

**1. Rename files**
```bash
mv oldname.txt newname.txt
```

**2. Move files**
```bash
mv file.txt /home/john/documents/
```

**Same command. Context determines which.**

---

## Why mv Instead of cp + rm?

**mv is atomic and preserves metadata:**
- Timestamps stay the same
- Permissions stay the same
- Ownership stays the same
- **Faster** (just updates directory entry, doesn't copy data)

---

## Interactive Mode

```bash
mv -i file1.txt file2.txt
```

**Prompts if destination exists:** `overwrite 'file2.txt'? (y/n)`

---

## Verbose Mode

```bash
mv -v old.txt new.txt
# Output: renamed 'old.txt' -> 'new.txt'
```

---

## Real Scenario: Rename Log File

```bash
# Rotate log file before it gets huge
mv -v /var/log/app/app.log /var/log/app/app.log.$(date +%F)

# Now you have: app.log.2025-01-15
```

---

## Real Scenario: Move to Archive

```bash
# Move old configs to archive
mkdir -p archive
mv -v *.conf.old archive/
```

---

## Key Takeaway

**mv = rename or move**  
**Use -i to be safe**  
**Use -v to see what happened**

**mv is atomic—either succeeds or fails, never half-done.**

</div>

</details>

---

<details>
<summary><strong>5. Deleting Files (And Not Regretting It)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## The Nuclear Warning

**rm has NO TRASH BIN.**

**When you delete, it's GONE.**

---

## Basic Delete

```bash
rm file.txt
```

**Permanently deletes file.txt.**

---

## Interactive Mode: Your Safety Net

```bash
rm -i file.txt
# Prompt: remove regular file 'file.txt'? (y/n)
```

**Use this when you're not 100% sure.**

---

## Deleting Directories

```bash
rm -r directory/
```

**Recursive delete—removes directory and everything inside.**

---

## Force Delete (DANGER ZONE)

```bash
rm -f file.txt
```

**Suppresses prompts. Ignores non-existent files.**

---

## The Infamous Command

```bash
rm -rf /
```

**DO NOT RUN THIS. EVER.**

**This tries to delete your entire system.**

Modern systems block it, but don't test it.

---

## The Safe Way to Delete Directories

```bash
rm -riv directory/
```

**-r** = recursive  
**-i** = interactive (asks for each file)  
**-v** = verbose (shows what's deleted)

**You see every file before it's gone.**

---

## Real Scenario: Clean Up Temp Files

```bash
# Delete all .tmp files in current directory
rm -iv *.tmp

# Safer: list first, then delete
ls *.tmp
# Confirm it's what you want
rm -v *.tmp
```

---

## Real Scenario: Remove Old Logs

```bash
# Find and delete logs older than 30 days
find /var/log/myapp -name "*.log" -mtime +30 -exec rm -v {} \;
```

---

## Pro Tip: Test with ls First

```bash
# Before:
rm *.conf

# Do this instead:
ls *.conf
# Confirm the list
rm *.conf
```

**See what you're deleting BEFORE you delete it.**

---

## Key Takeaway

**rm is permanent**  
**Use -i when unsure**  
**Test wildcards with ls first**  
**Never rm -rf unless you're 100% sure**

</div>

</details>

---

<details>
<summary><strong>6. Viewing File Contents</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## cat: Quick View

```bash
cat file.txt
```

**Dumps entire file to terminal.**

**Good for:** Small files, quick checks

**Bad for:** Large files (floods your terminal)

---

## head: First Lines

```bash
head file.txt
# Shows first 10 lines

head -n 20 file.txt
# Shows first 20 lines
```

**Perfect for:** Checking file format, seeing column headers

---

## tail: Last Lines

```bash
tail file.txt
# Shows last 10 lines

tail -n 50 file.txt
# Shows last 50 lines
```

**Perfect for:** Recent log entries

---

## tail -f: Follow Mode (THE KILLER FEATURE)

```bash
tail -f /var/log/nginx/access.log
```

**Watches file and shows new lines as they're added.**

**Press Ctrl+C to stop.**

**Use this during:**
- Deployments
- Debugging
- Monitoring live traffic

---

## less: Navigate Large Files

```bash
less large-log.txt
```

**Controls:**
- `Space` = next page
- `b` = previous page
- `/pattern` = search forward
- `?pattern` = search backward
- `q` = quit

**Why less > more:**
- Backward navigation
- Search
- Doesn't load entire file into memory

---

## Real Scenario: Check Error Logs

```bash
# See last 50 errors
tail -50 /var/log/app/error.log

# Follow errors in real-time
tail -f /var/log/app/error.log | grep "CRITICAL"
```

---

## Real Scenario: Check File Format

```bash
# See what columns a CSV has
head -1 data.csv
```

---

## Key Takeaway

**cat** = small files  
**head** = first lines  
**tail** = last lines  
**tail -f** = live monitoring  
**less** = large files, need navigation

</div>

</details>

---

<details>
<summary><strong>7. Wildcards and Pattern Matching</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## The Basics

**Wildcards (globbing) let you match multiple files.**

---

## * (Asterisk): Match Everything

```bash
ls *.txt
# Matches: file.txt, report.txt, data.txt

rm temp*
# Matches: temp, temp1, temp_backup, temperature.log

cp *.log backup/
# Copies all .log files
```

**Matches zero or more characters.**

---

## ? (Question Mark): Match One Character

```bash
ls file?.txt
# Matches: file1.txt, file2.txt, fileA.txt
# NOT: file10.txt

rm test?.log
# Matches: test1.log, test2.log
# NOT: test10.log
```

**Exactly one character.**

---

## [] (Brackets): Match Character Set

```bash
ls file[123].txt
# Matches: file1.txt, file2.txt, file3.txt
# NOT: file4.txt

ls log[A-Z].txt
# Matches: logA.txt, logB.txt, logZ.txt

ls file[0-9]*.txt
# Matches: file1.txt, file123.txt, file9backup.txt
```

---

## Negation: Match Everything Except

```bash
ls file[!0-9].txt
# Matches files NOT ending with a digit

rm *[!.txt]
# Delete everything EXCEPT .txt files
```

---

## Real Scenario: Backup Specific Files

```bash
# Backup all config files
cp -v *.conf backup/

# Backup yesterday's logs
cp -v app.log.2025-01-14* archive/

# Delete old temp files
rm temp-2024-*.txt
```

---

## Real Scenario: Process Multiple Files

```bash
# Count errors in all log files
grep -c "ERROR" *.log

# Find TODO comments in all Python files
grep "TODO" *.py
```

---

## Pro Tip: Test With ls First

```bash
# Before deleting:
rm *.tmp

# Do this:
ls *.tmp
# Verify the list
rm *.tmp
```

---

## Key Takeaway

`*` = match any characters  
`?` = match one character  
`[abc]` = match a, b, or c  
`[0-9]` = match any digit  
`[!0-9]` = match anything except digits

**Master these, operate on multiple files instantly.**

</div>

</details>

---

<details>
<summary><strong>8. Links: When and Why</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Two Types of Links

**Hard links** = point to the actual data  
**Symbolic (soft) links** = point to the filename

---

## Hard Links

```bash
ln original.txt hardlink.txt
```

**What happens:**
- Both files point to same data on disk
- Same inode number
- Delete one, the other still works
- Can't cross filesystems
- Can't link directories

**Check it:**
```bash
ls -li
# Output shows same inode:
12345678 -rw-r--r-- 2 john john 100 Jan 15 original.txt
12345678 -rw-r--r-- 2 john john 100 Jan 15 hardlink.txt
#  ↑ same inode
```

**When to use:** Backup critical files (data safe even if original deleted)

---

## Symbolic (Soft) Links

```bash
ln -s original.txt symlink.txt
```

**What happens:**
- Creates pointer to filename
- Different inode
- Delete original, link breaks
- Can cross filesystems
- Can link directories

**Check it:**
```bash
ls -l symlink.txt
# Output:
lrwxrwxrwx 1 john john 12 Jan 15 symlink.txt -> original.txt
#  ↑ 'l' means symbolic link
```

**When to use:** Shortcuts, cross-filesystem links, directory links

---

## Real Scenario: Quick Access to Logs

```bash
# Instead of cd /var/log/nginx every time:
ln -s /var/log/nginx ~/nginx-logs

# Now just:
cd ~/nginx-logs
```

---

## Real Scenario: Application Versioning

```bash
# You have multiple versions:
/opt/app-1.0/
/opt/app-1.1/
/opt/app-2.0/

# Create symlink to current version:
ln -s /opt/app-2.0 /opt/app

# Your service points to /opt/app
# To switch versions, just update the symlink:
rm /opt/app
ln -s /opt/app-1.1 /opt/app
```

**Zero downtime rollback.**

---

## Key Takeaway

**Hard link** = another name for same data  
**Soft link** = shortcut to filename

**Use soft links for:**
- Shortcuts
- Version management
- Directory links

**Use hard links for:**
- Backup files (survives deletion)

</div>

</details>

---

<details>
<summary><strong>9. Real Production Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Scenario 1: Backup Config Before Editing

### **Problem:**
Need to edit production config. If you break it, you're in trouble.

### **Solution:**

```bash
# Always backup first
sudo cp -iv /etc/nginx/nginx.conf /etc/nginx/nginx.conf.backup

# Edit
sudo nano /etc/nginx/nginx.conf

# Test
sudo nginx -t

# If broken, restore:
sudo cp -iv /etc/nginx/nginx.conf.backup /etc/nginx/nginx.conf
```

---

## Scenario 2: Watch Deployment Logs

### **Problem:**
Deployment running. Need to see if errors occur.

### **Solution:**

```bash
tail -f /var/log/app/deploy.log
```

**Or filter for errors:**
```bash
tail -f /var/log/app/deploy.log | grep -i error
```

---

## Scenario 3: Find Large Log Files

### **Problem:**
Disk full. Need to find what's eating space.

### **Solution:**

```bash
cd /var/log
ls -lhS | head -10

# Output shows largest files first:
-rw-r--r-- 1 root root 2.1G Jan 15 access.log
```

**Truncate it:**
```bash
sudo truncate -s 0 access.log
# Or:
sudo > access.log
```

---

## Scenario 4: Rotate Old Logs

### **Problem:**
Log file getting huge. Need to archive it.

### **Solution:**

```bash
# Rename with date
mv app.log app.log.$(date +%F)

# Compress
gzip app.log.2025-01-15

# Result: app.log.2025-01-15.gz
```

---

## Scenario 5: Copy All Configs to Backup

### **Problem:**
Need to backup all .conf files before upgrade.

### **Solution:**

```bash
mkdir -p /backup/configs-$(date +%F)
cp -v /etc/*.conf /backup/configs-$(date +%F)/
```

---

## Scenario 6: Delete Old Temp Files

### **Problem:**
/tmp filling up with old files.

### **Solution:**

```bash
# See what's there
ls -lht /tmp | head -20

# Delete files older than 7 days
find /tmp -type f -mtime +7 -exec rm -v {} \;
```

---

## Scenario 7: Monitor Multiple Log Files

### **Problem:**
Need to watch app log AND nginx log simultaneously.

### **Solution:**

```bash
# Terminal 1:
tail -f /var/log/app/app.log

# Terminal 2:
tail -f /var/log/nginx/error.log
```

**Or use multitail (if installed):**
```bash
multitail /var/log/app/app.log /var/log/nginx/error.log
```

---

## Key Takeaway

**Always backup before editing**  
**Use tail -f to monitor live**  
**Test wildcards with ls first**  
**Compress old logs to save space**

</div>

</details>

---

<details>
<summary><strong>10. Quick Command Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Creating Files

```bash copy
touch file.txt   # create empty file
```

```bash copy
echo "content" > file.txt   # create file with content
```

```bash copy
cat > file.txt   # create file, type content, Ctrl+D to finish
```

```bash copy
file myfile   # identify file type
```

```bash copy
stat file.txt   # show detailed file info
```

---

## Copying Files

```bash copy
cp source.txt dest.txt   # copy file
```

```bash copy
cp -i source.txt dest.txt   # copy with prompt before overwrite
```

```bash copy
cp -v source.txt dest.txt   # copy with verbose output
```

```bash copy
cp -iv source.txt dest.txt   # interactive + verbose (safe)
```

```bash copy
cp -r source/ dest/   # copy directory recursively
```

```bash copy
cp -rv source/ dest/   # recursive + verbose
```

```bash copy
cp *.txt backup/   # copy all .txt files
```

---

## Moving/Renaming Files

```bash copy
mv old.txt new.txt   # rename file
```

```bash copy
mv file.txt /path/to/dir/   # move file
```

```bash copy
mv -i old.txt new.txt   # prompt before overwrite
```

```bash copy
mv -v old.txt new.txt   # show what was renamed
```

```bash copy
mv *.log archive/   # move all .log files
```

---

## Deleting Files

```bash copy
rm file.txt   # delete file
```

```bash copy
rm -i file.txt   # prompt before delete
```

```bash copy
rm -v file.txt   # show what was deleted
```

```bash copy
rm -r directory/   # delete directory recursively
```

```bash copy
rm -riv directory/   # recursive + interactive + verbose (safest)
```

```bash copy
rm *.tmp   # delete all .tmp files
```

```bash copy
rm -f file.txt   # force delete (no prompt)
```

---

## Viewing File Contents

```bash copy
cat file.txt   # display entire file
```

```bash copy
cat -n file.txt   # display with line numbers
```

```bash copy
tac file.txt   # display in reverse order
```

```bash copy
head file.txt   # show first 10 lines
```

```bash copy
head -n 20 file.txt   # show first 20 lines
```

```bash copy
tail file.txt   # show last 10 lines
```

```bash copy
tail -n 50 file.txt   # show last 50 lines
```

```bash copy
tail -f file.txt   # follow file in real-time (Ctrl+C to stop)
```

```bash copy
tail -f log.txt | grep ERROR   # follow and filter for errors
```

```bash copy
less file.txt   # view file with navigation (q to quit)
```

```bash copy
more file.txt   # page through file (legacy, use less)
```

---

## Wildcards and Patterns

```bash copy
ls *.txt   # match all .txt files
```

```bash copy
ls file?.txt   # match file1.txt, file2.txt (one char)
```

```bash copy
ls file[123].txt   # match file1.txt, file2.txt, file3.txt
```

```bash copy
ls file[0-9].txt   # match file0.txt through file9.txt
```

```bash copy
ls file[!0-9].txt   # match files NOT ending with digit
```

```bash copy
rm temp*   # delete all files starting with "temp"
```

```bash copy
cp *.conf backup/   # copy all .conf files
```

---

## Redirection

```bash copy
command > file.txt   # redirect output to file (overwrite)
```

```bash copy
command >> file.txt   # redirect output to file (append)
```

```bash copy
command 2> errors.txt   # redirect errors to file
```

```bash copy
command &> all.txt   # redirect both output and errors
```

```bash copy
command > /dev/null   # discard output
```

```bash copy
command > /dev/null 2>&1   # discard all output and errors
```

```bash copy
wc -l < file.txt   # use file as input
```

```bash copy
sort < unsorted.txt > sorted.txt   # sort file
```

---

## Pipes

```bash copy
cat file.txt | grep "pattern"   # search in file
```

```bash copy
ls -l | grep ".txt"   # filter ls output
```

```bash copy
cat log.txt | grep ERROR | wc -l   # count errors
```

```bash copy
ps aux | grep nginx   # find nginx processes
```

```bash copy
history | grep docker   # search command history
```

```bash copy
ls | wc -l   # count files in directory
```

```bash copy
tail -f log.txt | grep CRITICAL   # watch for critical errors
```

---

## Links

```bash copy
ln original.txt hardlink.txt   # create hard link
```

```bash copy
ln -s original.txt symlink.txt   # create symbolic link
```

```bash copy
ln -s /var/log/nginx ~/logs   # create shortcut to directory
```

```bash copy
ls -li   # show inode numbers (check hard links)
```

```bash copy
ls -l symlink   # show where symbolic link points
```

```bash copy
readlink symlink.txt   # show target of symbolic link
```

---

## Text Editors

```bash copy
nano file.txt   # edit with nano (beginner-friendly)
```

```bash copy
vi file.txt   # edit with vi/vim
```

```bash copy
vim file.txt   # edit with vim (improved vi)
```

---

## Finding Files

```bash copy
find . -name "*.txt"   # find all .txt files in current dir
```

```bash copy
find /var/log -name "*.log" -mtime +7   # find logs older than 7 days
```

```bash copy
find . -type f -size +100M   # find files larger than 100MB
```

```bash copy
find . -name "*.tmp" -delete   # find and delete .tmp files
```

---

## Combining Commands

```bash copy
ls -lh | sort -k5 -n   # list files sorted by size
```

```bash copy
cat file.txt | grep -i error | wc -l   # count errors (case insensitive)
```

```bash copy
find . -name "*.log" | xargs gzip   # compress all log files
```

```bash copy
ls -lt | head -5 > recent.txt   # save 5 newest files to file
```

</div>

</details>

---
# **07. Processes & System Info — What's Running and How It's Performing**
> Monitor, troubleshoot, and control running programs

---

## What We'll Cover

- [1. Why You Need to See What's Running](#1-why-you-need-to-see-whats-running)
- [2. Understanding Processes and PIDs](#2-understanding-processes-and-pids)
- [3. Viewing Processes (ps, top, htop)](#3-viewing-processes)
- [4. System Resources (CPU, Memory, Disk)](#4-system-resources)
- [5. Killing Processes (The Right Way)](#5-killing-processes)
- [6. Real Production Scenarios](#6-real-production-scenarios)
- [7. Quick Command Reference](#7-quick-command-reference)

---

<details>
<summary><strong>1. Why You Need to See What's Running</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## The 2 AM Phone Call

**"The server is slow!"**

You SSH in. Now what?

**You need to answer:**
- What's consuming 100% CPU?
- Is memory full?
- Is disk space gone?
- Which process is the culprit?
- Can I kill it safely?

**Fast answers = fast fixes.**

---

## The Scenarios You'll Face

**Production down:**
- "Application not responding"
- "API timeouts"
- "Login page freezing"

**Resource exhaustion:**
- "Server running out of memory"
- "CPU pegged at 100%"
- "Disk full, services failing"

**Runaway processes:**
- "Background job consuming all CPU"
- "Memory leak in application"
- "Zombie processes piling up"

---

## What Most People Miss

They know `ps` exists. But they don't know:
- **How to find resource hogs instantly**
- **The difference between kill -15 and kill -9**
- **What load average actually means**
- **How to read memory usage correctly**

**After this file, you'll diagnose performance issues like a pro.**

</div>

</details>

---

<details>
<summary><strong>2. Understanding Processes and PIDs</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## What Is a Process?

**A process = running instance of a program.**

**When you run a command:**
```bash
firefox &
# [1] 12345
```

**The kernel:**
1. Loads the program into memory
2. Assigns it a unique ID: **PID 12345**
3. Starts executing it

---

## PIDs: The Actual Identity

**Every process has:**
- **PID** (Process ID) — unique number
- **PPID** (Parent Process ID) — who created it
- **Owner** (user running it)
- **State** (running, sleeping, zombie)

```bash
echo $$
# Output: 2891
# This is your shell's PID
```

---

## Process Hierarchy

**Everything starts from PID 1 (systemd):**

```
systemd (1)
├── sshd (890)
│   └── bash (2891) ← your SSH session
│       └── python app.py (5432) ← your app
├── nginx (1234)
│   ├── worker (1235)
│   └── worker (1236)
└── postgresql (987)
```

**Key concepts:**
- Every process (except PID 1) has a parent
- Kill parent → usually kills children
- Orphaned children get adopted by systemd

---

## Process States

| State | Symbol | Meaning |
|-------|--------|---------|
| **Running** | R | Actually executing on CPU |
| **Sleeping** | S | Waiting for something (interruptible) |
| **Disk Wait** | D | Waiting for disk I/O (uninterruptible) |
| **Stopped** | T | Paused (Ctrl+Z) |
| **Zombie** | Z | Finished but parent hasn't read exit code |

**Most processes are sleeping most of the time.**

**Many processes in D state = disk bottleneck.**

**Accumulating zombies = buggy parent process.**

---

## Quick Process Checks

```bash
# Your shell's PID
echo $$

# See process tree
pstree

# All processes for your user
ps u

# All processes on system
ps aux
```

</div>

</details>

---

<details>
<summary><strong>3. Viewing Processes (ps, top, htop)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## ps: Snapshot of Processes

**The go-to command:**
```bash
ps aux
```

**Output explained:**
```
USER    PID %CPU %MEM    VSZ   RSS STAT START   TIME COMMAND
john   1234  25.0  5.2 123456 78900 S   10:30   0:15 python app.py
```

**Columns:**
- **USER** — who owns it
- **PID** — process ID
- **%CPU** — CPU usage percentage
- **%MEM** — memory usage percentage
- **RSS** — physical RAM used (KB)
- **STAT** — state (R/S/D/Z/T)
- **COMMAND** — what's running

---

## Finding the Culprits

**Top CPU consumers:**
```bash
ps aux --sort=-%cpu | head -10
```

**Top memory consumers:**
```bash
ps aux --sort=-%mem | head -10
```

**Find specific process:**
```bash
ps aux | grep nginx
```

**Better way:**
```bash
pgrep -a nginx
# Output: 1234 nginx: master process
```

---

## top: Live Monitoring

**Real-time view:**
```bash
top
```

**Top section shows:**
```
load average: 2.15, 1.90, 1.75
Tasks: 250 total, 2 running, 248 sleeping
%Cpu(s): 25.0 us,  5.0 sy,  0.0 ni, 70.0 id
MiB Mem : 15872 total,  6543 free,  8234 used
```

**Interactive commands while running:**
- **M** — sort by memory
- **P** — sort by CPU
- **k** — kill process (prompts for PID)
- **1** — show individual CPU cores
- **q** — quit

---

## htop: Better Than top

**Install it:**
```bash
sudo apt install htop
```

**Run it:**
```bash
htop
```

**Why it's better:**
- Color-coded CPU/memory bars
- Mouse support
- Visual process tree (F5)
- Easy process killing (F9)
- Search and filter

**Keyboard shortcuts:**
- **F3** — search
- **F4** — filter
- **F5** — tree view
- **F6** — sort
- **F9** — kill
- **q** — quit

---

## Real Scenario: Find CPU Hog

```bash
# Quick snapshot approach
ps aux --sort=-%cpu | head -5

# Live monitoring approach
htop
# Press F6, select CPU%, press Enter
# Top process is the culprit
```

---

## Real Scenario: Is nginx Running?

```bash
pgrep nginx
# If output: yes
# If nothing: no

# With details:
pgrep -a nginx
# Output: 1234 nginx: master process

# Full status:
ps aux | grep nginx
```

---

## Key Takeaway

**ps aux** = snapshot of all processes  
**ps aux --sort=-%cpu** = find CPU hogs  
**ps aux --sort=-%mem** = find memory hogs  
**top** = live monitoring  
**htop** = better live monitoring  
**pgrep** = find by name

</div>

</details>

---

<details>
<summary><strong>4. System Resources (CPU, Memory, Disk)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Load Average: Is CPU Overloaded?

**Check it:**
```bash
uptime
# Output: load average: 2.15, 1.90, 1.75
#                        1min  5min  15min
```

**What it means:**
Number of processes waiting for CPU time.

**Interpretation (4-core system):**
- **Load = 4.0** → 100% utilized (fully busy)
- **Load = 2.0** → 50% utilized (half busy)
- **Load = 8.0** → 200% utilized (processes queuing)
- **Load = 16.0** → 400% utilized (severe bottleneck)

**Rule of thumb:**
```
Load < Cores → Underutilized
Load = Cores → Fully utilized
Load > Cores → Overloaded (queuing)
```

**Check your core count:**
```bash
nproc
# Output: 4
```

**So for 4 cores:**
- Load 4.0 or less = OK
- Load 8.0+ = Problem

---

## Memory: Is RAM Full?

**Check it:**
```bash
free -h
```

**Output:**
```
              total   used   free   shared  buff/cache   available
Mem:           15Gi   8.2Gi  2.1Gi    324Mi       5.0Gi        6.5Gi
Swap:         2.0Gi      0B  2.0Gi
```

**CRITICAL: Look at "available", not "free"!**

**Why?**
Linux caches aggressively. Low "free" is normal and GOOD.

**What matters:**
- **available = 6.5Gi** → This much RAM available for new apps
- **swap used = 0B** → No swapping (good)

**Warning signs:**
- **available < 1GB** → Low memory
- **swap used > 0** → System swapping (slow)
- **swap used = 2GB** → Serious memory pressure

**Find memory hogs:**
```bash
ps aux --sort=-%mem | head -10
```

---

## Disk: Is Space Full?

**Check filesystems:**
```bash
df -h
```

**Output:**
```
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        50G   30G   18G  63% /
/dev/sdb1       100G   85G   10G  90% /var
```

**Thresholds:**
- **< 80%** — Healthy
- **80-90%** — Monitor closely
- **> 90%** — Take action
- **100%** — Services will fail

**Find large directories:**
```bash
du -h --max-depth=1 /var | sort -rh | head -10
```

**Find large files:**
```bash
find /var -type f -size +100M -exec ls -lh {} \;
```

**Interactive disk explorer:**
```bash
sudo apt install ncdu
ncdu /var
```

---

## Real Scenario: Server Slow, Why?

```bash
# Step 1: Check load
uptime
# load average: 12.5, 10.2, 8.1
# (4-core system)
# Conclusion: SEVERELY overloaded

# Step 2: Find CPU hog
ps aux --sort=-%cpu | head -5
# john 5432 250.0 ... python runaway_job.py
# Found it!

# Step 3: Kill it
kill 5432
```

---

## Real Scenario: Out of Memory

```bash
# Step 1: Check memory
free -h
# available: 256M (only 256MB left!)
# swap used: 1.8GB (swapping heavily)
# Conclusion: Memory exhausted

# Step 2: Find memory hog
ps aux --sort=-%mem | head -5
# john 8765 45.2 ... java -Xmx8g app.jar
# Java app using 45% of RAM

# Step 3: Fix it
kill 8765
# or
systemctl restart myapp
```

---

## Real Scenario: Disk Full

```bash
# Step 1: Check disk
df -h
# /dev/sda1  98% used
# Conclusion: Almost full

# Step 2: Find culprit
du -h --max-depth=1 /var | sort -rh | head -5
# 15G /var/log
# Found it!

# Step 3: Check logs
du -h --max-depth=1 /var/log | sort -rh | head -5
# 12G /var/log/nginx
# Nginx logs huge

# Step 4: Clean up
sudo truncate -s 0 /var/log/nginx/access.log
# or
sudo logrotate -f /etc/logrotate.conf
```

---

## Quick System Health Check

```bash
# CPU
uptime

# Memory
free -h

# Disk
df -h

# Top processes
ps aux --sort=-%cpu | head -5
ps aux --sort=-%mem | head -5
```

</div>

</details>

---

<details>
<summary><strong>5. Killing Processes (The Right Way)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Signals: Talking to Processes

**Signals = messages you send to processes.**

**The important ones:**

| Signal | Number | Effect | When to Use |
|--------|--------|--------|-------------|
| **SIGTERM** | 15 | Graceful shutdown | Default (always try first) |
| **SIGKILL** | 9 | Force kill | Last resort |
| **SIGHUP** | 1 | Reload config | Restart without stopping |
| **SIGINT** | 2 | Interrupt (Ctrl+C) | Stop foreground process |

---

## SIGTERM (15): The Polite Way

**What it does:**
Asks process to shut down gracefully.

**Process can:**
- Save state
- Close files properly
- Flush buffers
- Release resources cleanly

**Send it:**
```bash
kill 1234
# Same as: kill -15 1234
```

**Always try this first.**

---

## SIGKILL (9): The Force

**What it does:**
Immediately terminates. Process can't catch or ignore it.

**Process cannot:**
- Save state
- Clean up
- Do anything

**It just dies. Immediately.**

**Send it:**
```bash
kill -9 1234
```

**When to use:**
- Process ignoring SIGTERM
- Process stuck (unresponsive)
- Emergency situations

**Don't use as first resort.**

---

## SIGHUP (1): Reload Config

**What it does:**
Tells process to reload configuration without restarting.

**Send it:**
```bash
kill -1 1234
```

**Use case:**
```bash
# Edit nginx config
sudo vim /etc/nginx/nginx.conf

# Reload without downtime
sudo kill -HUP $(cat /var/run/nginx.pid)
```

---

## Killing by PID

```bash
# Graceful (try this first)
kill 1234

# Force (last resort)
kill -9 1234

# Reload config
kill -1 1234
```

---

## Killing by Name

```bash
# Graceful
pkill nginx

# Force
pkill -9 nginx

# Specific user
pkill -u john
```

**Or use killall:**
```bash
killall nginx
killall -9 nginx
```

**Difference:**
- **pkill nginx** matches "nginx", "nginx-worker", etc.
- **killall nginx** only matches exactly "nginx"

---

## The Right Kill Sequence

```bash
# Step 1: Try graceful
kill 1234

# Step 2: Wait 5 seconds
sleep 5

# Step 3: Check if still running
ps -p 1234

# Step 4: If still there, force kill
kill -9 1234
```

---

## Real Scenario: App Not Responding

```bash
# Find it
ps aux | grep myapp
# john 5432 ... python myapp.py

# Try graceful
kill 5432

# Wait a bit
sleep 5

# Still there?
ps -p 5432
# Yes, it's stuck

# Force kill
kill -9 5432

# Verify it's gone
ps -p 5432
# No such process (success)
```

---

## Real Scenario: Kill All User Processes

```bash
# User left, kill everything
pkill -u olduser

# Force kill if needed
pkill -9 -u olduser
```

---

## Zombie Processes

**What are they?**
Process finished but parent hasn't collected exit code.

**Are they dangerous?**
Usually no. They use no CPU/memory, just a PID slot.

**When to worry:**
If hundreds/thousands accumulate.

**How to fix:**
Kill the PARENT, not the zombie.

```bash
# Find zombies
ps aux | grep Z

# Find parent
ps -o pid,ppid,stat,cmd | grep Z
# PID 5678, PPID 1234, Z

# Kill parent
kill 1234

# Zombies disappear
```

---

## Key Takeaway

**Always try kill (SIGTERM) first**  
**Use kill -9 (SIGKILL) only when necessary**  
**kill -1 (SIGHUP) reloads config**  
**pkill kills by name**  
**Zombies: kill the parent, not the zombie**

</div>

</details>

---

<details>
<summary><strong>6. Real Production Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Scenario 1: CPU at 100%, Server Slow

### **Problem:**
Users complaining site is slow. Server unresponsive.

### **Diagnosis:**
```bash
uptime
# load average: 24.5, 18.2, 12.1
# (4-core system = severely overloaded)

top
# Press M to sort by CPU
# PID 5432: python script.py using 380% CPU
```

### **Solution:**
```bash
kill 5432

# Verify
uptime
# load average: 1.2, 5.5, 8.3
# (load dropping)
```

---

## Scenario 2: Memory Exhausted

### **Problem:**
Applications crashing with OOM (Out of Memory) errors.

### **Diagnosis:**
```bash
free -h
# available: 128M (critically low)
# swap used: 2.0G (swapping heavily)

ps aux --sort=-%mem | head -5
# john 8765 85.2 ... java -Xmx12g app.jar
# Java app using 85% of RAM
```

### **Solution:**
```bash
# Kill memory hog
kill 8765

# Or restart with lower memory
# Edit config to use -Xmx4g instead
systemctl restart myapp

# Verify
free -h
# available: 8.5G (recovered)
```

---

## Scenario 3: Disk Full, Services Failing

### **Problem:**
Can't write logs. Database failing. Deployments broken.

### **Diagnosis:**
```bash
df -h
# /var  99%  (disk full)

du -h --max-depth=1 /var | sort -rh | head -5
# 45G /var/log
# 38G /var/log/application

ls -lh /var/log/application
# -rw-r--r-- 35G app.log
# Single 35GB log file!
```

### **Solution:**
```bash
# Truncate huge log
sudo truncate -s 0 /var/log/application/app.log

# Or compress and archive
sudo gzip /var/log/application/app.log
sudo mv /var/log/application/app.log.gz /archive/

# Verify
df -h
# /var  62%  (space recovered)
```

---

## Scenario 4: Process Won't Die

### **Problem:**
```bash
kill 1234
sleep 5
ps -p 1234
# Still running!
```

### **Solution:**
```bash
# Check state
ps aux | grep 1234
# STAT: D (uninterruptible disk wait)

# Can't be killed normally
# Try SIGKILL
kill -9 1234

# Still won't die? (rare)
# Probably waiting on NFS or broken disk
# Reboot may be only option (or fix underlying issue)
```

---

## Scenario 5: Find What's Using Port 80

### **Problem:**
Can't start nginx: "port 80 already in use"

### **Diagnosis:**
```bash
sudo lsof -i :80
# COMMAND  PID USER
# apache2  5432 root
```

### **Solution:**
```bash
# Apache is running, not nginx
sudo systemctl stop apache2

# Now start nginx
sudo systemctl start nginx
```

---

## Scenario 6: Accumulating Zombie Processes

### **Problem:**
```bash
ps aux | grep Z | wc -l
# 245
# 245 zombie processes!
```

### **Diagnosis:**
```bash
ps -o pid,ppid,stat,cmd | grep Z | head -5
# All have same PPID: 1234

ps -p 1234
# supervisord (buggy supervisor)
```

### **Solution:**
```bash
# Kill parent process
sudo systemctl restart supervisor

# Verify zombies gone
ps aux | grep Z | wc -l
# 0
```

---

## Scenario 7: Find Process Eating Bandwidth

### **Problem:**
Network saturated. What's causing it?

### **Diagnosis:**
```bash
# Install nethogs
sudo apt install nethogs

# Monitor bandwidth per process
sudo nethogs

# PID 7654: wget downloading at 95 Mbps
```

### **Solution:**
```bash
kill 7654
```

---

## Key Takeaway

**Check load, memory, disk first**  
**Use ps/top/htop to find culprits**  
**Try graceful kill before force kill**  
**Truncate huge logs to free disk**  
**Zombies: kill parent, not zombie**  
**lsof finds what's using ports**

</div>

</details>

---

<details>
<summary><strong>7. Quick Command Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Viewing Processes

```bash copy
ps aux   # all processes
```

```bash copy
ps aux | grep nginx   # find nginx processes
```

```bash copy
ps aux --sort=-%cpu | head -10   # top CPU users
```

```bash copy
ps aux --sort=-%mem | head -10   # top memory users
```

```bash copy
ps -p 1234   # specific PID
```

```bash copy
ps -u john   # processes for user john
```

```bash copy
pgrep nginx   # find PID by name
```

```bash copy
pgrep -a nginx   # find PID with full command
```

```bash copy
pgrep -u john   # PIDs for user john
```

```bash copy
pstree   # process tree
```

```bash copy
ps auxf   # process tree (alternative)
```

---

## Real-Time Monitoring

```bash copy
top   # live process monitor
```

```bash copy
htop   # better live monitor (install first)
```

```bash copy
top -u john   # top for specific user
```

**Top interactive commands:**
- `M` — sort by memory
- `P` — sort by CPU
- `k` — kill process
- `1` — show all CPUs
- `q` — quit

---

## System Resources

```bash copy
uptime   # load average
```

```bash copy
nproc   # number of CPU cores
```

```bash copy
lscpu   # detailed CPU info
```

```bash copy
free -h   # memory usage
```

```bash copy
df -h   # disk usage by filesystem
```

```bash copy
df -i   # inode usage
```

```bash copy
du -sh /var/log   # directory size
```

```bash copy
du -h --max-depth=1 /var | sort -rh | head -10   # largest dirs
```

```bash copy
ncdu /var   # interactive disk explorer
```

```bash copy
find /var -type f -size +100M   # find files >100MB
```

---

## Killing Processes

```bash copy
kill 1234   # graceful (SIGTERM)
```

```bash copy
kill -15 1234   # same as above
```

```bash copy
kill -9 1234   # force kill (SIGKILL)
```

```bash copy
kill -1 1234   # reload config (SIGHUP)
```

```bash copy
kill -l   # list all signals
```

```bash copy
pkill nginx   # kill by name
```

```bash copy
pkill -9 nginx   # force kill by name
```

```bash copy
pkill -u john   # kill all john's processes
```

```bash copy
killall nginx   # kill by exact name
```

```bash copy
killall -9 nginx   # force kill by exact name
```

---

## Process States and Info

```bash copy
ps aux | grep Z   # find zombie processes
```

```bash copy
ps -o pid,ppid,stat,cmd   # show parent PIDs and states
```

```bash copy
ps -p 1234 -o pid,ppid,user,%cpu,%mem,stat,cmd   # detailed info
```

```bash copy
echo $$   # your shell's PID
```

```bash copy
cat /proc/1234/status   # detailed process status
```

---

## Network and Ports

```bash copy
ss -tulpn   # listening ports
```

```bash copy
netstat -tulpn   # listening ports (older)
```

```bash copy
lsof -i :80   # what's using port 80
```

```bash copy
lsof -i -P   # all network connections
```

```bash copy
lsof -u john   # files opened by user
```

---

## System Information

```bash copy
uname -a   # kernel and system info
```

```bash copy
uname -r   # kernel version
```

```bash copy
cat /etc/os-release   # OS info
```

```bash copy
hostname   # system hostname
```

```bash copy
cat /proc/cpuinfo   # CPU details
```

```bash copy
cat /proc/meminfo   # memory details
```

```bash copy
dmesg | tail -50   # last 50 kernel messages
```

```bash copy
journalctl -f   # follow system journal
```

---

## Performance Analysis

```bash copy
vmstat 1   # system stats every second
```

```bash copy
iostat   # CPU and I/O stats
```

```bash copy
iotop   # top for I/O (needs install)
```

```bash copy
nethogs   # bandwidth per process (needs install)
```

---

## Quick Health Check

```bash copy
uptime && free -h && df -h   # one-liner health check
```

```bash copy
ps aux --sort=-%cpu | head -5   # top CPU processes
```

```bash copy
ps aux --sort=-%mem | head -5   # top memory processes
```

</div>

</details>

---
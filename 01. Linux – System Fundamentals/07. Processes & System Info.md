# **07. Processes & System Info — Monitoring and Managing Running Programs**
> Understanding what's running, how it performs, and how to control it.

---

## Table of Contents
- [1. Why Process Visibility Matters in Production](#1-why-process-visibility-matters-in-production)
- [2. Understanding Processes and PIDs](#2-understanding-processes-and-pids)
- [3. Viewing Active Processes](#3-viewing-active-processes)
- [4. Real-Time Monitoring with top and htop](#4-real-time-monitoring-with-top-and-htop)
- [5. CPU Load and System Performance](#5-cpu-load-and-system-performance)
- [6. Memory Usage Analysis](#6-memory-usage-analysis)
- [7. Disk Space Management](#7-disk-space-management)
- [8. Controlling Processes: Signals and Termination](#8-controlling-processes-signals-and-termination)
- [9. Troubleshooting Zombie Processes](#9-troubleshooting-zombie-processes)
- [10. Real-World Scenarios](#10-real-world-scenarios)
- [11. Commands Reference](#11-commands-reference)
- [12. Quick Takeaways](#12-quick-takeaways)

---

<details>
<summary><strong>1. Why Process Visibility Matters in Production</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every application running on your server is a process.

When something goes wrong:
- CPU spikes to 100%
- Memory runs out
- Application becomes unresponsive
- Disk fills up

You need to know:
- What's running right now?
- Which process is consuming resources?
- How do I stop a misbehaving process?
- Is the system healthy?

This file teaches you to see inside your running system, identify problems, and fix them before users notice.

</div>

</details>

---

<details>
<summary><strong>2. Understanding Processes and PIDs</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-001 — What is a Process?

A process is a running instance of a program.

When you run `nginx`, the kernel:
1. Loads the binary from disk
2. Allocates memory
3. Assigns a unique Process ID (PID)
4. Gives it CPU time
5. Tracks its state

**Process Identity:**
- **PID** — unique number identifying this process
- **PPID** — parent process ID (who started it)
- **UID** — user who owns the process
- **GID** — group the process belongs to

**Example:**
```bash copy
ps aux | grep nginx
# Output: root  1234  ... /usr/sbin/nginx
```

Here, `1234` is the PID.

---

### PROC-002 — Process States

Every process is in one of these states:

| State | Code | Meaning                                    |
|-------|------|-------------------------------------------|
| Running | `R` | Executing on CPU or ready to run        |
| Sleeping | `S` | Waiting for event (I/O, network, etc.) |
| Disk Sleep | `D` | Uninterruptible sleep (waiting for disk) |
| Stopped | `T` | Paused (by Ctrl+Z or signal)           |
| Zombie | `Z` | Finished but parent hasn't cleaned up   |

**Why This Matters:**
- Most processes are `S` (sleeping, waiting for work)
- `D` processes can't be killed (waiting for hardware)
- `Z` processes are dead but still listed (usually harmless)

**Checking State:**
```bash copy
ps aux
# Look at STAT column
```

---

### PROC-003 — Process Hierarchy

All processes form a tree starting from PID 1 (systemd on modern systems).

```
systemd (PID 1)
├── sshd (PID 850)
│   └── bash (PID 2341) — your SSH session
│       └── vim (PID 2890) — your editor
├── nginx (PID 1234)
│   ├── nginx worker (PID 1235)
│   └── nginx worker (PID 1236)
└── docker (PID 950)
    └── container process (PID 3456)
```

**Why Hierarchy Matters:**
- Killing a parent kills its children
- Orphaned processes get adopted by PID 1
- Understanding relationships helps debugging

**Viewing Tree:**
```bash copy
pstree
# OR
ps auxf
```

</div>

</details>

---

<details>
<summary><strong>3. Viewing Active Processes</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-004 — ps Command (Snapshot View)

**`ps`** shows a snapshot of current processes.

**Most Useful Format:**
```bash copy
ps aux
```

**Output Columns:**
```
USER  PID  %CPU  %MEM    VSZ   RSS  TTY  STAT  START  TIME  COMMAND
root  1234  0.1   2.3  125304 45632 ?   Ss   10:23  0:05  /usr/sbin/nginx
```

**Column Meanings:**
- `USER` — who owns the process
- `PID` — process ID
- `%CPU` — CPU usage percentage
- `%MEM` — memory usage percentage
- `VSZ` — virtual memory size (KB)
- `RSS` — resident set size (actual RAM used, KB)
- `TTY` — terminal (? means no terminal)
- `STAT` — process state
- `START` — when process started
- `TIME` — total CPU time used
- `COMMAND` — the command running

---

### PROC-005 — Common ps Patterns

**All processes:**
```bash copy
ps aux
```

**Just your processes:**
```bash copy
ps ux
```

**Processes for specific user:**
```bash copy
ps -u akhil
```

**Find specific process:**
```bash copy
ps aux | grep nginx
```

**Process tree:**
```bash copy
ps auxf
# OR
ps -ejH
```

**Custom columns:**
```bash copy
ps -eo pid,ppid,cmd,%mem,%cpu --sort=-%mem
# Shows PID, parent PID, command, memory, CPU sorted by memory
```

---

### PROC-006 — pgrep (Find by Name)

**Find PID by name:**
```bash copy
pgrep nginx
# Output: 1234
#         1235
#         1236
```

**With details:**
```bash copy
pgrep -a nginx
# Output: 1234 nginx: master process
#         1235 nginx: worker process
```

**Count processes:**
```bash copy
pgrep -c nginx
# Output: 3
```

</div>

</details>

---

<details>
<summary><strong>4. Real-Time Monitoring with top and htop</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-007 — top (Built-in Real-Time Monitor)

**`top`** shows live, updating view of processes.

```bash copy
top
```

**Header Explains:**
```
top - 14:23:15 up 5 days,  3:42,  2 users,  load average: 0.45, 0.32, 0.28
Tasks: 215 total,   1 running, 214 sleeping,   0 stopped,   0 zombie
%Cpu(s):  3.2 us,  1.1 sy,  0.0 ni, 95.5 id,  0.2 wa,  0.0 hi,  0.0 si,  0.0 st
MiB Mem :   7842.5 total,    342.1 free,   4521.3 used,   2979.1 buff/cache
MiB Swap:   2048.0 total,   2048.0 free,      0.0 used.   2901.2 avail Mem
```

**Key Metrics:**
- Load average (explained next section)
- Running/sleeping processes
- CPU breakdown (user, system, idle, wait)
- Memory (total, free, used, cache)

**Interactive Commands:**
- `k` — kill a process (enter PID)
- `r` — renice (change priority)
- `M` — sort by memory
- `P` — sort by CPU (default)
- `c` — show full command
- `q` — quit

---

### PROC-008 — htop (Enhanced Monitor)

**`htop`** is top with better UI and features.

**Installing:**
```bash copy
sudo apt install htop     # Debian/Ubuntu
sudo yum install htop     # RHEL/CentOS
```

**Running:**
```bash copy
htop
```

**Advantages over top:**
- Color-coded display
- Mouse support
- Easier to kill processes (F9)
- Tree view (F5)
- Search (F3)
- Filter (F4)

**Why Use htop:**
- Faster visual identification of problems
- More intuitive controls
- Better for interactive troubleshooting

</div>

</details>

---

<details>
<summary><strong>5. CPU Load and System Performance</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-009 — Load Average Explained

**What is Load Average?**
The number of processes waiting for CPU time.

**Viewing Load:**
```bash copy
uptime
# Output: 14:23:15 up 5 days, 3:42, 2 users, load average: 0.45, 0.32, 0.28
```

**Three Numbers:**
- **0.45** — 1-minute average
- **0.32** — 5-minute average
- **0.28** — 15-minute average

**Interpreting Load:**
On a 4-CPU system:
- Load of 4.0 = 100% utilized (healthy)
- Load of 2.0 = 50% utilized (plenty of room)
- Load of 8.0 = 200% utilized (processes waiting)

**Rule of Thumb:**
Load should be less than number of CPU cores.

**Checking CPU Count:**
```bash copy
nproc
# Output: 4
```

Or:
```bash copy
lscpu | grep "^CPU(s):"
# Output: CPU(s): 4
```

---

### PROC-010 — uptime Command

Shows how long system has been running and load average.

```bash copy
uptime
# Output: 14:23:15 up 5 days, 3:42, 2 users, load average: 0.45, 0.32, 0.28
```

**Fields:**
- Current time
- System uptime
- Logged-in users
- Load averages (1m, 5m, 15m)

**Use Case:**
Quick health check — high load means investigation needed.

</div>

</details>

---

<details>
<summary><strong>6. Memory Usage Analysis</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-011 — free Command

Shows memory usage in human-readable format.

```bash copy
free -h
```

**Output:**
```
              total        used        free      shared  buff/cache   available
Mem:          7.7Gi       4.4Gi       334Mi       156Mi       2.9Gi       2.8Gi
Swap:         2.0Gi          0B       2.0Gi
```

**Column Meanings:**
- `total` — total physical RAM
- `used` — RAM used by processes
- `free` — completely unused RAM
- `shared` — shared memory (tmpfs, etc.)
- `buff/cache` — RAM used for caching (reclaimable)
- `available` — RAM available for new apps (includes reclaimable cache)

**Key Insight:**
**Look at "available", not "free".**
Linux uses free RAM for caching to speed up I/O. This cache is automatically released when needed.

---

### PROC-012 — Understanding Memory States

**Why "free" is Low:**
Linux philosophy: free RAM is wasted RAM.
System caches frequently accessed files in RAM for speed.

**When to Worry:**
- `available` is very low (< 10%)
- Swap is being used heavily
- OOM (Out of Memory) killer activating

**Checking Swap Usage:**
```bash copy
free -h
# Look at Swap line
```

If swap `used` is high, system is under memory pressure.

---

### PROC-013 — Finding Memory Hogs

**Top memory consumers:**
```bash copy
ps aux --sort=-%mem | head -10
```

**Or in top:**
Press `M` to sort by memory.

**Specific process memory:**
```bash copy
ps -p 1234 -o pid,ppid,cmd,%mem,%cpu
```

</div>

</details>

---

<details>
<summary><strong>7. Disk Space Management</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-014 — df (Disk Free)

Shows filesystem disk space usage.

```bash copy
df -h
```

**Output:**
```
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        50G   38G   10G  80% /
/dev/sda2       100G   45G   50G  48% /var
tmpfs           3.9G     0  3.9G   0% /dev/shm
```

**Columns:**
- `Filesystem` — device or partition
- `Size` — total size
- `Used` — space used
- `Avail` — space available
- `Use%` — percentage used
- `Mounted on` — mount point

**When to Act:**
- Above 80% — start cleanup
- Above 90% — urgent action needed
- At 100% — system may become unstable

---

### PROC-015 — du (Disk Usage)

Shows directory sizes.

**Size of directory:**
```bash copy
du -sh /var/log
# Output: 2.3G    /var/log
```

**Top 10 largest directories:**
```bash copy
du -h /var | sort -rh | head -10
```

**Find large files in directory:**
```bash copy
find /var/log -type f -size +100M -exec ls -lh {} \;
```

**Common Pattern:**
```bash copy
du -sh /var/* | sort -rh | head -10
# Shows largest dirs under /var
```

</div>

</details>

---

<details>
<summary><strong>8. Controlling Processes: Signals and Termination</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-016 — Kill Signals Explained

Signals are messages sent to processes to control behavior.

**Common Signals:**

| Signal | Number | Name | Effect |
|--------|--------|------|--------|
| SIGTERM | 15 | Terminate | Polite shutdown (default) |
| SIGKILL | 9 | Kill | Force kill (immediate, can't be caught) |
| SIGHUP | 1 | Hangup | Reload config (many daemons) |
| SIGINT | 2 | Interrupt | Ctrl+C in terminal |
| SIGSTOP | 19 | Stop | Pause process |
| SIGCONT | 18 | Continue | Resume paused process |

**Signal Philosophy:**
- **Try SIGTERM first** — gives process chance to clean up
- **Use SIGKILL as last resort** — may leave orphaned resources

---

### PROC-017 — kill Command

Send signals to processes by PID.

**Graceful shutdown (default):**
```bash copy
kill 1234
# Sends SIGTERM (15)
```

**Force kill:**
```bash copy
kill -9 1234
# OR
kill -SIGKILL 1234
```

**Reload config:**
```bash copy
kill -HUP 1234
# OR
kill -1 1234
```

**List all signals:**
```bash copy
kill -l
```

---

### PROC-018 — killall and pkill

**Kill by name:**
```bash copy
killall nginx
# Kills all processes named "nginx"
```

**With specific signal:**
```bash copy
killall -9 nginx
```

**pkill (pattern matching):**
```bash copy
pkill -f "python.*api"
# Kills all processes matching pattern
```

**Safer testing:**
```bash copy
pgrep -f "python.*api"
# Shows what would be killed (without killing)
```

</div>

</details>

---

<details>
<summary><strong>9. Troubleshooting Zombie Processes</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-019 — What are Zombies?

A zombie process has finished executing but still has an entry in the process table because its parent hasn't read its exit status.

**Identifying Zombies:**
```bash copy
ps aux | grep Z
# OR
ps aux | grep defunct
```

**In top:**
Look at header: `0 zombie`

**Why Zombies Exist:**
Child process exits → becomes zombie → parent reads exit status → zombie disappears.

---

### PROC-020 — Cleaning Up Zombies

**You can't kill zombies** (they're already dead).

**Solution 1: Kill the Parent**
```bash copy
# Find parent PID
ps -o ppid= -p <zombie_PID>

# Kill parent (forces it to clean up children)
kill <parent_PID>
```

**Solution 2: Wait for Parent**
Zombies automatically disappear when parent exits or reads status.

**Solution 3: Reboot** (if parent is critical system process)

**Are Zombies Harmful?**
Usually no. They consume minimal resources (just process table entry).
Only worry if hundreds accumulate.

</div>

</details>

---

<details>
<summary><strong>10. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: High CPU Usage

**Symptom:**
Server slow, load average high.

**Diagnosis:**
```bash copy
top
# Press P to sort by CPU
# OR
ps aux --sort=-%cpu | head -10
```

**Fix:**
Identify the process consuming CPU, investigate why, potentially restart or kill it.

**Confirm:**
```bash copy
top
# CPU usage back to normal
```

---

### Scenario 2: Memory Exhausted

**Symptom:**
Applications crashing with out-of-memory errors.

**Diagnosis:**
```bash copy
free -h
# Check "available" column
ps aux --sort=-%mem | head -10
# Find memory hogs
```

**Fix:**
Kill or restart memory-hungry processes, or add more RAM.

**Confirm:**
```bash copy
free -h
# "available" increased
```

---

### Scenario 3: Disk Full

**Symptom:**
Applications failing to write files.

**Diagnosis:**
```bash copy
df -h
# Find full filesystem
du -sh /var/* | sort -rh | head -10
# Find largest directories
```

**Fix:**
Delete logs, old files, or expand disk.

**Confirm:**
```bash copy
df -h /var
# Usage below 80%
```

---

### Scenario 4: Process Won't Die

**Symptom:**
`kill` doesn't work, process still running.

**Cause:**
Process in uninterruptible sleep (D state) or needs SIGKILL.

**Fix:**
```bash copy
kill -9 <PID>
```

**If still stuck:**
Process may be waiting for hardware I/O. Check `dmesg` for disk errors.

**Confirm:**
```bash copy
ps aux | grep <PID>
# Process gone
```

---

### Scenario 5: Find What's Using Port

**Symptom:**
Can't start service, port already in use.

**Diagnosis:**
```bash copy
sudo lsof -i :80
# OR
sudo ss -tulpn | grep :80
```

**Fix:**
Kill the process using that port or change your service's port.

**Confirm:**
Service starts successfully.

</div>

</details>

---

<details>
<summary><strong>11. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
ps aux   # show all processes
```

```bash copy
ps -u username   # processes for specific user
```

```bash copy
ps auxf   # process tree
```

```bash copy
ps aux --sort=-%mem   # sort by memory
```

```bash copy
ps aux --sort=-%cpu   # sort by CPU
```

```bash copy
pgrep nginx   # find PID by name
```

```bash copy
pgrep -a nginx   # find PID with command
```

```bash copy
top   # real-time process monitor
```

```bash copy
htop   # enhanced process monitor
```

```bash copy
uptime   # system uptime and load average
```

```bash copy
free -h   # memory usage
```

```bash copy
df -h   # disk space usage
```

```bash copy
du -sh directory   # directory size
```

```bash copy
du -sh /* | sort -rh   # largest directories
```

```bash copy
kill PID   # send SIGTERM (graceful)
```

```bash copy
kill -9 PID   # send SIGKILL (force)
```

```bash copy
kill -HUP PID   # reload config
```

```bash copy
killall processname   # kill all by name
```

```bash copy
pkill -f pattern   # kill by pattern
```

```bash copy
systemctl status nginx   # check service status (just status)
```

```bash copy
lsof -i :80   # what's using port 80
```

```bash copy
ss -tulpn   # show listening ports
```

```bash copy
nproc   # number of CPU cores
```

```bash copy
lscpu   # detailed CPU info
```

</div>

</details>

---

<details>
<summary><strong>12. Quick Takeaways</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

- Every running program is a process with a unique PID
- Use `ps aux` for snapshots, `top`/`htop` for real-time monitoring
- Load average shows CPU demand (compare to core count)
- Check "available" memory, not "free" (Linux caches aggressively)
- `df -h` shows disk space, `du -sh` shows directory sizes
- Always try SIGTERM (15) before SIGKILL (9)
- Zombie processes are harmless unless they accumulate
- High load, low memory, or full disk needs immediate attention
- Process states: R (running), S (sleeping), D (disk wait), Z (zombie)
- Use `pgrep`, `pkill`, `killall` for name-based process management

**What's Next:**
Now that you understand processes and system monitoring, the next file covers package management — installing, updating, and managing software on your system.

</div>

</details>

---
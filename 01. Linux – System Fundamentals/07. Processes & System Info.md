# **07. Processes & System Info — Monitoring and Managing Running Programs**
> Understanding what's running, how it performs, and how to control it.

---

## Table of Contents
- [1. Why Process Visibility Matters](#1-why-process-visibility-matters)
- [2. Understanding Processes and PIDs](#2-understanding-processes-and-pids)
- [3. Process States and Lifecycle](#3-process-states-and-lifecycle)
- [4. Process Hierarchy: Parents and Children](#4-process-hierarchy-parents-and-children)
- [5. Viewing Processes with ps](#5-viewing-processes-with-ps)
- [6. Finding Processes by Name](#6-finding-processes-by-name)
- [7. Real-Time Monitoring with top](#7-real-time-monitoring-with-top)
- [8. Enhanced Monitoring with htop](#8-enhanced-monitoring-with-htop)
- [9. Understanding Load Average](#9-understanding-load-average)
- [10. Memory Usage Analysis](#10-memory-usage-analysis)
- [11. Disk Space Management](#11-disk-space-management)
- [12. Controlling Processes with Signals](#12-controlling-processes-with-signals)
- [13. Killing Processes Safely](#13-killing-processes-safely)
- [14. Zombie Processes Explained](#14-zombie-processes-explained)
- [15. System Information Commands](#15-system-information-commands)
- [16. Real-World Scenarios](#16-real-world-scenarios)
- [17. Commands Reference](#17-commands-reference)
- [18. Quick Reference](#18-quick-reference)

---

<details>
<summary><strong>1. Why Process Visibility Matters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every application running on your server is a process.

When production breaks:
- CPU spikes to 100%
- Memory runs out
- Application becomes unresponsive
- Disk fills up
- Users can't connect

You need to answer:
- What's running right now?
- Which process is consuming resources?
- How do I stop a misbehaving process?
- Is the system healthy overall?

Understanding processes means:
- you can identify bottlenecks instantly
- you can kill runaway processes confidently
- you can monitor system health proactively
- you can troubleshoot performance issues methodically

This isn't about memorizing commands.
It's about understanding what processes are, how to see them, and how to control them.

</div>

</details>

---

<details>
<summary><strong>2. Understanding Processes and PIDs</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-001 — What is a Process?

A process is a running instance of a program.

**Key Points:**
- Every process has a unique **PID** (Process ID)
- PIDs are numbers: 1, 1234, 5678, etc.
- PID 1 is always the **init system** (systemd on modern systems)
- When you run a command, the kernel creates a process

**Example:**
```bash copy
sleep 100 &
# Output: [1] 12345
```

`12345` is the PID of the `sleep` process.

**Viewing Your Shell's PID:**
```bash copy
echo $$
# Output: 2891 (your shell's PID)
```

</div>

</details>

---

<details>
<summary><strong>3. Process States and Lifecycle</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-002 — Process States

Every process has a state that tells you what it's doing.

| State | Symbol | Meaning |
|-------|--------|---------|
| Running | `R` | Currently executing or ready to run |
| Sleeping | `S` | Waiting for event (interruptible) |
| Disk Wait | `D` | Waiting for I/O (uninterruptible) |
| Stopped | `T` | Stopped by signal (Ctrl+Z) |
| Zombie | `Z` | Terminated but not reaped by parent |

**Sleeping (S):**
Most processes are sleeping most of the time, waiting for something (user input, network data, timer).

**Disk Wait (D):**
Waiting for disk I/O. If many processes stuck in `D`, disk is bottleneck.

**Zombie (Z):**
Process finished but parent hasn't collected exit status. Usually harmless unless accumulating.

**Viewing Process States:**
```bash copy
ps aux
# STAT column shows state
```

</div>

</details>

---

<details>
<summary><strong>4. Process Hierarchy: Parents and Children</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-003 — Process Hierarchy

Processes have parent-child relationships.

```
systemd (PID 1)
├── sshd (PID 890)
│   └── bash (PID 2891) — your SSH session
│       └── sleep (PID 12345) — command you ran
├── nginx (PID 1234)
│   ├── nginx worker (PID 1235)
│   └── nginx worker (PID 1236)
└── ...
```

**Key Concepts:**
- Every process (except PID 1) has a **parent process (PPID)**
- When parent dies, children are adopted by PID 1
- Killing parent usually kills children

**Viewing Process Tree:**
```bash copy
pstree
# Shows visual hierarchy
```

**Viewing Parent PID:**
```bash copy
ps -o pid,ppid,cmd
```

</div>

</details>

---

<details>
<summary><strong>5. Viewing Processes with ps</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-004 — ps Command (Snapshot View)

**`ps`** shows a snapshot of current processes.

**Common Usage:**
```bash copy
ps aux
```

**Output Columns:**
- **USER** — process owner
- **PID** — process ID
- **%CPU** — CPU usage percentage
- **%MEM** — memory usage percentage
- **VSZ** — virtual memory size (KB)
- **RSS** — resident set size (physical RAM in KB)
- **STAT** — process state
- **START** — start time
- **TIME** — cumulative CPU time
- **COMMAND** — command that started process

**Why `aux`?**
- `a` — all users' processes
- `u` — user-oriented format
- `x` — include processes without controlling terminal

---

### PROC-005 — Common ps Patterns

**All processes:**
```bash copy
ps aux
```

**Processes for specific user:**
```bash copy
ps aux | grep akhil
```

**Processes using most CPU:**
```bash copy
ps aux --sort=-%cpu | head -10
```

**Processes using most memory:**
```bash copy
ps aux --sort=-%mem | head -10
```

**Custom columns:**
```bash copy
ps -eo pid,ppid,user,cmd,%cpu,%mem
```

**Process tree:**
```bash copy
ps auxf
# Shows hierarchy with indentation
```

</div>

</details>

---

<details>
<summary><strong>6. Finding Processes by Name</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-006 — pgrep (Find by Name)

**`pgrep`** finds process IDs by name.

```bash copy
pgrep nginx
# Output: 1234
#         1235
#         1236
```

**With full command:**
```bash copy
pgrep -a nginx
# Output: 1234 nginx: master process
#         1235 nginx: worker process
```

**For specific user:**
```bash copy
pgrep -u akhil
```

**Count processes:**
```bash copy
pgrep -c nginx
# Output: 3
```

</div>

</details>

---

<details>
<summary><strong>7. Real-Time Monitoring with top</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-007 — top (Built-in Real-Time Monitor)

**`top`** shows live, updating view of processes.

```bash copy
top
```

**Top Section (System Summary):**
- **Load average** — CPU demand (1, 5, 15 min averages)
- **Tasks** — total, running, sleeping, stopped, zombie
- **CPU usage** — user, system, idle, wait
- **Memory** — total, used, free, buffers/cache
- **Swap** — total, used, free

**Process List:**
Sorted by CPU usage by default.

**Interactive Commands (while top is running):**
- `q` — quit
- `k` — kill process (prompts for PID)
- `M` — sort by memory usage
- `P` — sort by CPU usage
- `1` — toggle individual CPU cores
- `h` — help

**Why Use top:**
- See what's consuming resources right now
- Identify CPU or memory hogs
- Kill processes without leaving top

</div>

</details>

---

<details>
<summary><strong>8. Enhanced Monitoring with htop</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-008 — htop (Enhanced Monitor)

**`htop`** is a better, more visual alternative to `top`.

**Installation:**
```bash copy
sudo apt install htop    # Debian/Ubuntu
sudo dnf install htop    # RHEL/Fedora
```

**Running:**
```bash copy
htop
```

**Features:**
- Color-coded CPU and memory bars
- Mouse support
- Process tree view (F5)
- Easy process killing (F9)
- Search (F3)
- Filter (F4)
- Sort by any column (F6)

**Why htop is Better:**
- Visual representation
- Easier navigation
- No need to remember shortcuts
- Shows all CPU cores individually

**Interactive Commands:**
- `F9` — kill process
- `F5` — tree view
- `F6` — sort by column
- `F3` — search
- `F4` — filter
- `q` — quit

</div>

</details>

---

<details>
<summary><strong>9. Understanding Load Average</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-009 — Load Average Explained

**What is Load Average?**
Number of processes waiting for CPU time.

**Three Numbers:**
```
load average: 2.15, 1.90, 1.75
              │     │     │
              │     │     └─ 15-minute average
              │     └─────── 5-minute average
              └──────────── 1-minute average
```

**Interpretation:**
Compare load to number of CPU cores.

**Example: 4-core system**
- Load: `4.0` → 100% utilized (all cores busy)
- Load: `8.0` → 200% utilized (processes queuing)
- Load: `2.0` → 50% utilized (idle capacity)
- Load: `16.0` → 400% utilized (severe bottleneck)

**General Rules:**
- Load = Cores → Fully utilized (normal)
- Load < Cores → Underutilized
- Load > Cores → Overloaded (queuing)
- Load >> Cores → Severely overloaded

**Checking Core Count:**
```bash copy
nproc
# Output: 4
```

---

### PROC-010 — uptime Command

**`uptime`** shows load average quickly.

```bash copy
uptime
# Output: 14:32:15 up 7 days, 3:21, 2 users, load average: 0.52, 0.58, 0.59
```

**What it shows:**
- Current time
- How long system has been running
- Number of logged-in users
- Load averages (1, 5, 15 minutes)

</div>

</details>

---

<details>
<summary><strong>10. Memory Usage Analysis</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-011 — free Command

**`free`** shows memory usage.

```bash copy
free -h
```

**Output:**
```
              total        used        free      shared  buff/cache   available
Mem:           15Gi       8.2Gi       2.1Gi       324Mi       5.0Gi        6.5Gi
Swap:         2.0Gi          0B       2.0Gi
```

**Fields Explained:**
- **total** — total installed RAM
- **used** — RAM in use (includes cache/buffers)
- **free** — completely unused RAM
- **shared** — RAM used by tmpfs
- **buff/cache** — kernel buffers and page cache
- **available** — RAM available for new apps (free + reclaimable cache)

**Critical Insight:**
Look at **available**, not **free**.
Linux caches aggressively to improve performance. Low "free" is normal.

**If available is low:**
System is genuinely out of memory.

**Swap:**
- If swap used is high → system swapping (slow)
- If swap is 0 → no memory pressure (good)

---

### PROC-012 — Checking Memory Per Process

**Top memory consumers:**
```bash copy
ps aux --sort=-%mem | head -10
```

**Specific process memory:**
```bash copy
ps -p 1234 -o pid,rss,vsz,cmd
# RSS = physical RAM (KB)
# VSZ = virtual memory (KB)
```

</div>

</details>

---

<details>
<summary><strong>11. Disk Space Management</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-013 — df (Disk Free)

**`df`** shows filesystem usage.

```bash copy
df -h
```

**Output:**
```
Filesystem      Size  Used Avail Use% Mounted on
/dev/sda1        50G   30G   18G  63% /
/dev/sdb1       100G   85G   10G  90% /var
```

**Key Columns:**
- **Size** — total filesystem size
- **Used** — space used
- **Avail** — space available
- **Use%** — percentage used
- **Mounted on** — mount point

**Warning Thresholds:**
- `< 80%` — healthy
- `80-90%` — monitor closely
- `> 90%` — action needed
- `100%` — critical (services may fail)

**Inode Usage:**
```bash copy
df -i
# Shows inode usage (max number of files)
```

---

### PROC-014 — du (Disk Usage)

**`du`** shows directory sizes.

**Directory size:**
```bash copy
du -sh /var/log
# Output: 2.3G /var/log
```

**Subdirectory sizes:**
```bash copy
du -h --max-depth=1 /var
# Shows size of each subdirectory in /var
```

**Largest directories:**
```bash copy
du -h / | sort -rh | head -20
# Find 20 largest directories
```

**Finding Large Files:**
```bash copy
find /var -type f -size +100M -exec ls -lh {} \;
# Find files larger than 100MB
```

---

### PROC-015 — ncdu (Interactive Disk Usage)

**`ncdu`** is an interactive disk usage explorer.

**Installation:**
```bash copy
sudo apt install ncdu
```

**Usage:**
```bash copy
ncdu /var
```

**Navigation:**
- Arrow keys to move
- Enter to drill down
- `d` to delete files
- `q` to quit

**Why ncdu is Great:**
Visual, interactive way to find what's consuming disk space.

</div>

</details>

---

<details>
<summary><strong>12. Controlling Processes with Signals</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-016 — Signals Explained

**Signals** are messages sent to processes to control them.

**Common Signals:**

| Signal | Number | Effect | Use Case |
|--------|--------|--------|----------|
| SIGTERM | 15 | Graceful shutdown | Default kill signal |
| SIGKILL | 9 | Force kill (unblockable) | Last resort |
| SIGHUP | 1 | Hang up (reload config) | Restart without stopping |
| SIGINT | 2 | Interrupt (Ctrl+C) | Stop foreground process |
| SIGSTOP | 19 | Pause process | Ctrl+Z |
| SIGCONT | 18 | Resume paused process | After SIGSTOP |

**Key Insight:**
- **SIGTERM (15):** Process can catch, cleanup, save state, then exit
- **SIGKILL (9):** Immediate termination, no cleanup possible

**Sending Signals:**
```bash copy
kill -15 1234    # graceful shutdown
kill -9 1234     # force kill
kill -1 1234     # reload config
```

**Why Try SIGTERM First:**
Gives process chance to:
- Close open files
- Flush buffers
- Save state
- Release resources cleanly

**When to Use SIGKILL:**
- Process not responding to SIGTERM
- Process stuck in uninterruptible sleep (D state)
- Emergency situations

</div>

</details>

---

<details>
<summary><strong>13. Killing Processes Safely</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-017 — kill Command

**`kill`** sends signals to processes by PID.

**Graceful shutdown (SIGTERM):**
```bash copy
kill 1234
# Same as: kill -15 1234
```

**Force kill (SIGKILL):**
```bash copy
kill -9 1234
```

**Reload config (SIGHUP):**
```bash copy
kill -1 1234
```

**List all signals:**
```bash copy
kill -l
```

---

### PROC-018 — pkill (Kill by Name)

**`pkill`** kills processes by name.

```bash copy
pkill nginx
# Sends SIGTERM to all nginx processes
```

**Force kill by name:**
```bash copy
pkill -9 nginx
```

**Kill for specific user:**
```bash copy
pkill -u akhil
```

---

### PROC-019 — killall (Kill by Name)

**`killall`** similar to pkill but exact name match.

```bash copy
killall nginx
```

**Force kill:**
```bash copy
killall -9 nginx
```

**Difference from pkill:**
- `pkill nginx` matches "nginx", "nginx-worker", etc.
- `killall nginx` only matches exactly "nginx"

</div>

</details>

---

<details>
<summary><strong>14. Zombie Processes Explained</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-020 — What are Zombie Processes?

**Zombie (Z state):**
Process that has finished execution but parent hasn't collected exit status.

**Why They Exist:**
Parent process needs to read child's exit code (return value).

**Are Zombies Dangerous?**
Usually no. They consume PID slot but no CPU/memory.

**When to Worry:**
If zombies accumulate (hundreds/thousands), indicates buggy parent process.

**Viewing Zombies:**
```bash copy
ps aux | grep Z
```

**Fixing Zombies:**
Kill the **parent process**, not the zombie.

```bash copy
# Find parent of zombie
ps -o pid,ppid,stat,cmd | grep Z
# Kill parent
kill -9 <PPID>
```

**When parent dies:**
Zombies get adopted by PID 1 (systemd), which cleans them up.

</div>

</details>

---

<details>
<summary><strong>15. System Information Commands</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### PROC-021 — CPU Information

**Number of cores:**
```bash copy
nproc
# Output: 4
```

**Detailed CPU info:**
```bash copy
lscpu
```

**CPU model:**
```bash copy
cat /proc/cpuinfo | grep "model name" | head -1
```

---

### PROC-022 — Memory Information

**Total RAM:**
```bash copy
free -h | grep Mem | awk '{print $2}'
# Output: 15Gi
```

**Detailed memory info:**
```bash copy
cat /proc/meminfo
```

---

### PROC-023 — System Information

**Kernel version:**
```bash copy
uname -r
# Output: 5.15.0-58-generic
```

**OS info:**
```bash copy
cat /etc/os-release
```

**Hostname:**
```bash copy
hostname
```

**System uptime:**
```bash copy
uptime
```

---

### PROC-024 — Network Information

**Listening ports:**
```bash copy
ss -tulpn
# OR
netstat -tulpn
```

**What's using port 80:**
```bash copy
lsof -i :80
```

**All network connections:**
```bash copy
ss -tupn
```

</div>

</details>

---

<details>
<summary><strong>16. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Server CPU at 100%

**Symptom:**
Server unresponsive, CPU maxed out.

**Cause:**
Runaway process consuming CPU.

**Fix:**
```bash copy
# Find CPU hog
ps aux --sort=-%cpu | head -5

# Or use top/htop interactively
top

# Kill offending process
kill -15 <PID>
# Wait 10 seconds
kill -9 <PID>  # if still running
```

**Confirm:**
```bash copy
top
# CPU usage back to normal
```

---

### Scenario 2: Out of Memory

**Symptom:**
Applications crashing, OOM killer messages in logs.

**Cause:**
System ran out of memory.

**Fix:**
```bash copy
# Check available memory
free -h

# Find memory hogs
ps aux --sort=-%mem | head -10

# Kill largest consumer (if appropriate)
kill -15 <PID>
```

**Confirm:**
```bash copy
free -h
# Available memory increased
```

**Long-term:**
- Add more RAM
- Optimize application memory usage
- Add swap space

---

### Scenario 3: Disk Full

**Symptom:**
"No space left on device" errors.

**Cause:**
Filesystem at 100% capacity.

**Fix:**
```bash copy
# Find full filesystems
df -h

# Find what's consuming space
du -h / | sort -rh | head -20

# Or use ncdu interactively
ncdu /

# Clean up logs
sudo journalctl --vacuum-time=7d
sudo find /var/log -type f -name "*.log" -mtime +30 -delete
```

**Confirm:**
```bash copy
df -h
# Usage below 90%
```

---

### Scenario 4: Process Won't Die

**Symptom:**
`kill -15` doesn't stop process.

**Cause:**
Process ignoring SIGTERM or stuck in uninterruptible sleep.

**Fix:**
```bash copy
# Check process state
ps aux | grep <process_name>

# If state is 'D' (disk wait), wait or reboot
# If state is 'S' or 'R', force kill
kill -9 <PID>
```

**Confirm:**
```bash copy
ps aux | grep <PID>
# No output (process gone)
```

---

### Scenario 5: Many Zombie Processes

**Symptom:**
Hundreds of zombie processes accumulating.

**Cause:**
Parent process not reaping children (buggy parent).

**Fix:**
```bash copy
# Find zombies and their parent
ps -o pid,ppid,stat,cmd | grep Z

# Kill parent process
kill -9 <PPID>
```

**Confirm:**
```bash copy
ps aux | grep Z
# No zombies
```

---

### Scenario 6: High Load but Low CPU Usage

**Symptom:**
Load average high (e.g., 15.0 on 4-core system), but CPU idle.

**Cause:**
I/O bottleneck (disk or network).

**Fix:**
```bash copy
# Check for processes in 'D' state (disk wait)
ps aux | grep " D "

# Check disk I/O
iostat -x 1

# Or use iotop
sudo apt install iotop
sudo iotop
```

**Confirm:**
Identify process causing high I/O, investigate application.

</div>

</details>

---

<details>
<summary><strong>17. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
ps aux   # view all processes
```

```bash copy
ps aux --sort=-%cpu   # sort by CPU usage
```

```bash copy
ps aux --sort=-%mem   # sort by memory usage
```

```bash copy
ps -eo pid,ppid,user,cmd   # custom columns
```

```bash copy
ps auxf   # process tree with indentation
```

```bash copy
pgrep nginx   # find process IDs by name
```

```bash copy
pgrep -a nginx   # find with full command
```

```bash copy
pgrep -u akhil   # find by user
```

```bash copy
pstree   # view process hierarchy
```

```bash copy
top   # real-time process monitor
```

```bash copy
htop   # enhanced interactive monitor
```

```bash copy
uptime   # show load average and uptime
```

```bash copy
nproc   # number of CPU cores
```

```bash copy
lscpu   # detailed CPU information
```

```bash copy
free -h   # memory usage (human-readable)
```

```bash copy
df -h   # disk space usage (human-readable)
```

```bash copy
df -i   # inode usage
```

```bash copy
du -sh directory/   # directory size
```

```bash copy
du -h --max-depth=1   # subdirectory sizes
```

```bash copy
ncdu /var   # interactive disk usage explorer
```

```bash copy
kill 1234   # send SIGTERM (graceful shutdown)
```

```bash copy
kill -9 1234   # send SIGKILL (force kill)
```

```bash copy
kill -15 1234   # send SIGTERM explicitly
```

```bash copy
kill -1 1234   # send SIGHUP (reload config)
```

```bash copy
pkill nginx   # kill by name
```

```bash copy
pkill -9 nginx   # force kill by name
```

```bash copy
killall nginx   # kill by exact name match
```

```bash copy
hostname   # show system hostname
```

```bash copy
uname -r   # show kernel version
```

```bash copy
cat /etc/os-release   # show OS information
```

```bash copy
cat /proc/cpuinfo   # detailed CPU info
```

```bash copy
cat /proc/meminfo   # detailed memory info
```

```bash copy
ss -tulpn   # show listening ports
```

```bash copy
lsof -i :80   # what's using port 80
```

```bash copy
iostat -x 1   # disk I/O statistics
```

```bash copy
iotop   # interactive I/O monitor
```

</div>

</details>

---

<details>
<summary><strong>18. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Every running program is a process with a unique PID
- Use `ps aux` for snapshots, `top`/`htop` for real-time monitoring
- Load average shows CPU demand (compare to core count)
- Check "available" memory, not "free" (Linux caches aggressively)
- `df -h` shows disk space, `du -sh` shows directory sizes
- Always try SIGTERM (15) before SIGKILL (9)
- Zombie processes are harmless unless they accumulate
- High load, low memory, or full disk needs immediate attention
- Process stuck in D state usually means I/O bottleneck

**Process States:**

| State | Symbol | Meaning |
|-------|--------|---------|
| Running | `R` | Currently executing or ready to run |
| Sleeping | `S` | Waiting for event (interruptible) |
| Disk Wait | `D` | Waiting for I/O (uninterruptible) |
| Stopped | `T` | Stopped by signal (Ctrl+Z) |
| Zombie | `Z` | Terminated but not reaped by parent |

**Common Signals:**

| Signal | Number | Effect | Use Case |
|--------|--------|--------|----------|
| SIGTERM | 15 | Graceful shutdown | Default kill signal |
| SIGKILL | 9 | Force kill (unblockable) | Last resort |
| SIGHUP | 1 | Hang up (reload config) | Restart without stopping |
| SIGINT | 2 | Interrupt (Ctrl+C) | Stop foreground process |
| SIGSTOP | 19 | Pause process | Ctrl+Z (cannot be caught) |
| SIGCONT | 18 | Resume paused process | Use after SIGSTOP |

**ps Output Columns:**

| Column | Meaning |
|--------|---------|
| PID | Process ID |
| PPID | Parent Process ID |
| USER | Process owner |
| %CPU | CPU usage percentage |
| %MEM | Memory usage percentage |
| VSZ | Virtual memory size (KB) |
| RSS | Resident set size (physical RAM in KB) |
| STAT | Process state |
| TIME | Cumulative CPU time |
| COMMAND | Command that started the process |

**Load Average Interpretation:**

| Load vs Cores | Meaning |
|---------------|---------|
| Load = Cores | Fully utilized (normal) |
| Load < Cores | Underutilized |
| Load > Cores | Overloaded (queuing) |
| Load >> Cores | Severely overloaded |

**Example:** 4-core system
- Load: 4.0 → 100% utilized (healthy)
- Load: 8.0 → 200% utilized (struggling)
- Load: 2.0 → 50% utilized (idle capacity)
- Load: 16.0 → 400% overload (critical)

**Memory Fields (from free -h):**

| Field | Meaning |
|-------|---------|
| total | Total installed RAM |
| used | RAM in use (includes cache/buffers) |
| free | Completely unused RAM |
| shared | RAM used by tmpfs |
| buff/cache | Kernel buffers and page cache |
| available | RAM available for new apps (free + reclaimable cache) |

**Important:** Always check `available`, not `free`. Linux caches aggressively to improve performance.

**Disk Space Thresholds:**

| Usage | Status | Action |
|-------|--------|--------|
| < 80% | Healthy | Monitor normally |
| 80-90% | Warning | Plan cleanup |
| 90-95% | Critical | Clean up now |
| > 95% | Emergency | Services may fail |

**Common Process Management Patterns:**

| Task | Command |
|------|---------|
| Find process by name | `pgrep nginx` |
| Find with details | `ps aux \| grep nginx` |
| Kill by name | `pkill nginx` |
| Kill all instances | `killall nginx` |
| Kill by PID (graceful) | `kill 1234` |
| Kill by PID (force) | `kill -9 1234` |
| Reload config | `kill -1 1234` |
| View process tree | `pstree` |
| Top CPU users | `ps aux --sort=-%cpu \| head -10` |
| Top memory users | `ps aux --sort=-%mem \| head -10` |

**System Health Quick Checks:**

| Command | What to Check |
|---------|---------------|
| `uptime` | Load average vs core count |
| `free -h` | Available memory (not free) |
| `df -h` | Disk usage < 90% |
| `top` | CPU idle time > 0% |
| `ps aux \| grep Z` | No excessive zombies |

**What's Next:**
Now that you understand processes and system monitoring, the next file covers package management — installing, updating, and managing software on your system.

</div>

</details>

---
# **02. Shell & Terminal Basics — Your Command Interface**
> How commands work from typing to execution.

---

## Table of Contents
- [1. Why Shell Knowledge Matters](#1-why-shell-knowledge-matters)
- [2. The Shell vs Terminal Confusion](#2-the-shell-vs-terminal-confusion)
- [3. How the Shell Interprets Commands](#3-how-the-shell-interprets-commands)
- [4. PATH and Command Discovery](#4-path-and-command-discovery)
- [5. Environment Variables Explained](#5-environment-variables-explained)
- [6. Shell Configuration Files](#6-shell-configuration-files)
- [7. Aliases and Shortcuts](#7-aliases-and-shortcuts)
- [8. Command Execution Order](#8-command-execution-order)
- [9. Command History and Reuse](#9-command-history-and-reuse)
- [10. Interactive vs Non-Interactive Shells](#10-interactive-vs-non-interactive-shells)
- [11. Getting Help](#11-getting-help)
- [12. Customizing Your Prompt](#12-customizing-your-prompt)
- [13. Troubleshooting Common Issues](#13-troubleshooting-common-issues)
- [14. Commands Reference](#14-commands-reference)
- [15. Quick Reference](#15-quick-reference)

---

<details>
<summary><strong>1. Why Shell Knowledge Matters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every command you run goes through the shell.

Whether you're:
- SSH'd into a server
- Running CI/CD scripts
- Automating deployments
- Debugging production issues

The shell is your interface.

Understanding how it interprets commands, finds executables, and manages environment means:
- you can debug "command not found" errors instantly
- you can write reliable scripts
- you can customize your workflow
- you can troubleshoot PATH issues confidently

This isn't about memorizing syntax.
It's about knowing how the shell thinks.

</div>

</details>

---

<details>
<summary><strong>2. The Shell vs Terminal Confusion</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Most beginners think the terminal **is** the shell.

They're not the same.

**The Problem:**
- You type `ls` but get "command not found"
- You install a tool but can't run it
- You set a variable but it disappears after logout
- You create an alias but it doesn't persist

**Why This Happens:**
You're confusing where commands are **displayed** (terminal) with where they're **interpreted** (shell).

**What This File Fixes:**
You'll understand:
- terminal = display window
- shell = command interpreter
- PATH = where executables live
- environment = variables that persist
- startup files = what runs when you log in

Once you know this, these issues vanish.

</div>

</details>

---

<details>
<summary><strong>3. How the Shell Interprets Commands</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Think of it like this:

```
┌─────────────────────────────────────┐
│   You (typing commands)             │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   Terminal (display window)         │
│   - Shows text                      │
│   - Captures input                  │
│   - Just a UI                       │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   Shell (command interpreter)       │
│   - Parses your command             │
│   - Checks PATH for executables     │
│   - Manages environment variables   │
│   - Executes programs               │
└────────────┬────────────────────────┘
             │
┌────────────▼────────────────────────┐
│   Kernel (executes programs)        │
└─────────────────────────────────────┘
```

**The Flow When You Run `ls`:**

1. You type `ls` in the **terminal**
2. Terminal sends the text to the **shell**
3. Shell looks for `ls` in directories listed in **PATH**
4. Shell finds `/usr/bin/ls`
5. Shell asks the **kernel** to execute it
6. Kernel runs the program
7. Output flows back: kernel → shell → terminal → you

**Key Insight:**
The terminal is just a window.
The shell does all the thinking.

---

### SHL-001 — Common Shells

**bash** (Bourne Again Shell) — default on most Linux systems
**zsh** (Z Shell) — modern, feature-rich, default on macOS
**sh** (Bourne Shell) — minimal, POSIX-compliant
**fish** (Friendly Interactive Shell) — beginner-friendly

</div>

</details>

---

<details>
<summary><strong>4. PATH and Command Discovery</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SHL-002 — What is PATH?

A colon-separated list of directories where the shell looks for executables.

**Example PATH:**
```
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
```

When you type `ls`, the shell:
1. Checks `/usr/local/bin/ls` — not found
2. Checks `/usr/bin/ls` — found!
3. Executes it

**Why This Matters:**
If you install a tool in `/opt/custom/bin` but it's not in PATH, you'll get "command not found."

**Viewing PATH:**
```bash copy
echo $PATH
```

**Adding to PATH (temporary):**
```bash copy
export PATH=$PATH:/opt/custom/bin
```

**Adding to PATH (permanent):**
Add to `~/.bashrc` or `~/.zshrc`:
```bash copy
export PATH=$PATH:/opt/custom/bin
```

Then reload:
```bash copy
source ~/.bashrc
```

</div>

</details>

---

<details>
<summary><strong>5. Environment Variables Explained</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SHL-003 — Environment Variables

Variables that persist across commands and programs.

**Common Environment Variables:**
- `HOME` — your home directory (`/home/username`)
- `USER` — your username
- `SHELL` — path to your shell (`/bin/bash`)
- `PWD` — current working directory
- `PATH` — where executables are found

**Viewing All Environment Variables:**
```bash copy
env
```

**Viewing Specific Variable:**
```bash copy
echo $HOME
```

**Setting a Variable (temporary):**
```bash copy
export MY_VAR="hello"
```

**Setting a Variable (permanent):**
Add to `~/.bashrc`:
```bash copy
export MY_VAR="hello"
```

**Why "export"?**
Without `export`, the variable is only available in the current shell. With `export`, child processes (like scripts you run) can see it.

</div>

</details>

---

<details>
<summary><strong>6. Shell Configuration Files</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SHL-004 — Startup Files

When you log in, the shell reads configuration files to set up your environment.

**bash Startup Files:**
- `~/.bash_profile` — run on login (interactive login shell)
- `~/.bashrc` — run for interactive non-login shells
- `/etc/profile` — system-wide login settings
- `/etc/bash.bashrc` — system-wide interactive settings

**Typical Pattern:**
- SSH login → reads `~/.bash_profile`
- `~/.bash_profile` sources `~/.bashrc`
- Aliases and functions go in `~/.bashrc`

**zsh Startup Files:**
- `~/.zshrc` — main config file
- `~/.zprofile` — login shell config

**Best Practice:**
Put customizations in `~/.bashrc` (bash) or `~/.zshrc` (zsh).

</div>

</details>

---

<details>
<summary><strong>7. Aliases and Shortcuts</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SHL-005 — Aliases

Shortcuts for long commands.

**Creating an Alias (temporary):**
```bash copy
alias ll='ls -la'
```

**Creating an Alias (permanent):**
Add to `~/.bashrc`:
```bash copy
alias ll='ls -la'
alias gs='git status'
alias k='kubectl'
```

**Viewing All Aliases:**
```bash copy
alias
```

**Removing an Alias:**
```bash copy
unalias ll
```

**Why Aliases Matter:**
Save time on repetitive commands. Common in DevOps for kubectl, docker, git.

</div>

</details>

---

<details>
<summary><strong>8. Command Execution Order</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SHL-006 — Execution Flow

When you type a command, the shell follows this order:

1. **Aliases** — check if it's an alias
2. **Functions** — check if it's a shell function
3. **Built-ins** — check if it's a shell built-in (`cd`, `echo`, etc.)
4. **PATH** — search directories in PATH for an executable

**Example:**
```bash copy
type ls
# Output: ls is aliased to `ls --color=auto`
```

```bash copy
type cd
# Output: cd is a shell builtin
```

```bash copy
type python3
# Output: python3 is /usr/bin/python3
```

**Why This Matters:**
If you have an alias called `python` and a binary in PATH, the alias wins. Understanding this order prevents confusion.

</div>

</details>

---

<details>
<summary><strong>9. Command History and Reuse</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SHL-007 — Terminal Essentials

**Clearing the Screen:**
The `clear` command wipes the terminal display, giving you a fresh view without closing the session or affecting your command history.

```bash copy
clear
```

**Command History:**
The shell keeps a list of commands you've executed in the current session (and often across sessions).
- `history` prints this list with numbered entries.
- You can re-run any past command by referencing its number.

**Re-running Commands:**
- `!<num>` retrieves and executes the command with that history number (e.g., `!42`).
- `!-1` repeats the very last command you ran. You can also use `!-2`, `!-3`, etc., to go further back.

**Common Usage:**
```bash copy
history          # view command history
!42              # re-run command #42
!-1              # re-run last command
!!               # shortcut for !-1
```

</div>

</details>

---

<details>
<summary><strong>10. Interactive vs Non-Interactive Shells</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SHL-008 — Shell Types

**Interactive Shell:**
You type commands and see output immediately (SSH session, terminal window).

**Non-Interactive Shell:**
Runs scripts without user input (cron jobs, CI/CD pipelines).

**Why This Matters:**
- Interactive shells read `~/.bashrc`
- Non-interactive shells may not
- Scripts should set PATH explicitly

**Example Problem:**
Your cron job says "command not found" because PATH isn't set.

**Solution:**
Add PATH to the script:
```bash copy
#!/bin/bash
export PATH=/usr/local/bin:/usr/bin:/bin
your-command
```

---

### SHL-009 — Login vs Non-Login Shells

**Login Shell:**
Created when you log in (SSH, console login).
Reads: `~/.bash_profile`, `/etc/profile`

**Non-Login Shell:**
Created when you open a new terminal window.
Reads: `~/.bashrc`

**Common Pattern:**
Make `~/.bash_profile` source `~/.bashrc`:
```bash copy
# In ~/.bash_profile
if [ -f ~/.bashrc ]; then
    source ~/.bashrc
fi
```

This way, both login and non-login shells get the same config.

</div>

</details>

---

<details>
<summary><strong>11. Getting Help</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SHL-010 — Help Commands

**Manual Pages (`man`):**
Every command usually comes with its own "man page" containing detailed documentation. Use `man <cmd>` to read it in the pager.

**One-Line Summaries (`whatis`):**
Quickly view a brief description of a command without paging through the full manual.

**Locating Binaries & Documentation (`whereis`):**
Finds the locations of the executable, source, and man pages for a given command.

**Which Executable (`which`):**
Shows the exact path of the command that would be executed in your current PATH.

| Command   | Description                   | Example        |
|-----------|-------------------------------|----------------|
| `man`     | View manual page              | `man ls`       |
| `whatis`  | One-line description          | `whatis clear` |
| `whereis` | Locate binary and docs        | `whereis uname`|
| `which`   | Show command path             | `which ls`     |

</div>

</details>

---

<details>
<summary><strong>12. Customizing Your Prompt</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SHL-011 — Prompt Customization

The shell prompt shows info before each command.

**Default bash prompt:**
```
user@hostname:~$
```

**Controlled by PS1 variable:**
```bash copy
echo $PS1
```

**Customizing PS1 (temporary):**
```bash copy
export PS1="\u@\h:\w\$ "
```

**Common PS1 Codes:**
- `\u` — username
- `\h` — hostname
- `\w` — current directory
- `\$` — `$` for user, `#` for root

**Example Custom Prompt:**
```bash copy
export PS1="[\u@\h \W]\$ "
# Output: [akhil@server ~]$
```

Add to `~/.bashrc` to make permanent.

</div>

</details>

---

<details>
<summary><strong>13. Troubleshooting Common Issues</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: "Command Not Found" After Installation

**Symptom:**
Installed `terraform` but running `terraform` gives "command not found."

**Cause:**
Binary installed to `/usr/local/bin` but `/usr/local/bin` not in PATH.

**Fix:**
```bash copy
which terraform   # check if it's found
echo $PATH        # check current PATH
export PATH=$PATH:/usr/local/bin
terraform --version   # test
```

To make permanent, add to `~/.bashrc`:
```bash copy
export PATH=$PATH:/usr/local/bin
```

**Confirm:**
```bash copy
source ~/.bashrc
terraform --version
# Output: Terraform v1.5.0
```

---

### Scenario 2: Alias Doesn't Persist After Logout

**Symptom:**
Created alias `alias k='kubectl'` but it's gone after logout.

**Cause:**
Alias only exists in current shell session.

**Fix:**
Add to `~/.bashrc`:
```bash copy
echo "alias k='kubectl'" >> ~/.bashrc
source ~/.bashrc
```

**Confirm:**
```bash copy
k version
# Output: kubectl version info
```

---

### Scenario 3: Script Works Manually But Fails in Cron

**Symptom:**
Script runs fine when you execute it, fails in cron with "command not found."

**Cause:**
Cron doesn't load your shell environment (PATH, etc.).

**Fix:**
Add PATH to the script:
```bash copy
#!/bin/bash
export PATH=/usr/local/bin:/usr/bin:/bin
# rest of script
```

Or set PATH in crontab:
```bash copy
PATH=/usr/local/bin:/usr/bin:/bin
0 2 * * * /home/akhil/backup.sh
```

**Confirm:**
Check cron logs:
```bash copy
grep CRON /var/log/syslog
```

---

### Scenario 4: Environment Variable Not Available in Script

**Symptom:**
Set `export MY_VAR="value"` but script can't see it.

**Cause:**
Script runs in a subshell, and variable wasn't exported before running the script.

**Fix:**
Make sure to export before running:
```bash copy
export MY_VAR="value"
./my_script.sh
```

Or add to `~/.bashrc` for persistence:
```bash copy
export MY_VAR="value"
```

**Confirm:**
Inside script:
```bash copy
echo $MY_VAR
# Output: value
```

</div>

</details>

---

<details>
<summary><strong>14. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
echo $SHELL   # show current shell
```

```bash copy
echo $PATH   # show PATH variable
```

```bash copy
export PATH=$PATH:/opt/custom/bin   # add directory to PATH temporarily
```

```bash copy
env   # show all environment variables
```

```bash copy
echo $HOME   # show home directory
```

```bash copy
export MY_VAR="value"   # set environment variable
```

```bash copy
alias ll='ls -la'   # create alias temporarily
```

```bash copy
alias   # show all aliases
```

```bash copy
unalias ll   # remove alias
```

```bash copy
type ls   # show what 'ls' resolves to
```

```bash copy
which python3   # show full path of executable
```

```bash copy
whereis python3   # show binary, source, and man page locations
```

```bash copy
man bash   # view bash manual
```

```bash copy
whatis ls   # one-line description of command
```

```bash copy
clear   # clear terminal screen
```

```bash copy
history   # show command history
```

```bash copy
!42   # re-run command #42 from history
```

```bash copy
!!   # re-run last command
```

```bash copy
source ~/.bashrc   # reload bash configuration
```

```bash copy
echo $PS1   # show current prompt format
```

```bash copy
cat ~/.bashrc   # view bash config file
```

```bash copy
cat ~/.bash_profile   # view bash login config
```

</div>

</details>

---

<details>
<summary><strong>15. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Terminal displays text, shell interprets commands
- PATH tells the shell where to find executables
- Environment variables persist across commands
- Startup files (`~/.bashrc`, `~/.bash_profile`) configure your shell
- Aliases save time on repetitive commands
- Shell execution order: aliases → functions → builtins → PATH
- Export variables to make them available to child processes
- Interactive shells read `~/.bashrc`, login shells read `~/.bash_profile`

**Common Environment Variables:**

| Variable | Meaning |
|----------|---------|
| `HOME` | Your home directory (`/home/username`) |
| `USER` | Your username |
| `SHELL` | Path to your shell (`/bin/bash`) |
| `PWD` | Current working directory |
| `PATH` | Where executables are found |

**Shell Types:**

| Type | Description | Reads |
|------|-------------|-------|
| Interactive Login | SSH, console login | `~/.bash_profile`, `/etc/profile` |
| Interactive Non-Login | New terminal window | `~/.bashrc` |
| Non-Interactive | Scripts, cron | May not read config files |

**Common Shells:**

| Shell | Description |
|-------|-------------|
| `bash` | Bourne Again Shell (default on most Linux) |
| `zsh` | Z Shell (modern, feature-rich) |
| `sh` | Bourne Shell (minimal, POSIX) |
| `fish` | Friendly Interactive Shell |

**Command Execution Order:**
1. Aliases
2. Functions
3. Built-ins (`cd`, `echo`)
4. PATH search

**PS1 Prompt Codes:**
- `\u` — username
- `\h` — hostname
- `\w` — current directory
- `\$` — `$` for user, `#` for root

**What's Next:**
Now that you understand how the shell works, the next file covers navigation — moving around the filesystem with `cd`, `pwd`, and `ls`.

</div>

</details>

---
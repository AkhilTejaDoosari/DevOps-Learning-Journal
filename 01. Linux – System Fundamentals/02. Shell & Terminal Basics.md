# **02. Shell & Terminal Basics — Your Command Interface**
> Understanding how commands actually work from typing to execution

---

## What We'll Cover

- [1. Why This Actually Matters](#1-why-this-actually-matters)
- [2. Terminal vs Shell (Finally Explained)](#2-terminal-vs-shell)
- [3. PATH: How Commands Are Found](#3-path-how-commands-are-found)
- [4. Environment Variables That Control Everything](#4-environment-variables)
- [5. Making Changes Stick (Config Files)](#5-making-changes-stick)
- [6. Productivity Boosters](#6-productivity-boosters)
- [7. When Things Go Wrong](#7-when-things-go-wrong)
- [8. Quick Command Reference](#8-quick-command-reference)

---

<details>
<summary><strong>1. Why This Actually Matters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## The Real Problem

You type a command. Sometimes it works. Sometimes you get:

```
command not found
```

**Why?** You don't understand how the shell finds and runs commands.

---

## The Production Scenario

Your deployment script works on your laptop. You push it to the CI/CD server. It fails:

```
python: command not found
```

But Python is installed! You can run it manually!

**The issue:** The shell can't find it because PATH isn't set in the CI environment.

---

## What This File Gives You

After this, you'll understand:
- **Why** "command not found" happens
- **How** the shell finds executables
- **Where** to put your customizations so they stick
- **When** to use different config files

**No more guessing. No more copy-pasting random fixes from Stack Overflow.**

</div>

</details>

---

<details>
<summary><strong>2. Terminal vs Shell (Finally Explained)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## The Confusion

Most people think: "I'm working in the terminal, so that's my shell."

**Wrong.**

The terminal and shell are **two different programs** working together.

---

## The Mental Model

```
You type: ls -la
     ↓
Terminal (iTerm, PuTTY, GNOME Terminal)
  → Captures keystrokes
  → Displays output
  → Just the UI
     ↓
Shell (bash, zsh, sh)
  → Interprets "ls -la"
  → Looks in PATH for /usr/bin/ls
  → Executes it
     ↓
Kernel
  → Actually runs the program
     ↓
Output flows back up
```

---

## Why This Matters

**When you SSH into a server:**
- Your **local terminal** (on your laptop) displays text
- The **remote shell** (on the server) interprets commands

**When you configure aliases:**
- They go in **shell config files** (~/.bashrc)
- Not terminal settings

**When PATH is wrong:**
- It's a **shell issue**
- Not a terminal issue

---

## Common Shells

| Shell | What It Is | Where You See It |
|-------|-----------|------------------|
| **bash** | Bourne Again Shell | Default on most Linux |
| **zsh** | Z Shell | Default on macOS, feature-rich |
| **sh** | Bourne Shell | Minimal, POSIX scripts |
| **fish** | Friendly Interactive Shell | Beginner-friendly |

**Check yours:**
```bash
echo $SHELL
```

---

## Key Takeaway

**Terminal = display program (local)**  
**Shell = command interpreter (can be remote)**

Once you get this, so many things make sense.

</div>

</details>

---

<details>
<summary><strong>3. PATH: How Commands Are Found</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## The Problem Statement

```bash
$ myprogram
bash: myprogram: command not found
```

You **just installed it**. You can see the file! Why won't it run?

**Answer:** It's not in your PATH.

---

## What PATH Actually Is

PATH is a colon-separated list of directories where the shell looks for executables.

**Example PATH:**
```
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
```

**When you type `ls`, the shell:**
1. Checks `/usr/local/bin/ls` → not found
2. Checks `/usr/bin/ls` → found!
3. Executes it

**If `ls` isn't in any of those directories?** "command not found"

---

## Real Scenario: Custom Tool Installation

You install a tool in `/opt/mytool/bin`:

```bash
$ mytool
command not found
```

**Why?** `/opt/mytool/bin` isn't in PATH.

**The fix:**

```bash
# View current PATH
echo $PATH

# Add your directory (temporary - this session only)
export PATH=$PATH:/opt/mytool/bin

# Now it works
$ mytool
Tool version 1.0.0
```

---

## Making PATH Changes Permanent

**Temporary changes disappear when you log out.**

To make it stick, add to your shell config file:

**For bash:**
```bash
# Edit ~/.bashrc
echo 'export PATH=$PATH:/opt/mytool/bin' >> ~/.bashrc

# Reload
source ~/.bashrc
```

**For zsh:**
```bash
# Edit ~/.zshrc
echo 'export PATH=$PATH:/opt/mytool/bin' >> ~/.zshrc

# Reload
source ~/.zshrc
```

---

## Pro Tips

### **1. Order Matters**

```bash
export PATH=/opt/mytool/bin:$PATH
#              ↑ searched first
```

Put your custom directories **first** if you want to override system tools.

### **2. Check What Will Run**

```bash
which python
# Output: /usr/bin/python

which python3
# Output: /usr/local/bin/python3
```

### **3. See All Matches**

```bash
type -a python
# Shows all versions in PATH, in order
```

---

## Key Takeaway

**PATH is just a list of directories.**

The shell searches them **in order** until it finds your command.

"command not found" = not in any PATH directory.

**Easy fix:** Add the directory to PATH.

</div>

</details>

---

<details>
<summary><strong>4. Environment Variables That Control Everything</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## What They Are

Variables that:
- Persist across commands
- Get passed to programs you run
- Configure how tools behave

---

## The Important Ones

| Variable | What It Does | Example |
|----------|-------------|---------|
| `HOME` | Your home directory | `/home/username` |
| `USER` | Your username | `john` |
| `SHELL` | Your shell path | `/bin/bash` |
| `PWD` | Current directory | `/opt/myapp` |
| `PATH` | Where commands live | `/usr/bin:/bin` |
| `EDITOR` | Default text editor | `vim` or `nano` |
| `LANG` | Language/locale | `en_US.UTF-8` |

---

## Viewing Variables

```bash
# See all environment variables
env

# See specific variable
echo $HOME
echo $PATH
echo $USER
```

---

## Setting Variables

### **Temporary (This Session Only)**

```bash
export DATABASE_URL="postgresql://localhost/mydb"
export DEBUG=true
```

**Gone after logout.**

### **Permanent (Add to Config)**

```bash
# Add to ~/.bashrc or ~/.zshrc
echo 'export DATABASE_URL="postgresql://localhost/mydb"' >> ~/.bashrc
source ~/.bashrc
```

---

## Why "export" Matters

```bash
# Without export - only current shell sees it
MY_VAR="hello"

# With export - child processes see it too
export MY_VAR="hello"
```

**Example:**

```bash
# Set without export
DEBUG=true

# Run a script
./my-script.sh
# Script doesn't see DEBUG variable

# Set with export
export DEBUG=true

# Run a script
./my-script.sh
# Now script sees DEBUG=true
```

---

## Real Scenario: Application Config

Your app needs these variables:

```bash
DATABASE_URL=postgresql://localhost/myapp
REDIS_URL=redis://localhost:6379
API_KEY=abc123
```

**Instead of hardcoding in code, use environment variables:**

```bash
# In ~/.bashrc
export DATABASE_URL="postgresql://localhost/myapp"
export REDIS_URL="redis://localhost:6379"
export API_KEY="abc123"
```

**Now your app reads them:**
```python
import os
db_url = os.environ['DATABASE_URL']
```

**Benefits:**
- Different configs for dev/staging/prod
- No secrets in code
- Easy to change

---

## Key Takeaway

Environment variables are **configuration that travels with you**.

Set them once in your shell config, they're available everywhere.

</div>

</details>

---

<details>
<summary><strong>5. Making Changes Stick (Config Files)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## The Problem

You set an alias:

```bash
alias ll='ls -la'
```

It works! Then you log out. Next day? Gone.

**Why?** You didn't put it in a config file.

---

## Shell Config Files

### **For bash**

| File | When It's Read | What Goes Here |
|------|---------------|----------------|
| `~/.bashrc` | Every new terminal | Aliases, functions, most customizations |
| `~/.bash_profile` | Login shells (SSH) | Rarely edited directly |
| `/etc/profile` | System-wide login | Admin-level defaults |

### **For zsh**

| File | When It's Read | What Goes Here |
|------|---------------|----------------|
| `~/.zshrc` | Every new terminal | Everything (aliases, functions, PATH) |
| `~/.zprofile` | Login shells | Less common |

---

## The Best Practice

**Put everything in `~/.bashrc` (or `~/.zshrc` for zsh).**

Then make sure `~/.bash_profile` sources it:

```bash
# In ~/.bash_profile
if [ -f ~/.bashrc ]; then
    source ~/.bashrc
fi
```

**Why?** Now both login shells (SSH) and regular terminals get the same config.

---

## What to Put Where

**~/.bashrc contents:**

```bash
# PATH modifications
export PATH=$PATH:/opt/mytool/bin

# Aliases
alias ll='ls -la'
alias gs='git status'
alias k='kubectl'

# Environment variables
export EDITOR=vim
export DATABASE_URL="postgresql://localhost/mydb"

# Custom functions
deploy() {
    echo "Deploying to $1..."
    ssh $1 "cd /opt/app && git pull && systemctl restart app"
}
```

---

## After Editing Config

**Changes don't apply until you reload:**

```bash
source ~/.bashrc
```

**Or just log out and back in.**

---

## Real Scenario: Team Consistency

Your team uses the same tools. Create a shared config:

```bash
# ~/.bashrc
# DevOps team aliases
alias k='kubectl'
alias tf='terraform'
alias awslogin='aws sso login --profile prod'
alias logs='kubectl logs -f'

# Standard PATH
export PATH=$PATH:/opt/company-tools/bin

# Standard environment
export AWS_REGION=us-west-2
export KUBECONFIG=~/.kube/config
```

**Share this with the team.** Everyone has the same shortcuts.

---

## Key Takeaway

**Config files = persistence.**

Aliases, PATH changes, variables—they all go in `~/.bashrc` or `~/.zshrc`.

Edit once, they're there forever (until you change them).

</div>

</details>

---

<details>
<summary><strong>6. Productivity Boosters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Aliases: Save Your Typing

**The most common productivity hack.**

```bash
# Instead of typing this every time:
kubectl get pods --all-namespaces --watch

# Create an alias:
alias kgp='kubectl get pods --all-namespaces --watch'

# Now just type:
kgp
```

---

## Common DevOps Aliases

```bash
# Git
alias gs='git status'
alias ga='git add'
alias gc='git commit'
alias gp='git push'
alias gl='git log --oneline --graph --all'

# Docker
alias dps='docker ps'
alias di='docker images'
alias dc='docker-compose'
alias dcu='docker-compose up -d'

# Kubernetes
alias k='kubectl'
alias kgp='kubectl get pods'
alias kgs='kubectl get services'
alias kdp='kubectl describe pod'

# System
alias ll='ls -la'
alias ports='sudo netstat -tulpn'
alias myip='curl ifconfig.me'
```

**Add these to `~/.bashrc`, reload, never type the full command again.**

---

## Command History Tricks

**Don't retype. Reuse.**

```bash
# Show history
history

# Re-run command #42
!42

# Re-run last command
!!

# Re-run last command starting with 'docker'
!docker

# Search history interactively
Ctrl+R (then type to search)
```

**Example:**

```bash
$ docker run -it ubuntu bash
$ exit
$ !!   # runs 'docker run -it ubuntu bash' again
```

---

## Tab Completion

**Don't type full filenames. Let the shell help.**

```bash
$ cd /var/log/ngi<TAB>
# Autocompletes to: cd /var/log/nginx/

$ systemctl restart post<TAB>
# Autocompletes to: systemctl restart postgresql
```

---

## Custom Prompt (PS1)

**Make your prompt useful.**

**Default:**
```
user@hostname:~$
```

**Better:**
```
[user@hostname /opt/myapp] (main) $
```
Shows: username, hostname, full path, git branch

**Set it:**
```bash
# Add to ~/.bashrc
export PS1='[\u@\h \w] $ '
```

**Common PS1 codes:**
- `\u` = username
- `\h` = hostname
- `\w` = full path
- `\W` = current directory only
- `\$` = $ for user, # for root

---

## Functions for Complex Tasks

**Aliases are limited. Functions are powerful.**

```bash
# Add to ~/.bashrc
deploy() {
    if [ -z "$1" ]; then
        echo "Usage: deploy <environment>"
        return 1
    fi
    
    echo "Deploying to $1..."
    ssh $1 "cd /opt/app && git pull && systemctl restart app"
}

# Usage:
$ deploy prod
Deploying to prod...
```

---

## Key Takeaway

**Don't type the same thing twice.**

- Aliases for short commands
- Functions for complex workflows
- History for reusing past commands
- Tab completion to save keystrokes

**Invest 10 minutes in your shell config, save hours every week.**

</div>

</details>

---

<details>
<summary><strong>7. When Things Go Wrong</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Scenario 1: "command not found"

### **Symptom:**
```bash
$ python
command not found
```

### **Diagnosis:**

```bash
# Check if it's installed
which python
# If empty, not in PATH

# Check alternate names
which python3
# Output: /usr/bin/python3 (found it!)
```

### **Solutions:**

**Option 1:** Create alias
```bash
alias python=python3
```

**Option 2:** Add to PATH
```bash
# If python is in /opt/python/bin
export PATH=$PATH:/opt/python/bin
```

**Option 3:** Use full path
```bash
/usr/bin/python3 script.py
```

---

## Scenario 2: Alias Doesn't Work in Scripts

### **The Problem:**

```bash
# You have this alias in ~/.bashrc
alias k='kubectl'

# Your script:
#!/bin/bash
k get pods
# Error: k: command not found
```

### **Why:**

Scripts are **non-interactive shells**. They don't read `~/.bashrc`.

### **Solution:**

**Don't use aliases in scripts. Use full commands:**

```bash
#!/bin/bash
kubectl get pods
```

Or explicitly source bashrc:

```bash
#!/bin/bash
source ~/.bashrc
k get pods
```

---

## Scenario 3: Changes Don't Persist

### **The Problem:**

```bash
$ export DATABASE_URL="postgresql://localhost/db"
$ echo $DATABASE_URL
postgresql://localhost/db

# Log out and back in
$ echo $DATABASE_URL
# Empty!
```

### **Solution:**

**Add to config file:**

```bash
echo 'export DATABASE_URL="postgresql://localhost/db"' >> ~/.bashrc
source ~/.bashrc
```

---

## Scenario 4: Wrong Shell

### **The Problem:**

You're editing `~/.bashrc` but nothing changes.

**Check your shell:**

```bash
echo $SHELL
# Output: /bin/zsh
```

**You're using zsh, not bash!**

### **Solution:**

Edit the correct file:
- bash → `~/.bashrc`
- zsh → `~/.zshrc`

---

## Scenario 5: Cron Job Can't Find Commands

### **The Problem:**

Your cron job fails:
```
* * * * * /opt/scripts/backup.sh
# backup.sh: python: command not found
```

**But it works manually!**

### **Why:**

Cron jobs have a minimal PATH:
```
PATH=/usr/bin:/bin
```

Your python is in `/usr/local/bin`.

### **Solution:**

**Set PATH in the script:**

```bash
#!/bin/bash
export PATH=/usr/local/bin:/usr/bin:/bin
python /opt/scripts/backup.py
```

---

## Debug Commands

```bash
# What shell am I using?
echo $SHELL

# What's my PATH?
echo $PATH

# Where is this command?
which python

# What type of thing is this?
type python

# Show all versions in PATH
type -a python

# What environment variables are set?
env

# Did my config file load?
echo $MY_CUSTOM_VAR
```

---

## Key Takeaway

**Most shell problems are:**
1. PATH issues
2. Config not loaded
3. Wrong shell
4. Non-interactive environment

**Fix them systematically, not randomly.**

</div>

</details>

---

<details>
<summary><strong>8. Quick Command Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Shell Information

```bash copy
echo $SHELL   # show current shell
```

```bash copy
echo $0   # show current shell name
```

```bash copy
ps -p $$   # show current shell process
```

```bash copy
chsh -s /bin/zsh   # change default shell
```

---

## PATH Management

```bash copy
echo $PATH   # show PATH variable
```

```bash copy
export PATH=$PATH:/opt/custom/bin   # add directory to PATH (temporary)
```

```bash copy
echo 'export PATH=$PATH:/opt/bin' >> ~/.bashrc   # add to PATH permanently
```

```bash copy
which python3   # show full path of command
```

```bash copy
type python3   # show command type and location
```

```bash copy
type -a python   # show all matches in PATH
```

```bash copy
whereis python3   # show binary, source, and man page locations
```

---

## Environment Variables

```bash copy
env   # show all environment variables
```

```bash copy
printenv   # alternative to env
```

```bash copy
echo $HOME   # show home directory
```

```bash copy
echo $USER   # show current username
```

```bash copy
echo $PWD   # show current directory
```

```bash copy
export MY_VAR="value"   # set environment variable (temporary)
```

```bash copy
echo 'export MY_VAR="value"' >> ~/.bashrc   # set permanently
```

```bash copy
unset MY_VAR   # remove environment variable
```

---

## Aliases

```bash copy
alias ll='ls -la'   # create alias (temporary)
```

```bash copy
alias   # show all aliases
```

```bash copy
unalias ll   # remove alias
```

```bash copy
echo "alias ll='ls -la'" >> ~/.bashrc   # add alias permanently
```

```bash copy
\ls   # bypass alias (run actual command)
```

---

## Config Files

```bash copy
cat ~/.bashrc   # view bash config
```

```bash copy
cat ~/.bash_profile   # view bash login config
```

```bash copy
cat ~/.zshrc   # view zsh config
```

```bash copy
nano ~/.bashrc   # edit bash config
```

```bash copy
source ~/.bashrc   # reload bash config
```

```bash copy
source ~/.zshrc   # reload zsh config
```

---

## Command History

```bash copy
history   # show command history
```

```bash copy
history | grep docker   # search history
```

```bash copy
!42   # re-run command #42 from history
```

```bash copy
!!   # re-run last command
```

```bash copy
!-2   # re-run second-to-last command
```

```bash copy
!docker   # re-run last command starting with 'docker'
```

```bash copy
history -c   # clear command history
```

```bash copy
Ctrl+R   # search history interactively (then type search term)
```

---

## Help and Documentation

```bash copy
man ls   # view manual page for ls
```

```bash copy
whatis ls   # one-line description of command
```

```bash copy
apropos copy   # search man pages for keyword
```

```bash copy
ls --help   # show command help (GNU tools)
```

```bash copy
man -k network   # search man pages by keyword
```

---

## Prompt Customization

```bash copy
echo $PS1   # show current prompt format
```

```bash copy
export PS1='\u@\h:\w\$ '   # set simple prompt
```

```bash copy
export PS1='[\u@\h \w]$ '   # set prompt with brackets
```

---

## Shell Control

```bash copy
clear   # clear terminal screen
```

```bash copy
reset   # reset terminal to default state
```

```bash copy
exit   # exit current shell
```

```bash copy
logout   # logout from login shell
```

```bash copy
exec bash   # replace current shell with new one
```

---

## Debugging

```bash copy
bash -x script.sh   # run script with debug output
```

```bash copy
set -x   # enable debug mode in current shell
```

```bash copy
set +x   # disable debug mode
```

```bash copy
echo $?   # show exit code of last command
```

```bash copy
command -v python   # check if command exists
```

---

## Terminal Control

```bash copy
stty -a   # show terminal settings
```

```bash copy
tput cols   # show terminal width
```

```bash copy
tput lines   # show terminal height
```

```bash copy
resize   # update terminal size
```

---

## Job Control

```bash copy
jobs   # list background jobs
```

```bash copy
fg   # bring background job to foreground
```

```bash copy
bg   # send stopped job to background
```

```bash copy
Ctrl+Z   # suspend current foreground job
```

```bash copy
command &   # run command in background
```

```bash copy
disown   # remove job from shell's job table
```

</div>

</details>

---
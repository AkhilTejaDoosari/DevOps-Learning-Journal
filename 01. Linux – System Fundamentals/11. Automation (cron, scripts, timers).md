# **11. systemd Services — Managing Background Services and Daemons**
> Mastering service management, auto-start configuration, and log analysis.

---

## Table of Contents
- [1. Why systemd Matters](#1-why-systemd-matters)
- [2. Understanding systemd Architecture](#2-understanding-systemd-architecture)
- [3. Unit Types Explained](#3-unit-types-explained)
- [4. Viewing Service Status](#4-viewing-service-status)
- [5. Starting and Stopping Services](#5-starting-and-stopping-services)
- [6. Enabling Auto-Start at Boot](#6-enabling-auto-start-at-boot)
- [7. Reloading and Restarting Services](#7-reloading-and-restarting-services)
- [8. Service Dependencies](#8-service-dependencies)
- [9. Creating Custom Services](#9-creating-custom-services)
- [10. Service Unit File Structure](#10-service-unit-file-structure)
- [11. Timers: Replacing cron](#11-timers-replacing-cron)
- [12. Journal Logs with journalctl](#12-journal-logs-with-journalctl)
- [13. Analyzing Boot Performance](#13-analyzing-boot-performance)
- [14. Targets: System States](#14-targets-system-states)
- [15. Troubleshooting Failed Services](#15-troubleshooting-failed-services)
- [16. Real-World Scenarios](#16-real-world-scenarios)
- [17. Commands Reference](#17-commands-reference)
- [18. Quick Reference](#18-quick-reference)

---

<details>
<summary><strong>1. Why systemd Matters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every production system runs background services.

Whether it's:
- Web servers (nginx, apache)
- Databases (postgresql, mysql)
- Application servers
- Monitoring agents
- Custom microservices

Understanding systemd means:
- you can start/stop services confidently
- you can configure services to start at boot
- you can troubleshoot service failures quickly
- you can read and analyze service logs
- you can create custom service definitions

This isn't about memorizing systemctl commands.
It's about understanding how modern Linux manages services and how to control them.

</div>

</details>

---

<details>
<summary><strong>2. Understanding systemd Architecture</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-001 — What is systemd?

**systemd** is the init system and service manager for modern Linux.

**Key Responsibilities:**
- First process started (PID 1)
- Manages all services and daemons
- Handles boot process
- Manages logs (journald)
- Provides dependency management
- Offers socket activation
- Manages timers (cron replacement)

**Why systemd replaced SysV init:**
- Parallel service startup (faster boot)
- On-demand service activation
- Better dependency management
- Unified logging
- More powerful service control

---

### SYS-002 — systemd Components

**Main components:**
- **systemd** — init system (PID 1)
- **systemctl** — control services
- **journalctl** — query logs
- **systemd-analyze** — analyze boot time

**Everything is a "unit":**
Services, timers, mounts, sockets, etc. are all units managed by systemd.

</div>

</details>

---

<details>
<summary><strong>3. Unit Types Explained</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-003 — Unit Types

| Unit Type | Extension | Purpose |
|-----------|-----------|---------|
| Service | `.service` | Background daemons/services |
| Timer | `.timer` | Scheduled tasks (replaces cron) |
| Target | `.target` | Group of units (like runlevels) |
| Socket | `.socket` | IPC sockets for activation |
| Mount | `.mount` | Filesystem mount points |
| Device | `.device` | Device management |
| Path | `.path` | File/directory monitoring |

**Most common:** `.service` units

**Unit file locations:**
- `/etc/systemd/system/` — custom/override units
- `/lib/systemd/system/` — package-installed units
- `/usr/lib/systemd/system/` — distribution units

</div>

</details>

---

<details>
<summary><strong>4. Viewing Service Status</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-004 — systemctl status

**Check service status:**
```bash copy
systemctl status nginx
```

**Output shows:**
- Active state (running, stopped, failed)
- Process ID
- Memory usage
- Recent log entries
- Enabled/disabled for boot

**Example output:**
```
● nginx.service - A high performance web server
   Loaded: loaded (/lib/systemd/system/nginx.service; enabled)
   Active: active (running) since Mon 2025-01-15 10:00:00 UTC; 2 days ago
 Main PID: 1234 (nginx)
   Memory: 15.2M
   CGroup: /system.slice/nginx.service
           ├─1234 nginx: master process
           └─1235 nginx: worker process
```

**Quick check if service is active:**
```bash copy
systemctl is-active nginx
# Output: active or inactive
```

**Check if enabled at boot:**
```bash copy
systemctl is-enabled nginx
# Output: enabled or disabled
```

---

### SYS-005 — Listing Services

**All services:**
```bash copy
systemctl list-units --type=service
```

**Only running services:**
```bash copy
systemctl list-units --type=service --state=running
```

**Failed services:**
```bash copy
systemctl list-units --type=service --state=failed
```

**All installed services (including inactive):**
```bash copy
systemctl list-unit-files --type=service
```

</div>

</details>

---

<details>
<summary><strong>5. Starting and Stopping Services</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-006 — Basic Service Control

**Start service:**
```bash copy
sudo systemctl start nginx
```

**Stop service:**
```bash copy
sudo systemctl stop nginx
```

**Restart service:**
```bash copy
sudo systemctl restart nginx
```

**Important:** These commands affect current state only. They don't change boot behavior.

---

### SYS-007 — Checking Results

**After starting/stopping:**
```bash copy
systemctl status nginx
```

**Check process:**
```bash copy
ps aux | grep nginx
```

**Check logs:**
```bash copy
sudo journalctl -u nginx -n 20
```

</div>

</details>

---

<details>
<summary><strong>6. Enabling Auto-Start at Boot</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-008 — Enable and Disable

**Enable service at boot:**
```bash copy
sudo systemctl enable nginx
```

**What this does:**
Creates symlinks in `/etc/systemd/system/` so service starts at boot.

**Disable service at boot:**
```bash copy
sudo systemctl disable nginx
```

**Enable and start immediately:**
```bash copy
sudo systemctl enable --now nginx
```

**Disable and stop immediately:**
```bash copy
sudo systemctl disable --now nginx
```

---

### SYS-009 — Understanding Enable vs Start

**Common confusion:**

| Command | Effect |
|---------|--------|
| `systemctl start` | Start now, but won't auto-start at boot |
| `systemctl enable` | Auto-start at boot, but doesn't start now |
| `systemctl enable --now` | Auto-start at boot AND start now |

**Typical workflow for new service:**
```bash copy
sudo systemctl start nginx       # Test it works
sudo systemctl enable nginx      # Then enable for boot
```

**Or in one command:**
```bash copy
sudo systemctl enable --now nginx
```

</div>

</details>

---

<details>
<summary><strong>7. Reloading and Restarting Services</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-010 — Reload vs Restart

**Reload configuration (no downtime):**
```bash copy
sudo systemctl reload nginx
```

**What reload does:**
- Sends SIGHUP signal
- Service re-reads config
- Active connections maintained
- No downtime

**Restart (brief downtime):**
```bash copy
sudo systemctl restart nginx
```

**What restart does:**
- Stops service completely
- Starts service fresh
- Drops active connections
- Brief downtime

**Reload-or-restart (tries reload, falls back to restart):**
```bash copy
sudo systemctl reload-or-restart nginx
```

**When to reload:**
- Changed config file
- Want zero downtime
- Service supports reload

**When to restart:**
- Updated binary/package
- Service doesn't support reload
- Clean restart needed

</div>

</details>

---

<details>
<summary><strong>8. Service Dependencies</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-011 — Understanding Dependencies

Services often depend on other services or system states.

**Example:**
Web server needs network to be up before starting.

**View service dependencies:**
```bash copy
systemctl list-dependencies nginx
```

**Show what requires this service:**
```bash copy
systemctl list-dependencies --reverse nginx
```

**Common dependency types:**
- **Requires:** Hard dependency (must be available)
- **Wants:** Soft dependency (nice to have)
- **After:** Start after another unit
- **Before:** Start before another unit

</div>

</details>

---

<details>
<summary><strong>9. Creating Custom Services</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-012 — Creating a Service Unit

**Step 1: Create unit file**
```bash copy
sudo nano /etc/systemd/system/myapp.service
```

**Basic service example:**
```ini
[Unit]
Description=My Application
After=network.target

[Service]
Type=simple
User=myuser
WorkingDirectory=/opt/myapp
ExecStart=/usr/bin/python3 /opt/myapp/app.py
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

**Step 2: Reload systemd**
```bash copy
sudo systemctl daemon-reload
```

**Step 3: Start and enable**
```bash copy
sudo systemctl enable --now myapp
```

**Step 4: Check status**
```bash copy
systemctl status myapp
```

</div>

</details>

---

<details>
<summary><strong>10. Service Unit File Structure</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-013 — Unit File Sections

**[Unit] Section:**
Metadata and dependencies.

```ini
[Unit]
Description=My Service
Documentation=https://example.com/docs
After=network.target
Requires=postgresql.service
```

**[Service] Section:**
Service behavior and execution.

```ini
[Service]
Type=simple
User=appuser
Group=appgroup
WorkingDirectory=/opt/app
ExecStart=/usr/bin/myapp
ExecReload=/bin/kill -HUP $MAINPID
Restart=always
RestartSec=10
Environment="ENV_VAR=value"
```

**[Install] Section:**
Installation info (enable/disable).

```ini
[Install]
WantedBy=multi-user.target
```

---

### SYS-014 — Service Types

| Type | Behavior |
|------|----------|
| `simple` | Default. Process is main service. |
| `forking` | Service forks and parent exits. |
| `oneshot` | Process runs and exits (not a daemon). |
| `notify` | Service sends ready notification. |
| `dbus` | Service acquires DBus name. |

**Most common:** `simple`

---

### SYS-015 — Restart Policies

```ini
Restart=always          # Always restart
Restart=on-failure      # Restart on non-zero exit
Restart=on-abnormal     # Restart on signal/timeout
Restart=no              # Never restart (default)
```

**RestartSec:**
```ini
RestartSec=10           # Wait 10 seconds before restart
```

</div>

</details>

---

<details>
<summary><strong>11. Timers: Replacing cron</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-016 — systemd Timers

**Timers** are systemd's replacement for cron.

**Advantages over cron:**
- Integrated with service management
- Better logging (journald)
- Run missed jobs on boot
- More flexible scheduling

**Create timer unit:**
```bash copy
sudo nano /etc/systemd/system/backup.timer
```

**Timer example:**
```ini
[Unit]
Description=Daily Backup Timer

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
```

**Corresponding service:**
```bash copy
sudo nano /etc/systemd/system/backup.service
```

```ini
[Unit]
Description=Backup Service

[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup.sh
```

**Enable timer:**
```bash copy
sudo systemctl enable --now backup.timer
```

**Check timer status:**
```bash copy
systemctl status backup.timer
```

**List all timers:**
```bash copy
systemctl list-timers
```

---

### SYS-017 — Timer Schedules

**Common OnCalendar values:**
- `daily` → Once per day at midnight
- `weekly` → Once per week
- `monthly` → Once per month
- `*:0/15` → Every 15 minutes
- `Mon,Fri 10:00` → Monday and Friday at 10am

**Other timer options:**
- `OnBootSec=15min` → 15 minutes after boot
- `OnUnitActiveSec=1h` → 1 hour after last activation
- `Persistent=true` → Run missed executions on boot

</div>

</details>

---

<details>
<summary><strong>12. Journal Logs with journalctl</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-018 — journalctl Basics

**View all logs:**
```bash copy
sudo journalctl
```

**Follow logs (live):**
```bash copy
sudo journalctl -f
```

**Logs for specific service:**
```bash copy
sudo journalctl -u nginx
```

**Last N lines:**
```bash copy
sudo journalctl -u nginx -n 50
```

**Follow service logs:**
```bash copy
sudo journalctl -u nginx -f
```

---

### SYS-019 — Time-Based Filtering

**Since specific time:**
```bash copy
sudo journalctl --since "2025-01-15 10:00:00"
```

**Since relative time:**
```bash copy
sudo journalctl --since "1 hour ago"
sudo journalctl --since "today"
sudo journalctl --since "yesterday"
```

**Time range:**
```bash copy
sudo journalctl --since "2025-01-15" --until "2025-01-16"
```

**Boot-based:**
```bash copy
sudo journalctl -b          # Current boot
sudo journalctl -b -1       # Previous boot
```

---

### SYS-020 — Advanced Filtering

**Priority levels:**
```bash copy
sudo journalctl -p err      # Errors only
sudo journalctl -p warning  # Warnings and above
```

**Kernel messages:**
```bash copy
sudo journalctl -k
```

**Specific unit with priority:**
```bash copy
sudo journalctl -u nginx -p err
```

**Output formats:**
```bash copy
sudo journalctl -o json     # JSON format
sudo journalctl -o json-pretty
sudo journalctl -o verbose
```

---

### SYS-021 — Managing Journal Size

**Check disk usage:**
```bash copy
sudo journalctl --disk-usage
```

**Vacuum by time:**
```bash copy
sudo journalctl --vacuum-time=7d
# Keep only last 7 days
```

**Vacuum by size:**
```bash copy
sudo journalctl --vacuum-size=500M
# Keep only 500MB
```

**Configure in `/etc/systemd/journald.conf`:**
```ini
SystemMaxUse=500M
SystemKeepFree=1G
```

</div>

</details>

---

<details>
<summary><strong>13. Analyzing Boot Performance</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-022 — systemd-analyze

**Overall boot time:**
```bash copy
systemd-analyze
```

**Output:**
```
Startup finished in 2.1s (kernel) + 8.3s (userspace) = 10.4s
```

**Blame (slowest services):**
```bash copy
systemd-analyze blame
```

**Shows services sorted by startup time.**

**Critical chain (boot path):**
```bash copy
systemd-analyze critical-chain
```

**Shows dependency tree for boot target.**

**Service startup time:**
```bash copy
systemd-analyze critical-chain nginx.service
```

**Visual plot:**
```bash copy
systemd-analyze plot > boot.svg
```

Creates SVG chart of boot process.

</div>

</details>

---

<details>
<summary><strong>14. Targets: System States</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-023 — Understanding Targets

**Targets** are groups of units (like old runlevels).

**Common targets:**

| Target | Old Runlevel | Purpose |
|--------|--------------|---------|
| `poweroff.target` | 0 | Shutdown |
| `rescue.target` | 1 | Single-user mode |
| `multi-user.target` | 3 | Multi-user, no GUI |
| `graphical.target` | 5 | Multi-user with GUI |
| `reboot.target` | 6 | Reboot |

**Check current target:**
```bash copy
systemctl get-default
```

**Set default target:**
```bash copy
sudo systemctl set-default multi-user.target
```

**Switch to target (now):**
```bash copy
sudo systemctl isolate multi-user.target
```

**List available targets:**
```bash copy
systemctl list-units --type=target
```

</div>

</details>

---

<details>
<summary><strong>15. Troubleshooting Failed Services</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### SYS-024 — Debugging Failed Services

**Service failed to start:**

**Step 1: Check status**
```bash copy
systemctl status myapp
```

**Step 2: View logs**
```bash copy
sudo journalctl -u myapp -n 50
```

**Step 3: Check unit file**
```bash copy
systemctl cat myapp
```

**Step 4: Verify paths**
```bash copy
# Check if ExecStart path exists
ls -l /path/to/executable

# Check working directory
ls -ld /path/to/workdir
```

**Step 5: Test manually**
```bash copy
# Run command as service user
sudo -u serviceuser /path/to/executable
```

**Step 6: Check permissions**
```bash copy
# Does service user have access?
sudo -u serviceuser ls /path/to/files
```

---

### SYS-025 — Common Failure Reasons

**Permission denied:**
Service user can't read/execute files.

**File not found:**
Wrong path in ExecStart or WorkingDirectory.

**Port already in use:**
Another process using same port.

**Dependency failed:**
Required service not running.

**Configuration error:**
Syntax error in application config.

</div>

</details>

---

<details>
<summary><strong>16. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Service Won't Start

**Symptom:**
`systemctl start myapp` fails.

**Cause:**
Misconfigured service unit or application error.

**Fix:**
```bash copy
# Check status
systemctl status myapp

# View recent logs
sudo journalctl -u myapp -n 50

# Check unit file
systemctl cat myapp

# Test manually
sudo -u appuser /usr/bin/myapp

# Fix issue, then reload
sudo systemctl daemon-reload
sudo systemctl start myapp
```

**Confirm:**
```bash copy
systemctl status myapp
# Output: active (running)
```

---

### Scenario 2: Service Doesn't Start at Boot

**Symptom:**
Service works when started manually, but not after reboot.

**Cause:**
Service not enabled for auto-start.

**Fix:**
```bash copy
# Check if enabled
systemctl is-enabled myapp
# Output: disabled

# Enable it
sudo systemctl enable myapp

# Verify
systemctl is-enabled myapp
# Output: enabled
```

**Confirm:**
```bash copy
sudo reboot
# After reboot:
systemctl status myapp
# Service should be running
```

---

### Scenario 3: Apply Config Changes

**Symptom:**
Changed nginx config, need to apply without downtime.

**Cause:**
Config modification requires reload.

**Fix:**
```bash copy
# Test config first
sudo nginx -t

# If OK, reload
sudo systemctl reload nginx
```

**Confirm:**
```bash copy
systemctl status nginx
# No restart, connections maintained
```

---

### Scenario 4: Service Crashes Repeatedly

**Symptom:**
Service starts but crashes after few seconds.

**Cause:**
Application bug or resource issue.

**Fix:**
```bash copy
# View crash logs
sudo journalctl -u myapp -f

# Check for patterns
sudo journalctl -u myapp | grep -i error

# Disable auto-restart temporarily
sudo systemctl edit myapp
```

Add:
```ini
[Service]
Restart=no
```

```bash copy
# Restart to test
sudo systemctl daemon-reload
sudo systemctl restart myapp

# Debug the issue
```

**Confirm:**
Fixed application bug, re-enabled Restart=always.

---

### Scenario 5: Need to Run Task Daily

**Symptom:**
Need backup script to run every day at 2 AM.

**Cause:**
No scheduled task configured.

**Fix:**
```bash copy
# Create service
sudo nano /etc/systemd/system/backup.service
```

```ini
[Unit]
Description=Daily Backup

[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup.sh
```

```bash copy
# Create timer
sudo nano /etc/systemd/system/backup.timer
```

```ini
[Unit]
Description=Daily Backup Timer

[Timer]
OnCalendar=*-*-* 02:00:00
Persistent=true

[Install]
WantedBy=timers.target
```

```bash copy
# Enable timer
sudo systemctl daemon-reload
sudo systemctl enable --now backup.timer
```

**Confirm:**
```bash copy
systemctl list-timers | grep backup
# Shows next execution time
```

---

### Scenario 6: Analyze Slow Boot

**Symptom:**
System takes too long to boot.

**Cause:**
Slow services during startup.

**Fix:**
```bash copy
# Check boot time
systemd-analyze

# Find slowest services
systemd-analyze blame | head -20

# Check critical chain
systemd-analyze critical-chain

# Disable slow, non-essential services
sudo systemctl disable slow-service
```

**Confirm:**
```bash copy
sudo reboot
systemd-analyze
# Boot time improved
```

</div>

</details>

---

<details>
<summary><strong>17. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Service Control:**

```bash copy
systemctl status nginx   # view service status
```

```bash copy
sudo systemctl start nginx   # start service
```

```bash copy
sudo systemctl stop nginx   # stop service
```

```bash copy
sudo systemctl restart nginx   # restart service
```

```bash copy
sudo systemctl reload nginx   # reload config (no downtime)
```

```bash copy
sudo systemctl reload-or-restart nginx   # reload if possible, restart if needed
```

```bash copy
sudo systemctl enable nginx   # auto-start at boot
```

```bash copy
sudo systemctl disable nginx   # don't auto-start at boot
```

```bash copy
sudo systemctl enable --now nginx   # enable and start immediately
```

```bash copy
sudo systemctl disable --now nginx   # disable and stop immediately
```

```bash copy
systemctl is-active nginx   # check if running
```

```bash copy
systemctl is-enabled nginx   # check if enabled at boot
```

**Listing Services:**

```bash copy
systemctl list-units --type=service   # all loaded services
```

```bash copy
systemctl list-units --type=service --state=running   # running services
```

```bash copy
systemctl list-units --type=service --state=failed   # failed services
```

```bash copy
systemctl list-unit-files --type=service   # all installed services
```

**Dependencies:**

```bash copy
systemctl list-dependencies nginx   # show dependencies
```

```bash copy
systemctl list-dependencies --reverse nginx   # what depends on this
```

**Service Configuration:**

```bash copy
systemctl cat nginx   # view service unit file
```

```bash copy
sudo systemctl edit nginx   # create override file
```

```bash copy
sudo systemctl edit --full nginx   # edit entire file
```

```bash copy
sudo systemctl daemon-reload   # reload systemd config
```

**Logs (journalctl):**

```bash copy
sudo journalctl -u nginx   # logs for service
```

```bash copy
sudo journalctl -u nginx -f   # follow logs
```

```bash copy
sudo journalctl -u nginx -n 50   # last 50 lines
```

```bash copy
sudo journalctl -u nginx --since "1 hour ago"   # time filter
```

```bash copy
sudo journalctl -u nginx --since today   # today's logs
```

```bash copy
sudo journalctl -u nginx -p err   # errors only
```

```bash copy
sudo journalctl -b   # current boot logs
```

```bash copy
sudo journalctl -k   # kernel logs
```

```bash copy
sudo journalctl --disk-usage   # check journal size
```

```bash copy
sudo journalctl --vacuum-time=7d   # keep last 7 days
```

```bash copy
sudo journalctl --vacuum-size=500M   # keep 500MB max
```

**Timers:**

```bash copy
systemctl list-timers   # list all timers
```

```bash copy
systemctl status backup.timer   # timer status
```

```bash copy
sudo systemctl enable --now backup.timer   # enable timer
```

**Boot Analysis:**

```bash copy
systemd-analyze   # overall boot time
```

```bash copy
systemd-analyze blame   # slowest services
```

```bash copy
systemd-analyze critical-chain   # boot dependency chain
```

```bash copy
systemd-analyze critical-chain nginx.service   # service dependencies
```

**Targets:**

```bash copy
systemctl get-default   # current default target
```

```bash copy
sudo systemctl set-default multi-user.target   # set default target
```

```bash copy
sudo systemctl isolate multi-user.target   # switch to target now
```

```bash copy
systemctl list-units --type=target   # list targets
```

**System Control:**

```bash copy
sudo systemctl reboot   # reboot system
```

```bash copy
sudo systemctl poweroff   # shutdown system
```

```bash copy
sudo systemctl suspend   # suspend system
```

```bash copy
sudo systemctl hibernate   # hibernate system
```

</div>

</details>

---

<details>
<summary><strong>18. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- systemd is PID 1 and manages all services
- `start/stop` affects current state, `enable/disable` affects boot behavior
- `reload` reloads config without downtime, `restart` stops and starts
- Every service has a unit file in `/etc/systemd/system/` or `/lib/systemd/system/`
- Use `journalctl -u service` to view service logs
- Timers replace cron with better integration
- Always run `daemon-reload` after creating/editing unit files
- Use `systemd-analyze` to diagnose slow boot

**systemctl Quick Reference:**

| Command | Purpose |
|---------|---------|
| `systemctl status nginx` | View service status |
| `systemctl start nginx` | Start service now |
| `systemctl stop nginx` | Stop service now |
| `systemctl restart nginx` | Restart service |
| `systemctl reload nginx` | Reload config (no downtime) |
| `systemctl enable nginx` | Auto-start at boot |
| `systemctl disable nginx` | Don't auto-start at boot |
| `systemctl enable --now nginx` | Enable + start immediately |
| `systemctl is-active nginx` | Check if running |
| `systemctl is-enabled nginx` | Check if boot-enabled |

**Service States:**

| State | Meaning |
|-------|---------|
| `active (running)` | Service is running |
| `active (exited)` | Oneshot service completed successfully |
| `inactive (dead)` | Service stopped |
| `failed` | Service crashed or failed to start |
| `activating` | Service starting up |
| `deactivating` | Service shutting down |

**Unit File Structure:**

```ini
[Unit]
Description=My Service
After=network.target

[Service]
Type=simple
User=myuser
ExecStart=/usr/bin/myapp
Restart=always

[Install]
WantedBy=multi-user.target
```

**Service Types:**

| Type | Description |
|------|-------------|
| `simple` | Main process is service (default) |
| `forking` | Service forks, parent exits |
| `oneshot` | Runs once and exits |
| `notify` | Sends ready notification |
| `dbus` | Acquires DBus name |

**Restart Policies:**

| Policy | Effect |
|--------|--------|
| `always` | Always restart |
| `on-failure` | Restart on non-zero exit |
| `on-abnormal` | Restart on signal/timeout |
| `no` | Never restart (default) |

**Unit File Locations:**

| Location | Purpose |
|----------|---------|
| `/etc/systemd/system/` | Custom/admin units (highest priority) |
| `/run/systemd/system/` | Runtime units |
| `/lib/systemd/system/` | Package-installed units |
| `/usr/lib/systemd/system/` | Distribution units |

**journalctl Quick Reference:**

| Command | Purpose |
|---------|---------|
| `journalctl -u nginx` | Logs for service |
| `journalctl -u nginx -f` | Follow logs live |
| `journalctl -u nginx -n 50` | Last 50 lines |
| `journalctl --since "1 hour ago"` | Last hour |
| `journalctl --since today` | Today's logs |
| `journalctl -b` | Current boot |
| `journalctl -p err` | Errors only |
| `journalctl -k` | Kernel messages |

**Priority Levels:**

| Level | Meaning |
|-------|---------|
| `emerg` | System unusable |
| `alert` | Action needed immediately |
| `crit` | Critical conditions |
| `err` | Error conditions |
| `warning` | Warning conditions |
| `notice` | Normal but significant |
| `info` | Informational |
| `debug` | Debug messages |

**Common Targets:**

| Target | Old Runlevel | Purpose |
|--------|--------------|---------|
| `poweroff.target` | 0 | Shutdown |
| `rescue.target` | 1 | Single-user mode |
| `multi-user.target` | 3 | Multi-user, CLI |
| `graphical.target` | 5 | Multi-user with GUI |
| `reboot.target` | 6 | Reboot |

**Enable vs Start:**

| Scenario | Commands |
|----------|----------|
| Test service first | `start` then `enable` |
| Enable and start together | `enable --now` |
| Stop and disable together | `disable --now` |
| Boot behavior only | `enable` or `disable` |
| Current state only | `start` or `stop` |

**Reload vs Restart:**

| Action | Reload | Restart |
|--------|--------|---------|
| Downtime | None | Brief |
| Connections | Maintained | Dropped |
| Config changes | Yes | Yes |
| Binary updates | No | Yes |
| Signal | SIGHUP | SIGTERM |

**Timer Example:**

**backup.timer:**
```ini
[Unit]
Description=Daily Backup

[Timer]
OnCalendar=daily
Persistent=true

[Install]
WantedBy=timers.target
```

**backup.service:**
```ini
[Unit]
Description=Backup Script

[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup.sh
```

**OnCalendar Examples:**

| Pattern | Meaning |
|---------|---------|
| `daily` | Once per day at midnight |
| `weekly` | Once per week (Monday) |
| `monthly` | Once per month |
| `*:0/15` | Every 15 minutes |
| `Mon,Fri 10:00` | Mon & Fri at 10am |
| `*-*-* 02:00:00` | Daily at 2am |

**Troubleshooting Checklist:**

| Issue | Check |
|-------|-------|
| Service won't start | `systemctl status`, `journalctl -u service` |
| Not starting at boot | `systemctl is-enabled` |
| Config changes not applied | `daemon-reload`, then `restart` or `reload` |
| Service crashes | `journalctl -u service -f` for real-time logs |
| Slow boot | `systemd-analyze blame` |
| Port conflict | `ss -tulnp \| grep port` |

**systemd-analyze Commands:**

| Command | Purpose |
|---------|---------|
| `systemd-analyze` | Overall boot time |
| `systemd-analyze blame` | Slowest services |
| `systemd-analyze critical-chain` | Boot path dependencies |
| `systemd-analyze plot > boot.svg` | Visual boot timeline |

**Best Practices:**

1. **Always test before enabling:** Start service first, enable only when working
2. **Use reload when possible:** Avoid downtime for config changes
3. **Set Restart=always for critical services:** Automatic recovery from crashes
4. **Use timers instead of cron:** Better integration and logging
5. **Check logs with journalctl:** Centralized, structured logging
6. **Run daemon-reload after edits:** Always reload after changing unit files
7. **Use --now flag:** Combines enable+start or disable+stop

**What's Next:**
Congratulations! You've completed the Linux Essentials series. You now have a solid foundation in Linux system administration, covering everything from basic navigation to service management. Practice these skills, apply them to real projects, and continue building on this foundation.

</div>

</details>

---
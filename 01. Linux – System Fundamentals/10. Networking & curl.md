# **10. Networking Basics — Understanding Connectivity and Troubleshooting**
> Mastering IP addresses, DNS, ports, and network troubleshooting tools.

---

## Table of Contents
- [1. Why Networking Knowledge Matters](#1-why-networking-knowledge-matters)
- [2. Understanding IP Addresses](#2-understanding-ip-addresses)
- [3. Network Interfaces and Configuration](#3-network-interfaces-and-configuration)
- [4. DNS: Domain Name System](#4-dns-domain-name-system)
- [5. Ports and Services](#5-ports-and-services)
- [6. Testing Connectivity with ping](#6-testing-connectivity-with-ping)
- [7. Tracing Routes with traceroute](#7-tracing-routes-with-traceroute)
- [8. Checking Open Ports](#8-checking-open-ports)
- [9. Network Statistics with ss and netstat](#9-network-statistics-with-ss-and-netstat)
- [10. Downloading Files](#10-downloading-files)
- [11. Testing HTTP Endpoints](#11-testing-http-endpoints)
- [12. Firewall Basics](#12-firewall-basics)
- [13. SSH Remote Access](#13-ssh-remote-access)
- [14. Transferring Files with SCP and rsync](#14-transferring-files-with-scp-and-rsync)
- [15. Network Troubleshooting Methodology](#15-network-troubleshooting-methodology)
- [16. Real-World Scenarios](#16-real-world-scenarios)
- [17. Commands Reference](#17-commands-reference)
- [18. Quick Reference](#18-quick-reference)

---

<details>
<summary><strong>1. Why Networking Knowledge Matters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every server communicates over a network.

Whether it's:
- Users accessing web applications
- Microservices talking to each other
- Databases accepting connections
- APIs responding to requests
- Monitoring systems collecting metrics

Understanding networking means:
- you can diagnose connectivity issues quickly
- you can verify service availability
- you can troubleshoot DNS problems
- you can secure network access properly

This isn't about memorizing protocols.
It's about understanding how systems communicate and how to diagnose problems when they don't.

</div>

</details>

---

<details>
<summary><strong>2. Understanding IP Addresses</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-001 — IPv4 Basics

**IP Address:** Unique identifier for a device on a network.

**Format:** Four octets (0-255) separated by dots.
```
192.168.1.100
```

**Components:**
- **Network portion:** Identifies the network
- **Host portion:** Identifies the device

**Private IP Ranges (RFC 1918):**
- `10.0.0.0` to `10.255.255.255` (Class A)
- `172.16.0.0` to `172.31.255.255` (Class B)
- `192.168.0.0` to `192.168.255.255` (Class C)

**Public IP Addresses:**
Globally routable, assigned by ISPs.

**Special Addresses:**
- `127.0.0.1` — localhost (loopback)
- `0.0.0.0` — all addresses (typically means "any")
- `255.255.255.255` — broadcast

---

### NET-002 — Subnet Masks

**Subnet mask** defines network and host portions.

**Common masks:**
- `255.255.255.0` (or `/24`) — 256 addresses (254 usable)
- `255.255.0.0` (or `/16`) — 65,536 addresses
- `255.0.0.0` (or `/8`) — 16,777,216 addresses

**CIDR Notation:**
`192.168.1.0/24` means network 192.168.1.0 with mask 255.255.255.0

**Why This Matters:**
Subnet determines which devices can communicate directly vs. needing a router.

---

### NET-003 — IPv6 Overview

**IPv6:** Next-generation IP addressing (128-bit).

**Format:**
```
2001:0db8:85a3:0000:0000:8a2e:0370:7334
```

**Shortened:**
```
2001:db8:85a3::8a2e:370:7334
```

**Why IPv6?**
IPv4 addresses exhausted. IPv6 provides vastly more addresses.

**Loopback:**
`::1` (equivalent to 127.0.0.1)

</div>

</details>

---

<details>
<summary><strong>3. Network Interfaces and Configuration</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-004 — Viewing Network Interfaces

**Modern command (`ip`):**
```bash copy
ip addr show
```

**Short form:**
```bash copy
ip a
```

**Legacy command (`ifconfig`):**
```bash copy
ifconfig
```

**Common interfaces:**
- `eth0`, `ens33`, `enp0s3` — Ethernet
- `wlan0`, `wlp3s0` — Wireless
- `lo` — Loopback (127.0.0.1)
- `docker0` — Docker bridge
- `br0` — Network bridge

---

### NET-005 — Interface Status

**Check if interface is up:**
```bash copy
ip link show eth0
```

**Bring interface up:**
```bash copy
sudo ip link set eth0 up
```

**Bring interface down:**
```bash copy
sudo ip link set eth0 down
```

---

### NET-006 — Default Gateway

**Gateway:** Router that forwards traffic to other networks.

**View default gateway:**
```bash copy
ip route show
```

**Or:**
```bash copy
route -n
```

**Output example:**
```
default via 192.168.1.1 dev eth0
```

`192.168.1.1` is the default gateway.

</div>

</details>

---

<details>
<summary><strong>4. DNS: Domain Name System</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-007 — DNS Basics

**DNS** translates domain names to IP addresses.

```
google.com → 142.250.185.46
```

**Why DNS?**
Humans remember names, computers use IPs.

**DNS Resolution Process:**
1. Check local hosts file (`/etc/hosts`)
2. Query DNS servers (listed in `/etc/resolv.conf`)
3. Return IP address

---

### NET-008 — DNS Configuration

**/etc/hosts:**
Static hostname-to-IP mappings.

```bash copy
cat /etc/hosts
# Output:
127.0.0.1   localhost
192.168.1.10   webserver
```

**/etc/resolv.conf:**
DNS server configuration.

```bash copy
cat /etc/resolv.conf
# Output:
nameserver 8.8.8.8
nameserver 8.8.4.4
```

**Common DNS servers:**
- `8.8.8.8`, `8.8.4.4` — Google DNS
- `1.1.1.1`, `1.0.0.1` — Cloudflare DNS
- `208.67.222.222`, `208.67.220.220` — OpenDNS

---

### NET-009 — DNS Lookup Tools

**`nslookup`** (legacy):**
```bash copy
nslookup google.com
```

**`dig`** (modern, detailed):**
```bash copy
dig google.com
```

**Short answer:**
```bash copy
dig +short google.com
```

**Reverse DNS lookup:**
```bash copy
dig -x 8.8.8.8
```

**Query specific DNS server:**
```bash copy
dig @8.8.8.8 google.com
```

**`host`** (simple):**
```bash copy
host google.com
```

</div>

</details>

---

<details>
<summary><strong>5. Ports and Services</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-010 — Understanding Ports

**Port:** Endpoint for network connections.

**Port number range:** 0-65535

**Port categories:**
- **Well-known ports (0-1023):** Reserved for standard services
- **Registered ports (1024-49151):** Assigned to specific services
- **Dynamic/Private (49152-65535):** Temporary, client-side

---

### NET-011 — Common Ports

| Port | Service | Protocol |
|------|---------|----------|
| 20/21 | FTP | TCP |
| 22 | SSH | TCP |
| 25 | SMTP (email) | TCP |
| 53 | DNS | UDP/TCP |
| 80 | HTTP | TCP |
| 443 | HTTPS | TCP |
| 3306 | MySQL | TCP |
| 5432 | PostgreSQL | TCP |
| 6379 | Redis | TCP |
| 8080 | HTTP alternate | TCP |
| 27017 | MongoDB | TCP |

**Why This Matters:**
Services listen on specific ports. Firewall rules and connections target ports.

</div>

</details>

---

<details>
<summary><strong>6. Testing Connectivity with ping</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-012 — ping Command

**`ping`** tests if a host is reachable.

**Basic usage:**
```bash copy
ping google.com
```

**Output:**
```
64 bytes from 142.250.185.46: icmp_seq=1 ttl=117 time=12.3 ms
```

**Send N packets:**
```bash copy
ping -c 4 google.com
```

**Continuous ping:**
```bash copy
ping google.com
# Ctrl+C to stop
```

**Ping by IP:**
```bash copy
ping 8.8.8.8
```

---

### NET-013 — Understanding ping Output

**Key metrics:**
- **time:** Round-trip time in milliseconds
- **ttl:** Time-to-live (hops remaining)
- **icmp_seq:** Packet sequence number

**Interpreting results:**
- **Reply received:** Host is reachable
- **Request timeout:** Host unreachable or blocking ICMP
- **Destination host unreachable:** Network routing problem

**Statistics:**
```
--- google.com ping statistics ---
4 packets transmitted, 4 received, 0% packet loss, time 3004ms
rtt min/avg/max/mdev = 11.8/12.5/13.2/0.5 ms
```

</div>

</details>

---

<details>
<summary><strong>7. Tracing Routes with traceroute</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-014 — traceroute Command

**`traceroute`** shows path packets take to destination.

```bash copy
traceroute google.com
```

**On some systems:**
```bash copy
tracepath google.com
```

**Output:**
```
 1  192.168.1.1 (192.168.1.1)  1.234 ms
 2  10.0.0.1 (10.0.0.1)  8.456 ms
 3  142.250.185.46 (142.250.185.46)  12.789 ms
```

**What it shows:**
Each hop (router) between you and destination.

**Why use traceroute:**
- Identify where connection fails
- See network path
- Measure latency at each hop

**If hop shows `* * *`:**
Router not responding to traceroute (firewall or config).

</div>

</details>

---

<details>
<summary><strong>8. Checking Open Ports</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-015 — nmap (Network Mapper)

**`nmap`** scans for open ports.

**Installation:**
```bash copy
sudo apt install nmap     # Debian/Ubuntu
sudo dnf install nmap     # RHEL/Fedora
```

**Scan single host:**
```bash copy
nmap 192.168.1.100
```

**Scan specific ports:**
```bash copy
nmap -p 80,443,22 192.168.1.100
```

**Scan port range:**
```bash copy
nmap -p 1-1000 192.168.1.100
```

**Fast scan (common ports):**
```bash copy
nmap -F 192.168.1.100
```

**Service version detection:**
```bash copy
nmap -sV 192.168.1.100
```

---

### NET-016 — telnet for Port Testing

**`telnet`** tests if port is open.

```bash copy
telnet google.com 80
```

**If successful:**
```
Connected to google.com.
Escape character is '^]'.
```

**If failed:**
```
Unable to connect to remote host: Connection refused
```

**Exit telnet:** `Ctrl+]` then type `quit`

---

### NET-017 — nc (netcat)

**`nc`** (netcat) is more versatile.

**Test port:**
```bash copy
nc -zv google.com 80
# -z: scan without sending data
# -v: verbose
```

**Output:**
```
Connection to google.com 80 port [tcp/http] succeeded!
```

**Listen on port:**
```bash copy
nc -l 8080
# Listens on port 8080 (for testing)
```

</div>

</details>

---

<details>
<summary><strong>9. Network Statistics with ss and netstat</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-018 — ss Command (Modern)

**`ss`** shows socket statistics.

**All listening ports:**
```bash copy
ss -tuln
# -t: TCP
# -u: UDP
# -l: listening
# -n: numeric (don't resolve names)
```

**All connections:**
```bash copy
ss -tun
```

**Show process using port:**
```bash copy
sudo ss -tulnp
# -p: show process
```

**Filter by port:**
```bash copy
ss -tuln | grep :80
```

**Established connections:**
```bash copy
ss -tun state established
```

---

### NET-019 — netstat Command (Legacy)

**Similar to `ss`, older systems.**

```bash copy
netstat -tuln
```

**Show processes:**
```bash copy
sudo netstat -tulnp
```

**Why use `ss` instead of `netstat`?**
- Faster
- More detailed
- Part of modern iproute2 package

---

### NET-020 — lsof for Network

**`lsof`** lists open files, including network sockets.

**What's using port 80:**
```bash copy
sudo lsof -i :80
```

**What's using port 22:**
```bash copy
sudo lsof -i :22
```

**All network connections:**
```bash copy
sudo lsof -i
```

**Specific protocol:**
```bash copy
sudo lsof -i tcp
sudo lsof -i udp
```

</div>

</details>

---

<details>
<summary><strong>10. Downloading Files</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-021 — wget

**`wget`** downloads files from URLs.

**Basic download:**
```bash copy
wget https://example.com/file.zip
```

**Save with different name:**
```bash copy
wget -O custom_name.zip https://example.com/file.zip
```

**Continue interrupted download:**
```bash copy
wget -c https://example.com/largefile.iso
```

**Download in background:**
```bash copy
wget -b https://example.com/file.zip
```

**Recursive download (entire site):**
```bash copy
wget -r https://example.com
```

---

### NET-022 — curl

**`curl`** transfers data from/to servers.

**Download file:**
```bash copy
curl -O https://example.com/file.zip
```

**Save with different name:**
```bash copy
curl -o custom_name.zip https://example.com/file.zip
```

**Follow redirects:**
```bash copy
curl -L https://example.com/file.zip
```

**Show only headers:**
```bash copy
curl -I https://example.com
```

**POST request:**
```bash copy
curl -X POST -d "key=value" https://api.example.com/endpoint
```

**JSON POST:**
```bash copy
curl -X POST -H "Content-Type: application/json" -d '{"key":"value"}' https://api.example.com
```

**wget vs curl:**
- **wget:** Better for recursive downloads, resuming
- **curl:** Better for APIs, testing, complex requests

</div>

</details>

---

<details>
<summary><strong>11. Testing HTTP Endpoints</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-023 — Testing Web Services

**Check if web server responds:**
```bash copy
curl -I http://example.com
```

**Get HTTP status code:**
```bash copy
curl -o /dev/null -s -w "%{http_code}\n" http://example.com
```

**Test API endpoint:**
```bash copy
curl https://api.github.com/users/octocat
```

**With authentication:**
```bash copy
curl -u username:password https://api.example.com
```

**Bearer token:**
```bash copy
curl -H "Authorization: Bearer TOKEN" https://api.example.com
```

**Measure response time:**
```bash copy
curl -o /dev/null -s -w "Time: %{time_total}s\n" http://example.com
```

</div>

</details>

---

<details>
<summary><strong>12. Firewall Basics</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-024 — ufw (Ubuntu/Debian)

**UFW (Uncomplicated Firewall)** manages iptables easily.

**Enable firewall:**
```bash copy
sudo ufw enable
```

**Check status:**
```bash copy
sudo ufw status
```

**Allow port:**
```bash copy
sudo ufw allow 80
sudo ufw allow 443
sudo ufw allow 22
```

**Allow specific service:**
```bash copy
sudo ufw allow ssh
sudo ufw allow http
sudo ufw allow https
```

**Deny port:**
```bash copy
sudo ufw deny 8080
```

**Delete rule:**
```bash copy
sudo ufw delete allow 80
```

**Allow from specific IP:**
```bash copy
sudo ufw allow from 192.168.1.100
```

**Disable firewall:**
```bash copy
sudo ufw disable
```

---

### NET-025 — firewalld (RHEL/Fedora)

**Firewalld** is default on RHEL-based systems.

**Check status:**
```bash copy
sudo firewall-cmd --state
```

**List rules:**
```bash copy
sudo firewall-cmd --list-all
```

**Allow service:**
```bash copy
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --reload
```

**Allow port:**
```bash copy
sudo firewall-cmd --permanent --add-port=8080/tcp
sudo firewall-cmd --reload
```

**Remove service:**
```bash copy
sudo firewall-cmd --permanent --remove-service=http
sudo firewall-cmd --reload
```

</div>

</details>

---

<details>
<summary><strong>13. SSH Remote Access</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-026 — SSH Basics

**SSH (Secure Shell)** provides secure remote access.

**Connect to server:**
```bash copy
ssh username@hostname
```

**Specify port:**
```bash copy
ssh -p 2222 username@hostname
```

**Use SSH key:**
```bash copy
ssh -i ~/.ssh/id_rsa username@hostname
```

**Execute command remotely:**
```bash copy
ssh username@hostname 'ls -la'
```

**SSH config file:**
Location: `~/.ssh/config`

Example:
```
Host myserver
    HostName 192.168.1.100
    User akhil
    Port 22
    IdentityFile ~/.ssh/id_rsa
```

Then connect with:
```bash copy
ssh myserver
```

---

### NET-027 — SSH Key Authentication

**Generate SSH key:**
```bash copy
ssh-keygen -t rsa -b 4096 -C "your_email@example.com"
```

**Copy key to server:**
```bash copy
ssh-copy-id username@hostname
```

**Manual key copy:**
```bash copy
cat ~/.ssh/id_rsa.pub | ssh username@hostname "mkdir -p ~/.ssh && cat >> ~/.ssh/authorized_keys"
```

**Set correct permissions:**
```bash copy
chmod 700 ~/.ssh
chmod 600 ~/.ssh/authorized_keys
```

**Why use keys instead of passwords:**
- More secure
- No password typing
- Required for automation

</div>

</details>

---

<details>
<summary><strong>14. Transferring Files with SCP and rsync</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-028 — scp (Secure Copy)

**Copy file to remote:**
```bash copy
scp file.txt username@hostname:/remote/path/
```

**Copy from remote:**
```bash copy
scp username@hostname:/remote/file.txt /local/path/
```

**Copy directory:**
```bash copy
scp -r directory/ username@hostname:/remote/path/
```

**Specify port:**
```bash copy
scp -P 2222 file.txt username@hostname:/remote/path/
```

---

### NET-029 — rsync

**`rsync`** is more efficient for large transfers.

**Basic sync:**
```bash copy
rsync -avz source/ username@hostname:/destination/
```

**Flags:**
- `-a` archive mode (preserves permissions, timestamps)
- `-v` verbose
- `-z` compress during transfer

**Dry run (preview):**
```bash copy
rsync -avz --dry-run source/ username@hostname:/destination/
```

**Delete files not in source:**
```bash copy
rsync -avz --delete source/ username@hostname:/destination/
```

**Exclude files:**
```bash copy
rsync -avz --exclude='*.log' source/ username@hostname:/destination/
```

**Show progress:**
```bash copy
rsync -avz --progress source/ username@hostname:/destination/
```

**Why rsync over scp:**
- Only transfers changed files
- Resumable
- More options (exclude, delete, etc.)

</div>

</details>

---

<details>
<summary><strong>15. Network Troubleshooting Methodology</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### NET-030 — Systematic Approach

**Layer-by-layer troubleshooting:**

**1. Physical/Link Layer:**
```bash copy
ip link show
# Is interface up? (state UP)
```

**2. Network Layer (IP):**
```bash copy
ip addr show
# Does interface have IP?

ping 127.0.0.1
# Can you reach yourself?

ping [gateway IP]
# Can you reach your gateway?

ping 8.8.8.8
# Can you reach internet?
```

**3. DNS:**
```bash copy
ping google.com
# Does DNS resolve?

dig google.com
# Check DNS resolution
```

**4. Transport/Application Layer:**
```bash copy
telnet example.com 80
# Can you reach specific port?

curl http://example.com
# Does application respond?
```

---

### NET-031 — Common Diagnostics Checklist

**Can't reach a service:**

1. **Check if service is running:**
```bash copy
systemctl status nginx
```

2. **Check if port is listening:**
```bash copy
sudo ss -tulnp | grep :80
```

3. **Check firewall:**
```bash copy
sudo ufw status
sudo firewall-cmd --list-all
```

4. **Check from localhost:**
```bash copy
curl http://localhost:80
```

5. **Check from remote:**
```bash copy
curl http://[server-ip]:80
```

6. **Check logs:**
```bash copy
sudo journalctl -u nginx -f
```

</div>

</details>

---

<details>
<summary><strong>16. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Can't SSH to Server

**Symptom:**
`ssh user@server` times out or refuses connection.

**Cause:**
SSH service down, firewall blocking, or network issue.

**Fix:**
```bash copy
# Test if port 22 is reachable
nc -zv server 22

# If timeout, check firewall on server
sudo ufw allow 22
# OR
sudo firewall-cmd --permanent --add-service=ssh
sudo firewall-cmd --reload

# Check if SSH service running
systemctl status sshd
sudo systemctl start sshd
sudo systemctl enable sshd
```

**Confirm:**
```bash copy
ssh user@server
# Successfully connected
```

---

### Scenario 2: Website Not Accessible

**Symptom:**
Can't reach website at http://example.com

**Cause:**
DNS issue, web server down, or firewall blocking.

**Fix:**
```bash copy
# Test DNS resolution
dig example.com
ping example.com

# If DNS fails, try IP directly
curl http://[IP_ADDRESS]

# Check if web server running
systemctl status nginx

# Check if port 80 open
sudo ss -tulnp | grep :80

# Check firewall
sudo ufw status
sudo ufw allow 80
sudo ufw allow 443

# Test locally
curl http://localhost
```

**Confirm:**
```bash copy
curl http://example.com
# Returns website content
```

---

### Scenario 3: Slow Network Performance

**Symptom:**
Network connections are slow.

**Cause:**
High latency or packet loss.

**Fix:**
```bash copy
# Check ping times
ping -c 10 google.com

# Trace route to find where delay occurs
traceroute google.com

# Check for packet loss
ping -c 100 google.com | grep loss
```

**Confirm:**
Identify bottleneck hop, contact network admin if needed.

---

### Scenario 4: DNS Not Resolving

**Symptom:**
`ping google.com` fails but `ping 8.8.8.8` works.

**Cause:**
DNS configuration issue.

**Fix:**
```bash copy
# Check DNS servers
cat /etc/resolv.conf

# Test specific DNS server
dig @8.8.8.8 google.com

# If needed, add Google DNS
echo "nameserver 8.8.8.8" | sudo tee -a /etc/resolv.conf
```

**Confirm:**
```bash copy
ping google.com
# Successfully resolves and responds
```

---

### Scenario 5: Port Already in Use

**Symptom:**
Starting service fails: "Address already in use"

**Cause:**
Another process using the port.

**Fix:**
```bash copy
# Find what's using port 80
sudo ss -tulnp | grep :80
# OR
sudo lsof -i :80

# Kill the process
sudo kill [PID]

# Or stop the conflicting service
sudo systemctl stop apache2
```

**Confirm:**
```bash copy
sudo systemctl start nginx
systemctl status nginx
# Service started successfully
```

---

### Scenario 6: Can't Transfer Files

**Symptom:**
`scp file.txt user@server:/path/` fails.

**Cause:**
SSH issue, permission problem, or disk full.

**Fix:**
```bash copy
# Test SSH connection
ssh user@server

# Check disk space on remote
ssh user@server 'df -h'

# Check permissions on destination
ssh user@server 'ls -ld /path/'

# Try with verbose flag
scp -v file.txt user@server:/path/
```

**Confirm:**
```bash copy
scp file.txt user@server:/path/
# Transfer successful
```

</div>

</details>

---

<details>
<summary><strong>17. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Network Configuration:**

```bash copy
ip addr show   # show IP addresses
```

```bash copy
ip link show   # show network interfaces
```

```bash copy
ip route show   # show routing table
```

```bash copy
ifconfig   # legacy interface config
```

**DNS:**

```bash copy
dig google.com   # DNS lookup
```

```bash copy
dig +short google.com   # short answer
```

```bash copy
dig -x 8.8.8.8   # reverse lookup
```

```bash copy
nslookup google.com   # DNS lookup (legacy)
```

```bash copy
host google.com   # simple DNS lookup
```

```bash copy
cat /etc/hosts   # view hosts file
```

```bash copy
cat /etc/resolv.conf   # view DNS config
```

**Connectivity:**

```bash copy
ping google.com   # test reachability
```

```bash copy
ping -c 4 google.com   # send 4 packets
```

```bash copy
traceroute google.com   # trace route
```

```bash copy
tracepath google.com   # alternative tracer
```

**Ports:**

```bash copy
nmap 192.168.1.100   # scan for open ports
```

```bash copy
nmap -p 80,443,22 192.168.1.100   # scan specific ports
```

```bash copy
telnet google.com 80   # test port connectivity
```

```bash copy
nc -zv google.com 80   # test port with netcat
```

**Socket Statistics:**

```bash copy
ss -tuln   # show listening sockets
```

```bash copy
ss -tulnp   # show with process names
```

```bash copy
ss -tun state established   # established connections
```

```bash copy
netstat -tuln   # legacy socket stats
```

```bash copy
sudo lsof -i :80   # what's using port 80
```

```bash copy
sudo lsof -i tcp   # all TCP connections
```

**Downloads:**

```bash copy
wget https://example.com/file.zip   # download file
```

```bash copy
wget -O name.zip https://example.com/file.zip   # save as
```

```bash copy
wget -c https://example.com/file.iso   # resume download
```

```bash copy
curl -O https://example.com/file.zip   # download with curl
```

```bash copy
curl -o name.zip https://example.com/file.zip   # save as
```

```bash copy
curl -I https://example.com   # show headers only
```

```bash copy
curl -L https://example.com   # follow redirects
```

**HTTP Testing:**

```bash copy
curl http://example.com   # GET request
```

```bash copy
curl -X POST -d "key=value" http://api.example.com   # POST
```

```bash copy
curl -H "Authorization: Bearer TOKEN" http://api.example.com   # with header
```

```bash copy
curl -o /dev/null -s -w "%{http_code}\n" http://example.com   # status code
```

**Firewall (ufw):**

```bash copy
sudo ufw status   # check firewall status
```

```bash copy
sudo ufw enable   # enable firewall
```

```bash copy
sudo ufw allow 80   # allow port
```

```bash copy
sudo ufw allow ssh   # allow service
```

```bash copy
sudo ufw deny 8080   # deny port
```

```bash copy
sudo ufw delete allow 80   # remove rule
```

**Firewall (firewalld):**

```bash copy
sudo firewall-cmd --state   # check status
```

```bash copy
sudo firewall-cmd --list-all   # list rules
```

```bash copy
sudo firewall-cmd --permanent --add-service=http   # allow service
```

```bash copy
sudo firewall-cmd --permanent --add-port=8080/tcp   # allow port
```

```bash copy
sudo firewall-cmd --reload   # apply changes
```

**SSH:**

```bash copy
ssh user@hostname   # connect to server
```

```bash copy
ssh -p 2222 user@hostname   # specify port
```

```bash copy
ssh -i ~/.ssh/key user@hostname   # use specific key
```

```bash copy
ssh user@hostname 'command'   # execute remote command
```

```bash copy
ssh-keygen -t rsa -b 4096   # generate SSH key
```

```bash copy
ssh-copy-id user@hostname   # copy key to server
```

**File Transfer:**

```bash copy
scp file.txt user@host:/path/   # copy to remote
```

```bash copy
scp user@host:/remote/file.txt /local/path/   # copy from remote
```

```bash copy
scp -r directory/ user@host:/path/   # copy directory
```

```bash copy
rsync -avz source/ user@host:/dest/   # sync with rsync
```

```bash copy
rsync -avz --progress source/ user@host:/dest/   # with progress
```

```bash copy
rsync -avz --delete source/ user@host:/dest/   # delete extra files
```

</div>

</details>

---

<details>
<summary><strong>18. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- IP addresses identify devices on networks
- DNS translates domain names to IP addresses
- Ports identify specific services on a host
- Always test connectivity layer by layer (link → IP → DNS → application)
- Firewalls control which ports are accessible
- SSH provides secure remote access
- Use `ping` to test basic connectivity, `traceroute` to find where failures occur
- `ss` and `lsof` show what's using network ports

**Private IP Ranges:**

| Range | CIDR | Addresses |
|-------|------|-----------|
| 10.0.0.0 - 10.255.255.255 | 10.0.0.0/8 | 16,777,216 |
| 172.16.0.0 - 172.31.255.255 | 172.16.0.0/12 | 1,048,576 |
| 192.168.0.0 - 192.168.255.255 | 192.168.0.0/16 | 65,536 |

**Special IP Addresses:**

| Address | Meaning |
|---------|---------|
| 127.0.0.1 | Localhost (loopback) |
| 0.0.0.0 | All addresses / any |
| 255.255.255.255 | Broadcast |

**Common Ports:**

| Port | Service | Protocol |
|------|---------|----------|
| 20/21 | FTP | TCP |
| 22 | SSH | TCP |
| 25 | SMTP | TCP |
| 53 | DNS | UDP/TCP |
| 80 | HTTP | TCP |
| 443 | HTTPS | TCP |
| 3306 | MySQL | TCP |
| 5432 | PostgreSQL | TCP |
| 6379 | Redis | TCP |
| 8080 | HTTP (alt) | TCP |
| 27017 | MongoDB | TCP |

**Network Troubleshooting Flow:**

```
1. Check Interface:        ip link show
2. Check IP Address:       ip addr show
3. Ping Localhost:         ping 127.0.0.1
4. Ping Gateway:           ping [gateway-ip]
5. Ping External IP:       ping 8.8.8.8
6. Test DNS:               ping google.com
7. Check Service:          systemctl status service
8. Check Port Listening:   ss -tulnp | grep :port
9. Check Firewall:         ufw status / firewall-cmd --list-all
10. Check Logs:            journalctl -u service
```

**DNS Commands Comparison:**

| Task | dig | nslookup | host |
|------|-----|----------|------|
| Basic lookup | `dig google.com` | `nslookup google.com` | `host google.com` |
| Short answer | `dig +short google.com` | N/A | `host google.com` |
| Reverse lookup | `dig -x 8.8.8.8` | `nslookup 8.8.8.8` | `host 8.8.8.8` |
| Specific server | `dig @8.8.8.8 google.com` | `nslookup google.com 8.8.8.8` | N/A |

**Port Scanning Tools:**

| Tool | Purpose | Example |
|------|---------|---------|
| `nmap` | Comprehensive port scanner | `nmap -p 80,443 192.168.1.100` |
| `telnet` | Simple port test | `telnet google.com 80` |
| `nc` | Swiss army knife | `nc -zv google.com 80` |
| `ss` | Socket statistics | `ss -tuln` |
| `lsof` | What's using port | `sudo lsof -i :80` |

**ss Command Options:**

| Option | Meaning |
|--------|---------|
| `-t` | TCP sockets |
| `-u` | UDP sockets |
| `-l` | Listening sockets |
| `-n` | Numeric (don't resolve names) |
| `-p` | Show process |

**Common ss Patterns:**

| Command | Purpose |
|---------|---------|
| `ss -tuln` | All listening TCP/UDP ports |
| `ss -tulnp` | With process names |
| `ss -tun state established` | Established connections |
| `ss -tulnp \| grep :80` | What's on port 80 |

**curl vs wget:**

| Feature | curl | wget |
|---------|------|------|
| Basic download | `curl -O url` | `wget url` |
| Save as | `curl -o name url` | `wget -O name url` |
| Resume | Not built-in | `wget -c url` |
| Recursive | Limited | `wget -r url` |
| HTTP POST | `curl -X POST -d data url` | Complex |
| Headers | `curl -I url` | `wget --server-response url` |
| Best for | APIs, testing, scripting | Downloading files, mirrors |

**Firewall Comparison:**

| Task | ufw (Ubuntu/Debian) | firewalld (RHEL/Fedora) |
|------|---------------------|-------------------------|
| Check status | `ufw status` | `firewall-cmd --state` |
| Enable | `ufw enable` | `systemctl start firewalld` |
| Allow port | `ufw allow 80` | `firewall-cmd --add-port=80/tcp --permanent` |
| Allow service | `ufw allow http` | `firewall-cmd --add-service=http --permanent` |
| List rules | `ufw status` | `firewall-cmd --list-all` |
| Reload | Automatic | `firewall-cmd --reload` |

**SSH Quick Reference:**

| Task | Command |
|------|---------|
| Connect | `ssh user@host` |
| With specific key | `ssh -i ~/.ssh/key user@host` |
| Specify port | `ssh -p 2222 user@host` |
| Generate key | `ssh-keygen -t rsa -b 4096` |
| Copy key to server | `ssh-copy-id user@host` |
| Execute remote command | `ssh user@host 'command'` |
| Config file | `~/.ssh/config` |

**File Transfer Comparison:**

| Feature | scp | rsync |
|---------|-----|-------|
| Copy to remote | `scp file user@host:/path/` | `rsync -avz file user@host:/path/` |
| Copy from remote | `scp user@host:/file /local/` | `rsync -avz user@host:/file /local/` |
| Recursive | `scp -r dir/ user@host:/path/` | `rsync -avz dir/ user@host:/path/` |
| Resume | No | Yes |
| Only changed files | No | Yes |
| Delete extra files | No | `rsync --delete` |
| Dry run | No | `rsync --dry-run` |
| Best for | One-time copies | Sync, large transfers, backups |

**Network Diagnostics Checklist:**

| Problem | First Check | Tool |
|---------|-------------|------|
| Can't reach host | Connectivity | `ping host` |
| Slow connection | Latency | `ping host` / `traceroute host` |
| DNS not working | Resolution | `dig domain` |
| Port not accessible | Port status | `telnet host port` / `nc -zv host port` |
| Service not listening | Socket status | `ss -tulnp \| grep port` |
| Blocked by firewall | Firewall rules | `ufw status` / `firewall-cmd --list-all` |
| SSH fails | SSH service | `systemctl status sshd` |

**What's Next:**
Now that you understand networking basics, the next file covers systemd services — managing background services, enabling auto-start, and reading service logs.

</div>

</details>

---
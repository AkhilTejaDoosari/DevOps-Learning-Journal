# **01. Linux Foundations — How Your Server Actually Works**
> From power button to login: understanding the system that runs 90% of the internet

---

## What We'll Cover

- [1. Why This Matters (And Why It's Easier Than You Think)](#1-why-this-matters)
- [2. The Big Picture: Linux in 5 Minutes](#2-the-big-picture)
- [3. Boot Up: What Happens When You Turn It On](#3-boot-up-what-happens)
- [4. systemd: Your Service Manager (It's Actually Simple)](#4-systemd-your-service-manager)
- [5. Files, Directories, and Where Everything Lives](#5-files-and-directories)
- [6. When Things Break: Real Fixes That Work](#6-when-things-break)
- [7. Quick Command Reference](#7-quick-command-reference)

---

<details>
<summary><strong>1. Why This Matters (And Why It's Easier Than You Think)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Here's the Truth

You don't need to be a Linux wizard. You just need to understand how the pieces fit together.

Think about it: every time you SSH into a server, launch an EC2 instance, or deploy a Docker container—you're using Linux. And once you get the mental model, everything clicks.

---

## The 3 AM Scenario

Your production app goes down. You SSH in. Services aren't running. Logs aren't obvious. 

**Right now, you might:**
- Google random commands
- Try things hoping they work
- Escalate because you're not sure what's wrong

**After this guide:**
- "Okay, let me check if the service started during boot"
- "Let me see what systemd is telling me"
- "Ah, the database wasn't ready when my app started—easy fix"

**That confidence? That's what we're building.**

---

## Why Linux Runs Everything

Look at your infrastructure:

```
AWS EC2 instances        → Linux
Docker containers        → Linux kernel features  
Kubernetes nodes         → Linux
CI/CD runners            → Linux
Database servers         → Linux
```

**One OS. Everywhere.**

Learn it once, use it for your entire career.

---

## What Makes This Different

Most Linux tutorials dump commands at you. This guide shows you **how the system thinks**.

You'll understand:
- What actually happens when you press the power button
- How services start (and why they sometimes don't)
- Where to look when things break
- How to fix it instead of reinstalling

**By the end, you'll feel like: "Yeah, I got this."**

</div>

</details>

---

<details>
<summary><strong>2. The Big Picture: Linux in 5 Minutes</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Linux is Just Layers

Seriously, that's it. Everything in Linux is just layers talking to each other.

```
You (typing commands)
     ↓
Shell (interprets what you typed)
     ↓
Programs (do the actual work)
     ↓
Kernel (talks to hardware)
     ↓
Hardware (CPU, disk, network)
```

**Example: When you type `ls`**

1. Your terminal catches the keystrokes
2. Shell says "oh, `ls` is in `/usr/bin/ls`, let me run that"
3. The `ls` program asks the kernel "hey, what files are in this directory?"
4. Kernel reads the disk and returns the list
5. Results flow back up to your screen

**That's it. That's how everything works.**

---

## The Three Parts of Linux

### The Kernel

This is the only part that's actually "Linux." It's the core that:
- Manages your CPU, RAM, and disk
- Runs your programs
- Handles hardware

**You rarely interact with it directly.** It just works in the background.

---

### User Space

Everything else runs here:
- Your shell (bash, zsh)
- Programs (nginx, postgresql, your app)
- System tools (systemctl, grep, etc.)

**This is where you live.**

---

### The Distribution (Distro)

Just a pre-packaged system with all the tools you need.

| Distribution | Vibe | Where You See It |
|--------------|------|------------------|
| **Ubuntu/Debian** | Beginner-friendly | AWS, DigitalOcean, everywhere |
| **RHEL/CentOS/AlmaLinux** | Enterprise, stable | Corporate data centers |
| **Alpine** | Super minimal (5MB!) | Docker containers |
| **Arch** | Build-your-own | Power users, hobbyists |

**The kernel is the same. The packaging is different.**

---

## Why This Matters

When you `ssh` into an Ubuntu server and then a CentOS server, **the commands are the same**:
- `systemctl start nginx` works on both
- `/etc/` holds configs on both  
- `journalctl` shows logs on both

**Once you learn Linux, you know them all.**

---

## Command Execution: The Mental Model

Let's trace what actually happens:

```bash
$ sudo systemctl restart nginx
```

**Step by step:**

1. **You type it** → Terminal captures input
2. **Shell parses it** → "sudo means run with elevated privileges"
3. **Shell finds systemctl** → Looks in `/usr/bin/systemctl`
4. **sudo checks permissions** → "Does this user have sudo rights?"
5. **systemctl talks to systemd** → "Hey, restart nginx"
6. **systemd stops nginx** → Sends stop signal to the process
7. **systemd starts nginx** → Spawns new nginx process
8. **Output flows back** → Terminal shows you the result

**Once you see this flow, debugging becomes obvious:**
- Command not found? → Check PATH
- Permission denied? → Check sudo rights
- Service won't start? → Check systemd status

**No more mystery.**

</div>

</details>

---

<details>
<summary><strong>3. Boot Up: What Happens When You Turn It On</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## The Real Scenario

You update your server and reboot. 15 minutes later, it still shows "unreachable" in monitoring.

**Without understanding boot, you're stuck.** With it? You know exactly where to look.

---

## Boot Flow: The Simple Version

```
Press power button
     ↓
Firmware wakes up (BIOS/UEFI)
     ↓
Finds bootloader (GRUB)
     ↓
Loads kernel into memory
     ↓
Kernel starts systemd (PID 1)
     ↓
systemd starts all your services
     ↓
Login prompt appears
```

**That's it. Six steps.**

---

## Let's Go Deeper (But Keep It Simple)

### Step 1: Firmware (BIOS/UEFI)

When you power on:
- Firmware checks if RAM/CPU work (POST test)
- Looks for a bootable disk
- Hands off to the bootloader

**Modern systems use UEFI** (faster, supports big disks).

**You barely ever touch this.** Just know it exists.

---

### Step 2: GRUB (The Bootloader)

GRUB's job is simple: load the kernel.

**Important files:**
- `/boot/grub/grub.cfg` - Generated config (don't edit)
- `/etc/default/grub` - Settings you CAN edit
- `/boot/vmlinuz-*` - Kernel files

**When you see the GRUB menu** (press Shift during boot), you can:
- Choose an older kernel (saved your butt when updates break things)
- Boot into recovery mode
- Edit boot options

**Pro tip:** Always keep at least one old kernel installed. You'll thank yourself later.

---

### Step 3: The Kernel

Kernel wakes up and:
1. Loads device drivers
2. Mounts the root filesystem (`/`)
3. Starts systemd as PID 1

**Fun fact:** The kernel can't mount `/` without disk drivers, but disk drivers are stored on `/`. 

**Solution:** `initramfs` (a temporary mini-filesystem in RAM) contains the drivers needed to mount the real disk.

**Chicken-and-egg problem solved.**

---

### Step 4: systemd Takes Over

Once systemd starts, it:
- Reads all service files
- Figures out what needs to start
- Starts services in parallel (fast!)
- Reaches the target (multi-user for servers, graphical for desktops)

**Then you get a login prompt.**

---

## When Boot Fails: The Troubleshooting Mental Model

**Symptom:** Server won't boot after a kernel update.

**Where did it fail?**

```
✅ Firmware worked (or you'd see hardware errors)
✅ GRUB loaded (or you'd get "No bootable device")
❌ Kernel might be broken ← START HERE
```

**The fix:**
1. Boot into GRUB menu (hold Shift during boot)
2. Select "Advanced options"
3. Choose the previous kernel
4. Once booted, remove the broken kernel:
   ```bash
   sudo apt remove linux-image-5.15.0-91-generic
   ```

**See? Not scary. Just systematic.**

---

## Pro Tip: Keep Old Kernels

```bash
# Prevent auto-removal of working kernel
sudo apt-mark hold linux-image-$(uname -r)
```

**Why?** Updates sometimes break things. Having a fallback = peace of mind.

---


## Key Takeaway

systemd isn't complicated. It's just:
1. Write a service file (copy-paste a template)
2. Tell it when to start and what to run
3. Enable it
4. Forget about it (until you need to check logs)

**You got this.**

</div>


## Key Takeaway

Boot is **sequential**. Each step depends on the previous one.

**When something breaks:**
1. Figure out where it failed
2. Boot to the last working point (usually an older kernel)
3. Fix the issue
4. Reboot confidently

**You're not reinstalling. You're systematically diagnosing.**

</div>

</details>

---

<details>
<summary><strong>4. systemd: Your Service Manager (It's Actually Simple)</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## What systemd Actually Does

**One job:** Start and manage services.

That's it. Everything else is just features to make that job easier.

---

## The Problem It Solves

You deploy an app. It works when you start it manually:

```bash
$ ./myapp
Server started on port 8080
```

But you need it to:
- Start automatically on boot
- Restart if it crashes  
- Run as a specific user
- Have logs go to the right place

**Enter systemd.**

---

## Service Files: Just Config Files

A systemd service file is just a text file that describes your service.

**Example: `/etc/systemd/system/myapp.service`**

```ini
[Unit]
Description=My Application
After=network.target postgresql.service

[Service]
Type=simple
User=myapp
WorkingDirectory=/opt/myapp
ExecStart=/opt/myapp/bin/start.sh
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

**Let's break it down:**

- `After=network.target` → Start after network is up
- `After=postgresql.service` → Start after database is ready
- `User=myapp` → Run as this user (not root)
- `ExecStart=/opt/myapp/bin/start.sh` → This is your program
- `Restart=on-failure` → Auto-restart if it crashes
- `WantedBy=multi-user.target` → Start on boot

**That's the whole thing. Simple, right?**

---

## The Commands You Actually Need

```bash
# Start service now
sudo systemctl start myapp

# Stop service
sudo systemctl stop myapp

# Restart service
sudo systemctl restart myapp

# Check status
systemctl status myapp

# Enable auto-start at boot
sudo systemctl enable myapp

# Enable AND start now
sudo systemctl enable --now myapp

# View logs
sudo journalctl -u myapp

# Follow logs in real-time
sudo journalctl -u myapp -f
```

**These 8 commands handle 95% of your daily work.**

---

## Real Scenario: The Startup Race Condition

**The problem:**

Your app starts before PostgreSQL is ready.

```bash
sudo systemctl start myapp
# Crashes immediately
# Logs: "Connection refused: localhost:5432"
```

**Why?** systemd started them at the same time, but your app was faster.

---

**The fix:**

Edit your service file:

```ini
[Unit]
After=postgresql.service
Requires=postgresql.service
```

- `After=` → Wait for this service to start first
- `Requires=` → Fail if this service fails

**Reload and restart:**

```bash
sudo systemctl daemon-reload
sudo systemctl restart myapp
```

**Boom. Race condition solved.**

---

## When Services Fail: The Debug Process

```bash
$ sudo systemctl start myapp
Job for myapp.service failed. See "systemctl status myapp" for details.
```

**Don't panic. Follow the breadcrumbs:**

**Step 1: Check status**
```bash
systemctl status myapp
```

Look for:
- Exit code (1 = generic error, 203 = can't execute)
- Last few log lines

**Step 2: Check full logs**
```bash
sudo journalctl -u myapp -n 50
```

**Step 3: Test manually**
```bash
# Run as the service user
sudo -u myapp /opt/myapp/bin/start.sh
```

**Usually reveals:**
- Missing environment variables
- Permission issues
- Wrong working directory

**Step 4: Fix and retry**

---

## Common Exit Codes (Quick Reference)

| Code | Meaning | Typical Fix |
|------|---------|-------------|
| 1 | Generic error | Check logs for details |
| 126 | Not executable | `chmod +x /path/to/script` |
| 127 | Command not found | Fix path in ExecStart |
| 203 | Can't execute | File doesn't exist or no permission |

---

## Common Exit Codes (Quick Reference)

## Best Practices (The Stuff That Saves You Later)

### **1. Always Set Dependencies**

```ini
After=network.target database.service
Requires=database.service
```

**Prevents:** "Works on my machine" bugs

---

### **2. Add Restart Logic**

```ini
Restart=on-failure
RestartSec=5s
```

**Prevents:** Permanent downtime from transient errors

---

### **3. Run as Non-Root User**

```ini
User=myapp
Group=myapp
```

**Prevents:** Security nightmares

---

### **4. Set Resource Limits**

```ini
MemoryMax=1G
CPUQuota=50%
```

**Prevents:** One service eating all resources

---
</details>

---

<details>
<summary><strong>5. Files, Directories, and Where Everything Lives</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## The Unix Philosophy: Everything Is a File

Disks are files. Processes are files. Network connections are files.

**Why?** Simpler mental model. One set of commands works on everything.

---

## The Directory Structure (What Actually Matters)

```
/                          ← Root of everything
├── etc/                   ← All your config files
├── var/log/               ← All your logs (THIS IS GOLD)
├── home/                  ← User files
├── opt/                   ← Third-party apps (where you install your stuff)
├── tmp/                   ← Temporary files (gets wiped)
└── usr/bin/               ← Where programs live
```

**That's 90% of what you need to know.**

---

## The Directory Structure (What Actually Matters)

## The Directories You'll Actually Use

### **/etc — Configuration Central**

```
/etc/nginx/nginx.conf       ← nginx config
/etc/systemd/system/        ← Your service files
/etc/hosts                  ← Hostname mappings
/etc/fstab                  ← What disks mount where
/etc/ssh/sshd_config        ← SSH server config
```

**Golden rule:** Back up `/etc` before changing anything.

```bash
sudo tar -czf /backup/etc-$(date +%F).tar.gz /etc
```

---

### **/var/log — Where Answers Live**

```
/var/log/syslog            ← System log (Debian/Ubuntu)
/var/log/messages          ← System log (RHEL/CentOS)
/var/log/nginx/            ← Web server logs
/var/log/postgresql/       ← Database logs
```

**When debugging, start here.**

```bash
# Quick check for errors
sudo tail -f /var/log/syslog | grep -i error
```

---

### **/home — User Stuff**

```
/home/username/            ← Personal files
/home/username/.bashrc     ← Shell config
/home/username/.ssh/       ← SSH keys
```

---

### **/opt — Your Applications**

**Convention:** Install third-party apps here.

```
/opt/myapp/
├── bin/
├── config/
└── logs/
```

**Why?** Keeps your app separate from system files.

---

### **/tmp — Temporary Storage**

Gets **wiped on reboot**. Perfect for:
- Build artifacts
- Temporary downloads
- Scratch space

**Don't put anything important here.**

---

## Mounting: How Disks Work in Linux

**In Windows:** You have `C:\`, `D:\`, `E:\`

**In Linux:** Everything is under `/`. Disks "mount" to directories.

```
Physical disk: /dev/sdb1
         ↓ (mount)
Directory: /mnt/data
```

**Example:**

```bash
# Mount a disk
sudo mount /dev/sdb1 /mnt/data

# Now you can access it
cd /mnt/data
ls
```

---

### **Permanent Mounts: /etc/fstab**

**Problem:** Manual mounts disappear after reboot.

**Solution:** Add to `/etc/fstab`

```
/dev/sdb1    /mnt/data    ext4    defaults    0    2
```

**Better: Use UUIDs** (device names can change)

```bash
# Get UUID
sudo blkid /dev/sdb1
# Output: UUID="abc-123-def"

# Add to fstab
UUID=abc-123-def    /mnt/data    ext4    defaults    0    2
```

**Test before rebooting:**
```bash
sudo mount -a
```

**If it errors, fix it now instead of discovering a non-booting server later.**

---

## Real Scenario: Disk Is Full

**Alert:** `/var` at 98% capacity

**Investigation:**

```bash
# Check disk usage
df -h

# Find the biggest directories
sudo du -sh /var/* | sort -rh | head -5
```

**Common culprits:**

**1. Log files**
```bash
# Find large logs
sudo find /var/log -type f -size +100M

# Clean old logs
sudo journalctl --vacuum-time=7d
```

**2. Docker images**
```bash
docker system df
docker system prune -a
```

**3. Old packages**
```bash
sudo apt autoremove
sudo apt clean
```

---

## Best Practices

### **1. Monitor Disk Space**

```bash
# Set up alerts when >80%
df -h | awk '$5 > 80 {print $0}'
```

### **2. Separate Important Directories**

**Production servers should have separate partitions:**
- `/` (10-20GB)
- `/var` (large, for logs/databases)
- `/home` (separate user data)

**Why?** If logs fill up, they don't crash the root filesystem.

### **3. Use tmpfs for Temp Files**

```bash
# Add to /etc/fstab
tmpfs  /tmp  tmpfs  defaults,size=2G  0  0
```

**Benefits:**
- Fast (RAM-based)
- Auto-cleaned on reboot
- Can't execute binaries (security++)

---

## Key Takeaway

**You don't need to memorize the entire filesystem.**

Just remember:
- `/etc` = configs
- `/var/log` = logs  
- `/home` = user files
- `/opt` = your apps

**That covers 95% of your daily work.**

</div>

</details>

---

<details>
<summary><strong>6. When Things Break: Real Fixes That Work</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## The Philosophy

**You don't need to know everything.** You need to know where to look.

---

## Scenario 1: Server Won't Boot After Update

### **What happened:**

```bash
sudo apt upgrade -y
sudo reboot
```

**15 minutes later:** Still unreachable.

---

### **The fix:**

**Step 1:** Boot into older kernel
- Access server console (AWS Serial Console, or physical access)
- Reboot and press `Shift` to enter GRUB
- Select "Advanced options"
- Choose previous kernel

**Step 2:** Remove broken kernel

```bash
# List kernels
dpkg --list | grep linux-image

# Remove the new one
sudo apt remove linux-image-5.15.0-92-generic

# Verify default kernel
uname -r
```

**Step 3:** Reboot and confirm

---

### **Prevention:**

```bash
# Hold your current working kernel
sudo apt-mark hold linux-image-$(uname -r)
```

**Lesson:** Always keep at least one old kernel.

---

## Scenario 2: Service Won't Start

### **Symptom:**

```bash
$ sudo systemctl start myapp
Job for myapp.service failed.
```

---

### **The debug process:**

**Step 1: What's the error?**
```bash
systemctl status myapp
```

Look for exit code and last log lines.

**Step 2: Full logs**
```bash
sudo journalctl -u myapp -n 100
```

**Step 3: Test manually**
```bash
# Run as the service user
sudo -u myapp /opt/myapp/bin/start.sh
```

**This usually reveals:**
- Missing file
- Wrong permissions
- Missing environment variable

---

### **Common fixes:**

**Exit code 203 (can't execute):**
```bash
sudo chmod +x /opt/myapp/bin/start.sh
```

**Exit code 127 (command not found):**
- Check ExecStart path
- Verify file exists

**Exit code 1 (app crashed):**
- Check app logs
- Test with verbose mode

---

## Scenario 3: Port Already in Use

### **Symptom:**

```
Failed to bind to 0.0.0.0:8080: Address already in use
```

---

### **Find the culprit:**

```bash
sudo ss -tlnp | grep :8080
```

**Output:**
```
LISTEN  0  128  *:8080  users:(("nginx",pid=1234))
```

---

### **Solutions:**

**Option 1:** Stop the other service
```bash
sudo systemctl stop nginx
```

**Option 2:** Change your app's port
```bash
vi /etc/myapp/config.yaml
# Change port to 8081
```

**Option 3:** Kill the process (last resort)
```bash
sudo kill -9 1234
```

---

## Scenario 4: Permission Denied (But File Has Execute Permission)

### **Symptom:**

```bash
$ ./deploy.sh
Permission denied

$ ls -l deploy.sh
-rwxr-xr-x 1 user user 1234 deploy.sh
# ^^^ Has execute permission!
```

---

### **Hidden causes:**

**1. Mounted with noexec**
```bash
mount | grep /tmp
# tmpfs on /tmp (noexec)

# Move script elsewhere
cp deploy.sh /opt/
/opt/deploy.sh
```

**2. SELinux blocking it**
```bash
getenforce
# Output: Enforcing

# Temporary fix (testing)
sudo setenforce 0

# Permanent fix
sudo chcon -t bin_t ./deploy.sh
```

---

## Scenario 5: "It Works Manually But Not in systemd"

### **The problem:**

```bash
# Works fine
$ /opt/myapp/start.sh
Server started

# Fails in systemd
$ sudo systemctl start myapp
Main process exited, status=1/FAILURE
```

---

### **Why?**

systemd has a **minimal environment**. Your shell has `~/.bashrc`, PATH, environment variables.

---

### **The fix:**

Add to service file:

```ini
[Service]
Environment="PATH=/usr/local/bin:/usr/bin:/bin"
Environment="DATABASE_URL=postgresql://localhost/myapp"
WorkingDirectory=/opt/myapp
```

---

## The Troubleshooting Toolkit

**When something breaks, run these:**

```bash
# Service issues
systemctl status <service>
sudo journalctl -u <service> -n 100

# Boot issues
sudo journalctl -xb
dmesg | grep -i error

# Disk issues
df -h
sudo du -sh /var/* | sort -rh

# Network issues
ss -tlnp                # Listening ports
ping -c 3 google.com    # Connectivity

# Process issues
ps aux | grep <name>
top                     # Real-time monitoring
```

---

## Key Takeaway

**Debugging is just:**
1. Figure out where it failed
2. Look at the logs
3. Test manually
4. Fix the root cause

**No magic. No reinstalling. Just systematic thinking.**

**You got this.**

</div>

</details>

---

<details>
<summary><strong>7. Quick Command Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

## Boot and System

```bash copy
uname -r   # show current kernel version
```

```bash copy
uname -a   # show all system information
```

```bash copy
dmesg | less   # view kernel and boot messages
```

```bash copy
sudo journalctl -xb   # view boot logs with explanations
```

```bash copy
sudo journalctl -b 0   # current boot logs
```

```bash copy
sudo journalctl -b -1   # previous boot logs
```

```bash copy
uptime   # show system uptime
```

```bash copy
last reboot   # show reboot history
```

---

## systemd Service Management

```bash copy
sudo systemctl start nginx   # start service now
```

```bash copy
sudo systemctl stop nginx   # stop service
```

```bash copy
sudo systemctl restart nginx   # restart service
```

```bash copy
sudo systemctl reload nginx   # reload config without restart
```

```bash copy
systemctl status nginx   # check service status
```

```bash copy
sudo systemctl enable nginx   # enable auto-start at boot
```

```bash copy
sudo systemctl disable nginx   # disable auto-start
```

```bash copy
sudo systemctl enable --now nginx   # enable and start immediately
```

```bash copy
systemctl is-active nginx   # check if service is running
```

```bash copy
systemctl is-enabled nginx   # check if enabled at boot
```

```bash copy
systemctl list-units --type=service   # list all services
```

```bash copy
systemctl list-units --type=service --state=running   # list running services
```

```bash copy
systemctl list-units --type=service --state=failed   # list failed services
```

```bash copy
sudo systemctl daemon-reload   # reload systemd after editing unit files
```

---

## Logs (journalctl)

```bash copy
sudo journalctl -u nginx   # view service logs
```

```bash copy
sudo journalctl -u nginx -f   # follow logs in real-time
```

```bash copy
sudo journalctl -u nginx -n 50   # last 50 log lines
```

```bash copy
sudo journalctl -u nginx --since "2025-01-15 10:00:00"   # logs from specific time
```

```bash copy
sudo journalctl -p err   # show only errors
```

```bash copy
sudo journalctl --vacuum-time=7d   # delete logs older than 7 days
```

```bash copy
sudo journalctl --disk-usage   # show log disk usage
```

---

## systemd Targets

```bash copy
systemctl get-default   # check current default target
```

```bash copy
sudo systemctl set-default multi-user.target   # set CLI-only boot
```

```bash copy
sudo systemctl set-default graphical.target   # set GUI boot
```

```bash copy
sudo systemctl isolate multi-user.target   # switch to target immediately
```

```bash copy
systemctl list-units --type=target   # list all targets
```

---

## GRUB Bootloader

```bash copy
cat /etc/default/grub   # view GRUB settings
```

```bash copy
sudo update-grub   # regenerate GRUB config (Debian/Ubuntu)
```

```bash copy
sudo grub2-mkconfig -o /boot/grub2/grub.cfg   # regenerate GRUB (RHEL/CentOS)
```

```bash copy
ls /boot/vmlinuz-*   # list installed kernels
```

```bash copy
sudo grub-set-default 0   # set first kernel as default
```

```bash copy
sudo apt-mark hold linux-image-$(uname -r)   # prevent kernel removal
```

---

## Filesystem and Disk

```bash copy
df -h   # show disk usage (human-readable)
```

```bash copy
du -sh /var/log   # show directory size
```

```bash copy
sudo du -sh /var/* | sort -rh | head -10   # find largest directories
```

```bash copy
lsblk   # list block devices
```

```bash copy
sudo blkid   # show UUIDs of partitions
```

```bash copy
mount   # show mounted filesystems
```

```bash copy
sudo mount /dev/sdb1 /mnt/data   # mount filesystem
```

```bash copy
sudo umount /mnt/data   # unmount filesystem
```

```bash copy
sudo mount -a   # mount all from /etc/fstab
```

```bash copy
cat /etc/fstab   # view filesystem mount table
```

---

## Package Management (Debian/Ubuntu)

```bash copy
sudo apt update   # update package index
```

```bash copy
sudo apt upgrade   # upgrade installed packages
```

```bash copy
sudo apt full-upgrade   # upgrade with dependency handling
```

```bash copy
sudo apt install nginx   # install package
```

```bash copy
sudo apt remove nginx   # remove package (keep configs)
```

```bash copy
sudo apt purge nginx   # remove package and configs
```

```bash copy
sudo apt autoremove   # remove unused dependencies
```

```bash copy
sudo apt clean   # clear package cache
```

```bash copy
apt search nginx   # search for package
```

```bash copy
apt show nginx   # show package information
```

```bash copy
apt list --installed   # list installed packages
```

```bash copy
sudo apt-mark hold nginx   # prevent package upgrades
```

```bash copy
sudo apt-mark unhold nginx   # allow package upgrades
```

---

## Package Management (RHEL/CentOS/Fedora)

```bash copy
sudo dnf check-update   # check for available updates
```

```bash copy
sudo dnf upgrade   # upgrade packages
```

```bash copy
sudo dnf install nginx   # install package
```

```bash copy
sudo dnf remove nginx   # remove package
```

```bash copy
dnf search nginx   # search for package
```

```bash copy
dnf info nginx   # show package info
```

```bash copy
dnf list installed   # list installed packages
```

```bash copy
sudo dnf clean all   # clean cache
```

---

## Process Management

```bash copy
ps aux   # show all running processes
```

```bash copy
ps aux | grep nginx   # find specific process
```

```bash copy
top   # real-time process monitoring
```

```bash copy
htop   # improved process viewer (if installed)
```

```bash copy
pgrep nginx   # find process ID by name
```

```bash copy
kill 1234   # send SIGTERM to process
```

```bash copy
kill -9 1234   # force kill process (SIGKILL)
```

```bash copy
killall nginx   # kill all processes by name
```

---

## Network Troubleshooting

```bash copy
ss -tlnp   # show listening TCP ports
```

```bash copy
ss -tlnp | grep :80   # check specific port
```

```bash copy
ip addr   # show IP addresses
```

```bash copy
ip route   # show routing table
```

```bash copy
ping -c 3 google.com   # test connectivity
```

```bash copy
traceroute google.com   # trace network path
```

```bash copy
netstat -tulpn   # show listening ports (older systems)
```

```bash copy
lsof -i :8080   # show what's using a port
```

---

## System Control

```bash copy
sudo reboot   # restart system
```

```bash copy
sudo reboot now   # restart immediately
```

```bash copy
sudo shutdown -h now   # shutdown immediately
```

```bash copy
sudo shutdown -h +10   # shutdown in 10 minutes
```

```bash copy
sudo shutdown -c   # cancel scheduled shutdown
```

```bash copy
sudo poweroff   # power off system
```

---

## File Permissions

```bash copy
ls -l /path/to/file   # view file permissions
```

```bash copy
chmod +x script.sh   # make file executable
```

```bash copy
chmod 755 script.sh   # rwxr-xr-x permissions
```

```bash copy
chmod 644 file.txt   # rw-r--r-- permissions
```

```bash copy
sudo chown user:group file.txt   # change owner
```

```bash copy
sudo chown -R user:group /directory   # recursive ownership change
```

</div>

</details>

---
# **01. Linux Foundations — Understanding the OS from Power-On to Login**
> The calm, inside-out view of how Linux actually works.

---

## Table of Contents
- [1. Why Linux Matters in DevOps](#1-why-linux-matters-in-devops)
- [2. What Linux Solves](#2-what-linux-solves)
- [3. Linux Architecture: Layers Explained](#3-linux-architecture-layers-explained)
- [4. The Boot Process: Power to Login](#4-the-boot-process-power-to-login)
- [5. systemd and Service Management](#5-systemd-and-service-management)
- [6. Understanding Shells and Terminals](#6-understanding-shells-and-terminals)
- [7. Package Managers Overview](#7-package-managers-overview)
- [8. Filesystems and Storage](#8-filesystems-and-storage)
- [9. Troubleshooting Boot and Service Issues](#9-troubleshooting-boot-and-service-issues)
- [10. Commands Reference](#10-commands-reference)
- [11. Quick Reference](#11-quick-reference)

---

<details>
<summary><strong>1. Why Linux Matters in DevOps</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Most production servers run Linux.

Cloud instances? Linux.
Containers? Linux.
Kubernetes nodes? Linux.
CI/CD agents? Linux.

Understanding how Linux boots, runs, and manages services means you can:
- debug server failures faster
- provision infrastructure confidently
- automate deployments reliably
- troubleshoot production issues calmly

This isn't about memorizing commands.
It's about knowing how the system thinks.

</div>

</details>

---

<details>
<summary><strong>2. What Linux Solves</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Before Linux became the standard, server management was fragmented.

Different operating systems meant:
- inconsistent tooling
- vendor lock-in
- expensive licensing
- limited customization
- harder automation

**What Linux Fixed:**
- Open source → free to use and modify
- Consistent tooling → same commands across distros
- Stable and secure → battle-tested in production
- Automation-friendly → scriptable, predictable behavior
- Community-driven → massive ecosystem of packages and support

**Why This Matters Now:**
When you deploy infrastructure, you need consistency. Linux gives you one mental model that works across AWS, GCP, Azure, on-prem, and containers. Learn it once, use it everywhere.

</div>

</details>

---

<details>
<summary><strong>3. Linux Architecture: Layers Explained</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Think of Linux as concentric layers:

```
┌─────────────────────────────────────────┐
│        User (you, SSH, apps)            │
├─────────────────────────────────────────┤
│     Shell (bash, zsh, terminal)         │
├─────────────────────────────────────────┤
│   User Space (applications, services)   │
├─────────────────────────────────────────┤
│      Kernel (device drivers, core)      │
├─────────────────────────────────────────┤
│   Hardware (CPU, RAM, disk, network)    │
└─────────────────────────────────────────┘
```

**The Flow:**
1. You type a command in the shell
2. Shell passes it to user space programs
3. Programs request kernel services (file I/O, network, etc.)
4. Kernel talks to hardware
5. Results flow back up to you

**Example:**
When you run `ls`:
- Shell interprets the command
- `ls` program runs in user space
- Kernel reads directory entries from disk
- Results displayed in your terminal

This Inside-Out model explains everything in Linux.

---

### LX-001 — What Linux Actually Is

Linux isn't one thing — it's three things working together:

**The Kernel:**
The brain of the OS. It talks to hardware (CPU, RAM, disk, network) and manages processes, memory, and drivers.

**User Space:**
Where your programs live. Shells, browsers, databases, servers — everything you interact with runs here.

**Distributions (Distros):**
Pre-packaged Linux systems with different philosophies:
- **Ubuntu/Debian** → beginner-friendly, stable
- **RHEL/CentOS/AlmaLinux** → enterprise-focused
- **Fedora** → cutting-edge features
- **Arch** → minimal, build-your-own

Each distro uses the same Linux kernel but packages tools differently.

**Why This Matters:**
When you deploy on AWS, GCP, or Azure, you're choosing a distro. Understanding the kernel vs user space helps you debug issues that cross both layers.

</div>

</details>

---

<details>
<summary><strong>4. The Boot Process: Power to Login</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### LX-002 — Power ON & Firmware

When you power on a server:

1. **Firmware starts** (BIOS or UEFI)
2. **POST runs** (Power-On Self-Test) to check hardware
3. **Bootable disk found** → hands off to bootloader

**Firmware Types:**
- **BIOS** = Basic Input/Output System (legacy)
- **UEFI** = Unified Extensible Firmware Interface (modern)

UEFI is faster and supports larger disks.

---

### LX-003 — Disk Partitioning: MBR vs GPT

Your disk needs a partition table so the firmware knows where to find the bootloader.

| Feature          | MBR (Master Boot Record) | GPT (GUID Partition Table) |
|------------------|--------------------------|----------------------------|
| Max partitions   | 4 primary                | 128+ partitions            |
| Max disk size    | 2 TB                     | 9.4 ZB (essentially unlimited) |
| Firmware support | BIOS                     | UEFI (also BIOS-compatible) |
| Reliability      | Single point of failure  | Redundant headers          |

**Modern systems use GPT.**

---

### LX-004 — Bootloader (GRUB2)

**What is it?**
A tiny program that loads the kernel and initial ramdisk into memory.

**Tasks:**
- Show OS selection menu (if dual-boot)
- Load Linux kernel
- Load initramfs (temporary root filesystem)
- Hand off control to the kernel

**Main Files:**
- `/boot/grub2/` or `/boot/efi/EFI/`
- `/etc/default/grub` — user-editable settings
- `/etc/grub.d/` — config scripts
- `/boot/grub2/grub.cfg` — final generated config (don't edit directly)

---

### LX-005 — The Kernel

**Job:**
- Load device drivers
- Mount the real root filesystem (e.g., `/dev/sda1`)
- Start the first user-space process: `systemd` (PID 1)

**initramfs (Initial RAM Filesystem):**
- Temporary root with essential drivers
- Needed before the real `/` mount
- Contains drivers for disk controllers, filesystems, etc.

**Why initramfs?**
Your kernel can't mount `/` if the drivers for your disk aren't loaded yet. initramfs solves this chicken-and-egg problem.

</div>

</details>

---

<details>
<summary><strong>5. systemd and Service Management</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### LX-006 — systemd (First User-Space Process)

Once the kernel starts, it launches `systemd` as PID 1.

**systemd's Job:**
- Start all services (daemons)
- Manage logs (`journalctl`)
- Handle mounts, sockets, timers
- Manage boot targets (like old runlevels)

**Main Unit Types:**
- `.service` → start/stop daemons
- `.target` → boot states (multi-user, graphical, etc.)
- `.socket` → activate services on-demand
- `.mount` → filesystem mounts
- `.timer` → scheduled tasks (replaces cron)

systemd replaced the old SysV `init` system.

---

### LX-007 — Runlevels vs Targets

Old Linux used numbered runlevels. systemd uses targets.

| Old Runlevel | systemd Target       | Purpose                     |
|--------------|----------------------|-----------------------------|
| 0            | `poweroff.target`    | Shutdown                    |
| 1            | `rescue.target`      | Single-user mode (recovery) |
| 3            | `multi-user.target`  | CLI, no GUI                 |
| 5            | `graphical.target`   | Multi-user with GUI         |
| 6            | `reboot.target`      | Restart the system          |

**Checking Current Target:**
```bash copy
systemctl get-default
```

**Switching Target:**
```bash copy
sudo systemctl isolate multi-user.target
```

---

### LX-008 — Login Stage

Once systemd finishes starting services, you get:
- **CLI login** (for servers)
- **GUI login screen** (for desktops)

Then you're ready to use the system.

</div>

</details>

---

<details>
<summary><strong>6. Understanding Shells and Terminals</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### LX-009 — Shells vs Terminals

**Terminal:**
The window you type in. It's just an interface.

**Shell:**
The program that interprets your commands. Examples:
- `bash` (Bourne Again Shell) — default on most systems
- `zsh` (Z Shell) — modern, feature-rich
- `sh` (original Bourne Shell) — minimal, POSIX-compliant

**Relationship:**
Terminal displays text. Shell processes commands.

**Why This Matters:**
When you SSH into a server, the terminal is your local SSH client. The shell runs on the remote server.

</div>

</details>

---

<details>
<summary><strong>7. Package Managers Overview</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### LX-010 — Package Managers

Linux distros use package managers to install, update, and remove software.

| Distro Family       | Package Manager | Command Examples                |
|---------------------|-----------------|--------------------------------|
| Debian/Ubuntu       | `apt`           | `apt install nginx`             |
| RHEL/CentOS/Fedora  | `dnf` or `yum`  | `dnf install nginx`             |
| Arch                | `pacman`        | `pacman -S nginx`               |

**Why Package Managers Matter:**
They handle dependencies, updates, and security patches automatically.

**High-Level Concept:**
You don't compile from source (usually). Package managers fetch pre-built binaries and handle installation.

</div>

</details>

---

<details>
<summary><strong>8. Filesystems and Storage</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### LX-011 — Filesystems (High-Level)

Linux treats everything as a file: disks, devices, processes, sockets.

**Common Filesystem Types:**
- **ext4** → default for many distros, stable
- **xfs** → high-performance, good for large files
- **btrfs** → snapshots, compression (newer)

**Filesystem Hierarchy Standard (FHS):**
- `/` — root
- `/home` — user data
- `/etc` — system config files
- `/var` — logs, databases
- `/tmp` — temporary files
- `/boot` — kernel and bootloader files

**Mounting:**
Filesystems must be "mounted" to a directory to be accessible.

**Example:**
```bash copy
mount /dev/sdb1 /mnt/backup
```

</div>

</details>

---

<details>
<summary><strong>9. Troubleshooting Boot and Service Issues</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Server Won't Boot

**Symptom:**
EC2 instance stuck at boot, no SSH access.

**Cause:**
GRUB misconfiguration or kernel panic.

**Fix:**
1. Attach root volume to another instance
2. Mount it:
```bash copy
mount /dev/xvdf1 /mnt
```
3. Check GRUB config:
```bash copy
cat /mnt/boot/grub/grub.cfg
```
4. Regenerate if needed:
```bash copy
grub2-mkconfig -o /mnt/boot/grub/grub.cfg
```
5. Reattach and boot

**Confirm:**
Instance boots normally, SSH works.

---

### Scenario 2: Wrong systemd Target After Reboot

**Symptom:**
Server boots to GUI instead of CLI.

**Cause:**
Default target set to `graphical.target`.

**Fix:**
```bash copy
sudo systemctl set-default multi-user.target
sudo reboot
```

**Confirm:**
```bash copy
systemctl get-default
# Output: multi-user.target
```

---

### Scenario 3: Understanding Boot Logs

**Symptom:**
Service fails to start, need to know why.

**Cause:**
Missing dependency or misconfiguration.

**Fix:**
```bash copy
dmesg | less          # kernel messages
journalctl -xb        # boot logs with explanations
journalctl -u nginx   # specific service logs
```

**Confirm:**
Found error message, fixed config, restarted service.

</div>

</details>

---

<details>
<summary><strong>10. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
uname -r   # show current kernel version
```

```bash copy
dmesg | less   # view kernel and boot messages
```

```bash copy
systemctl get-default   # check current boot target
```

```bash copy
systemctl set-default multi-user.target   # change default boot target
```

```bash copy
systemctl list-units --type=service   # list all running services
```

```bash copy
ls /boot   # view kernel and bootloader files
```

```bash copy
cat /etc/default/grub   # view GRUB configuration
```

```bash copy
sudo update-grub   # regenerate GRUB config (Debian/Ubuntu)
```

```bash copy
sudo grub2-mkconfig -o /boot/grub2/grub.cfg   # regenerate GRUB config (RHEL/CentOS)
```

```bash copy
journalctl -xb   # view boot logs with explanations
```

```bash copy
journalctl -u <service>   # view logs for specific service
```

```bash copy
mount /dev/sdb1 /mnt/backup   # mount filesystem to directory
```

```bash copy
reboot   # restart the system
```

```bash copy
shutdown -h now   # shut down immediately
```

</div>

</details>

---

<details>
<summary><strong>11. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Linux = kernel + user space + distro packaging
- Boot flow: firmware → bootloader → kernel → initramfs → systemd → login
- systemd manages everything in user space (services, logs, mounts)
- Shells interpret commands, terminals display output
- Package managers handle software installation
- Everything in Linux is a file

**Disk Partitioning:**

| Feature          | MBR (Master Boot Record) | GPT (GUID Partition Table) |
|------------------|--------------------------|----------------------------|
| Max partitions   | 4 primary                | 128+ partitions            |
| Max disk size    | 2 TB                     | 9.4 ZB (essentially unlimited) |
| Firmware support | BIOS                     | UEFI (also BIOS-compatible) |
| Reliability      | Single point of failure  | Redundant headers          |

**Runlevels vs Targets:**

| Old Runlevel | systemd Target       | Purpose                     |
|--------------|----------------------|-----------------------------|
| 0            | `poweroff.target`    | Shutdown                    |
| 1            | `rescue.target`      | Single-user mode (recovery) |
| 3            | `multi-user.target`  | CLI, no GUI                 |
| 5            | `graphical.target`   | Multi-user with GUI         |
| 6            | `reboot.target`      | Restart the system          |

**systemd Unit Types:**
- `.service` → start/stop daemons
- `.target` → boot states (multi-user, graphical, etc.)
- `.socket` → activate services on-demand
- `.mount` → filesystem mounts
- `.timer` → scheduled tasks

**Filesystem Hierarchy (Key Directories):**
- `/` — root (top of tree)
- `/home` — user home directories
- `/etc` — system configuration files
- `/var` — variable data (logs, databases)
- `/tmp` — temporary files
- `/usr` — user programs and utilities
- `/boot` — kernel and bootloader files

**What's Next:**
Now that you understand the OS architecture, the next file covers shell and terminal basics — how commands actually work.

</div>

</details>

---
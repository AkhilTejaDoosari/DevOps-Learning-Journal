# **01. Bash Basics & Variables — Foundation of Shell Scripting**
> Understanding how Bash thinks from variables to execution.

---

## Table of Contents
- [1. Why Bash Scripting Matters](#1-why-bash-scripting-matters)
- [2. Understanding the Shell Environment](#2-understanding-the-shell-environment)
- [3. Creating and Running Scripts](#3-creating-and-running-scripts)
- [4. Variables: Assignment and Access](#4-variables-assignment-and-access)
- [5. Quoting: Single, Double, and None](#5-quoting-single-double-and-none)
- [6. Special Variables and Positional Parameters](#6-special-variables-and-positional-parameters)
- [7. Environment Variables](#7-environment-variables)
- [8. Parameter Expansion](#8-parameter-expansion)
- [9. String Operations](#9-string-operations)
- [10. Command Substitution](#10-command-substitution)
- [11. Arithmetic Operations](#11-arithmetic-operations)
- [12. Reading User Input](#12-reading-user-input)
- [13. Exit Status and Return Codes](#13-exit-status-and-return-codes)
- [14. Real-World Scenarios](#14-real-world-scenarios)
- [15. Commands Reference](#15-commands-reference)
- [16. Quick Reference](#16-quick-reference)

---

<details>
<summary><strong>1. Why Bash Scripting Matters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every automation task in DevOps starts with a script.

Deploying code? Bash script.
Managing servers? Bash script.
Processing logs? Bash script.
Running backups? Bash script.

Understanding Bash means:
- you can automate repetitive tasks
- you can write reliable deployment scripts
- you can debug production issues faster
- you can build CI/CD pipelines confidently

This isn't about memorizing syntax.
It's about understanding how the shell interprets commands, stores data, and executes programs — so you can write scripts that actually work.

</div>

</details>

---

<details>
<summary><strong>2. Understanding the Shell Environment</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

When you type commands in a terminal, you're interacting with a shell.

The shell is your interface to the operating system — it:
- interprets commands
- manages variables
- executes programs
- handles I/O redirection
- runs scripts

**Two Operating Modes:**
- **Interactive** → you type commands manually
- **Non-interactive** → scripts run automatically

Understanding this distinction helps you write scripts that behave correctly in both contexts.

---

### BASH-001 — What is Bash?

**Bash** (Bourne Again Shell) is the default shell on most Linux systems.

**Why Bash?**
- Pre-installed on virtually every Linux distribution
- Industry standard for automation
- Powerful scripting capabilities
- Massive ecosystem of tools and examples

**Other Shells:**
- `sh` → minimal POSIX shell
- `zsh` → feature-rich, default on macOS
- `fish` → beginner-friendly
- `dash` → lightweight, fast

For DevOps work, Bash is the standard.

---

### BASH-002 — Interactive vs Non-Interactive

**Interactive Shell:**
- You're typing commands manually
- Shell shows a prompt
- Shell loads profile and rc files
- History is saved

**Non-Interactive Shell:**
- Scripts run automatically
- No prompt displayed
- Different startup files loaded
- No history saved

**Why This Matters:**
Scripts that work interactively might fail non-interactively if they depend on shell settings or environment variables that aren't loaded.

</div>

</details>

---

<details>
<summary><strong>3. Creating and Running Scripts</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-003 — The Shebang Line

Every Bash script should start with a shebang:

```bash copy
#!/bin/bash
```

This tells the kernel which interpreter to use.

**Why It Matters:**
Without a shebang, the shell guesses the interpreter. This can cause scripts to fail in different environments.

**Alternative (Portable):**
```bash copy
#!/usr/bin/env bash
```

This finds Bash in the PATH, which is useful when Bash isn't in `/bin` (common on BSD systems).

---

### BASH-004 — Creating and Running Scripts

**Create a Script:**
```bash copy
cat > hello.sh << 'EOF'
#!/bin/bash
echo "Hello from Bash"
EOF
```

**Make It Executable:**
```bash copy
chmod +x hello.sh
```

**Run It:**
```bash copy
./hello.sh
```

**Why the `./` Prefix?**
Linux doesn't include `.` (current directory) in the PATH for security. You must explicitly specify `./` to run scripts in the current directory.

**Alternative Execution:**
```bash copy
bash hello.sh        # Works without execute permissions
bash < hello.sh      # Redirects script as input
```

---

### BASH-005 — Script Header Best Practices

Production scripts should have a header that documents purpose and usage:

```bash copy
#!/bin/bash
#
# deploy.sh - Deploy application to specified environment
#
# USAGE:
#   deploy.sh <environment> <version>
#
# EXAMPLES:
#   deploy.sh production v2.3.1
#   deploy.sh staging v2.3.0-rc1
#
# EXIT CODES:
#   0  Success
#   1  Invalid arguments
#   2  Deployment failed
#
# AUTHOR: DevOps Team
# DATE: 2024-11-19

set -euo pipefail  # Strict mode
```

This header makes scripts maintainable and self-documenting.

</div>

</details>

---

<details>
<summary><strong>4. Variables: Assignment and Access</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Variables store data that your scripts can manipulate.

---

### BASH-006 — Variable Assignment

**Basic Assignment:**
```bash copy
name="Alice"
count=42
version="3.14.2"
```

**Critical Rule:**
No spaces around the `=` sign.

```bash copy
# WRONG
name = "Alice"  # Error: command not found

# RIGHT
name="Alice"
```

**Why?**
Bash interprets `name = "Alice"` as running a command called `name` with arguments `=` and `"Alice"`.

---

### BASH-007 — Accessing Variables

```bash copy
name="DevOps Engineer"

# Simple access
echo $name

# With braces (explicit)
echo ${name}

# Quoted (safe)
echo "$name"

# Literal (no expansion)
echo '$name'
```

**Always Quote Variables:**
```bash copy
# Without quotes (breaks on spaces)
file="my document.txt"
rm $file              # Tries to remove "my" and "document.txt"

# With quotes (safe)
rm "$file"            # Removes "my document.txt"
```

---

### BASH-008 — Variable Naming Conventions

| Type | Convention | Example |
|------|------------|---------|
| Local variables | lowercase_with_underscores | `user_name="alice"` |
| Constants | UPPERCASE_WITH_UNDERSCORES | `readonly MAX_RETRIES=5` |
| Environment | UPPERCASE_WITH_UNDERSCORES | `export DATABASE_URL="..."` |

**Example:**
```bash copy
# Local variables
database_host="localhost"
backup_dir="/var/backups"

# Constants
readonly MAX_CONNECTIONS=100
readonly CONFIG_FILE="/etc/app/config.conf"

# Environment variables
export PATH="/usr/local/bin:$PATH"
export DATABASE_URL="postgresql://localhost/mydb"
```

---

### BASH-009 — Variable Scope

**Global Variables:**
Available throughout the script.

**Local Variables:**
Only available inside functions.

```bash copy
#!/bin/bash

# Global
global_var="I'm global"

function my_function() {
    # Local (only exists in function)
    local local_var="I'm local"
    echo "Inside: $local_var"
    echo "Inside: $global_var"
}

my_function
echo "Outside: $global_var"
echo "Outside: $local_var"  # Empty
```

**Best Practice:**
Always use `local` for variables inside functions to prevent accidental modification of global variables.

---

### BASH-010 — The Braces Syntax

Use `${}` when the variable name is followed by characters that could be part of the name:

```bash copy
# Without braces (ambiguous)
file=report
echo $file_backup.txt   # Looks for variable $file_backup

# With braces (explicit)
echo ${file}_backup.txt # report_backup.txt
```

**Example:**
```bash copy
environment="production"
echo "Deploying to ${environment}_cluster"  # production_cluster
echo "Config: ${environment}.conf"          # production.conf
```

---

### BASH-011 — Read-Only Variables (Constants)

```bash copy
# Using readonly
readonly MAX_RETRIES=5

# Using declare
declare -r API_ENDPOINT="https://api.example.com"

# Attempting to modify causes error
MAX_RETRIES=10  # Error: readonly variable
```

**When to Use:**
Configuration values that should never change during script execution.

</div>

</details>

---

<details>
<summary><strong>5. Quoting: Single, Double, and None</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Quoting controls how Bash interprets strings and variables.

---

### BASH-012 — Single Quotes (Literal)

Everything inside single quotes is literal — no expansion:

```bash copy
message='Hello $USER, today is $(date)'
echo $message  # Hello $USER, today is $(date)
```

**Use When:**
- You need literal strings
- Working with special characters
- Preventing any expansion

---

### BASH-013 — Double Quotes (Expansion)

Variables and command substitution are expanded:

```bash copy
message="Hello $USER, today is $(date)"
echo $message  # Hello alice, today is Tue Nov 19 10:30:00 UTC 2024
```

**Use When:**
- You need variable expansion
- Working with strings that contain variables
- Most common quoting method

---

### BASH-014 — No Quotes (Word Splitting)

Without quotes, word splitting and globbing occur:

```bash copy
# Word splitting
files="file1.txt file2.txt file3.txt"
rm $files  # Expands to: rm file1.txt file2.txt file3.txt

# Breaks with spaces
files="file with spaces.txt"
rm $files  # Tries to remove: "file" "with" "spaces.txt"
rm "$files"  # Correctly removes "file with spaces.txt"
```

---

### BASH-015 — Quoting Rules Summary

| Syntax | Expansion | Use Case |
|--------|-----------|----------|
| `'text'` | None (literal) | Strings with special chars |
| `"text"` | Variables, commands | Most string operations |
| No quotes | Word splitting, globbing | Rarely (when you want splitting) |

**Best Practice:**
Always quote variables unless you specifically need word splitting or globbing.

</div>

</details>

---

<details>
<summary><strong>6. Special Variables and Positional Parameters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Bash provides special variables that give you information about the script and its execution.

---

### BASH-016 — Positional Parameters

```bash copy
#!/bin/bash
# Script: deploy.sh
# Usage: ./deploy.sh production web-app v2.3.1

echo "Script name: $0"        # ./deploy.sh
echo "First argument: $1"     # production
echo "Second argument: $2"    # web-app
echo "Third argument: $3"     # v2.3.1
echo "All arguments: $@"      # production web-app v2.3.1
echo "Number of arguments: $#"  # 3
```

**$@ vs $\*:**
- `"$@"` → expands to separate quoted strings
- `"$*"` → expands to a single string

**Always use `"$@"`** when passing arguments to other commands.

---

### BASH-017 — Process Variables

```bash copy
#!/bin/bash

echo "Process ID: $$"           # Current script's PID
echo "Parent Process ID: $PPID" # Parent shell's PID
echo "Last background PID: $!"  # PID of last background job
echo "Exit status: $?"          # Exit status of last command
```

**Using Exit Status:**
```bash copy
grep "error" /var/log/app.log
if [ $? -eq 0 ]; then
    echo "Errors found"
fi

# Better: use command directly
if grep -q "error" /var/log/app.log; then
    echo "Errors found"
fi
```

---

### BASH-018 — Special Variables Summary

| Variable | Meaning |
|----------|---------|
| `$0` | Script name |
| `$1` - `$9` | Positional parameters |
| `${10}` - `${N}` | Positional parameters 10+ |
| `$#` | Number of arguments |
| `$@` | All arguments (separate) |
| `$*` | All arguments (single string) |
| `$?` | Last exit status |
| `$$` | Current process ID |
| `$!` | Last background PID |
| `$_` | Last argument of previous command |

</div>

</details>

---

<details>
<summary><strong>7. Environment Variables</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Environment variables are inherited by child processes and are the primary way to configure scripts.

---

### BASH-019 — Viewing Environment Variables

```bash copy
# Show all environment variables
env
printenv

# Show specific variable
echo $PATH
echo $HOME
echo $USER

# Show all variables (including shell variables)
set
```

---

### BASH-020 — Setting Environment Variables

```bash copy
# Set for current session only
DATABASE_URL="postgresql://localhost/mydb"

# Export to make available to child processes
export DATABASE_URL="postgresql://localhost/mydb"

# Set and export in one line
export API_KEY="secret_key_here"

# Set for single command
DATABASE_URL="postgresql://testhost/testdb" ./run_tests.sh
```

**Critical Difference:**
Variables without `export` are only available in the current shell. Child processes (scripts you call) won't see them.

---

### BASH-021 — Common Environment Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `HOME` | User's home directory | `/home/alice` |
| `USER` | Current username | `alice` |
| `PATH` | Command search path | `/usr/local/bin:/usr/bin:/bin` |
| `PWD` | Present working directory | `/var/www/html` |
| `OLDPWD` | Previous directory | `/home/alice` |
| `SHELL` | Current shell | `/bin/bash` |
| `HOSTNAME` | System hostname | `web-server-01` |
| `LANG` | System language/locale | `en_US.UTF-8` |

---

### BASH-022 — Configuration via Environment

**Script Example:**
```bash copy
#!/bin/bash
# backup.sh - Configurable via environment

# Defaults
DATABASE_HOST="${DATABASE_HOST:-localhost}"
DATABASE_PORT="${DATABASE_PORT:-5432}"
DATABASE_NAME="${DATABASE_NAME:-myapp}"
BACKUP_DIR="${BACKUP_DIR:-/var/backups}"
RETENTION_DAYS="${RETENTION_DAYS:-7}"

echo "Backing up: $DATABASE_NAME"
echo "Host: $DATABASE_HOST:$DATABASE_PORT"

# Create backup
backup_file="${BACKUP_DIR}/${DATABASE_NAME}_$(date +%Y%m%d_%H%M%S).sql"
pg_dump -h "$DATABASE_HOST" -p "$DATABASE_PORT" "$DATABASE_NAME" > "$backup_file"
gzip "$backup_file"

# Clean old backups
find "$BACKUP_DIR" -name "${DATABASE_NAME}_*.sql.gz" -mtime +$RETENTION_DAYS -delete
```

**Usage:**
```bash copy
# Development
export DATABASE_HOST="dev-db.local"
export DATABASE_NAME="myapp_dev"
./backup.sh

# Production
export DATABASE_HOST="prod-db-01.example.com"
export DATABASE_NAME="myapp_prod"
export RETENTION_DAYS=30
./backup.sh
```

</div>

</details>

---

<details>
<summary><strong>8. Parameter Expansion</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Bash provides powerful parameter expansion features for manipulating variables.

---

### BASH-023 — Default Values

```bash copy
# Use default if unset or empty
name=${USER:-"unknown"}
port=${PORT:-8080}

# Assign default if unset
port=${PORT:=8080}
```

**Difference:**
- `:-` provides default but doesn't assign
- `:=` provides default AND assigns to variable

**Example:**
```bash copy
#!/bin/bash
# Use defaults for optional configuration

REGISTRY="${REGISTRY:-docker.io}"
NAMESPACE="${NAMESPACE:-mycompany}"
REPLICAS="${REPLICAS:-3}"
TIMEOUT="${TIMEOUT:-300}"

echo "Registry: $REGISTRY"
echo "Replicas: $REPLICAS"
```

---

### BASH-024 — Error on Unset

```bash copy
# Exit with error if variable is unset
database=${DATABASE:?"DATABASE not configured"}
api_key=${API_KEY:?"API_KEY environment variable required"}
```

**Fail Fast Pattern:**
```bash copy
#!/bin/bash
# Require critical variables

: ${DATABASE_HOST:?"DATABASE_HOST not set"}
: ${DATABASE_NAME:?"DATABASE_NAME not set"}
: ${API_KEY:?"API_KEY not set"}

echo "Configuration verified"
```

---

### BASH-025 — Use Alternative Value

```bash copy
# Use alternative if variable IS set
echo "${defined_var+alternative}"

# Example: optional flags
verbose=${VERBOSE+"-v"}
docker run $verbose myapp:latest
```

---

### BASH-026 — Parameter Expansion Summary

| Syntax | Description | Example |
|--------|-------------|---------|
| `${var}` | Value of var | `${name}` → "Alice" |
| `${var:-default}` | Use default if unset/empty | `${port:-8080}` |
| `${var:=default}` | Assign default if unset/empty | `${port:=8080}` |
| `${var:?error}` | Error if unset/empty | `${req:?missing}` |
| `${var:+alternate}` | Use alternate if set | `${debug:+"-v"}` |

</div>

</details>

---

<details>
<summary><strong>9. String Operations</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Bash provides built-in string manipulation capabilities.

---

### BASH-027 — String Length

```bash copy
text="Hello DevOps"
echo ${#text}  # 11

# Validation
password="secret"
if [ ${#password} -lt 8 ]; then
    echo "Password too short"
fi
```

---

### BASH-028 — Substring Extraction

```bash copy
text="Hello DevOps World"

# Extract from position (0-indexed)
echo ${text:0:5}   # Hello
echo ${text:6:6}   # DevOps
echo ${text:13}    # World (from 13 to end)

# Negative offset (from end)
echo ${text: -5}   # World (note space before -)
echo ${text: -5:3} # Wor
```

**Use Case:**
```bash copy
# Parse log timestamp
log_line="2024-11-19 10:30:45 ERROR Database failed"
date=${log_line:0:10}        # 2024-11-19
time=${log_line:11:8}        # 10:30:45
level=${log_line:20:5}       # ERROR
```

---

### BASH-029 — Pattern Removal from Beginning

```bash copy
filename="report_2024_11_19.csv"

# Remove shortest match from beginning
echo ${filename#report_}      # 2024_11_19.csv
echo ${filename#*_}           # 2024_11_19.csv

# Remove longest match from beginning
echo ${filename##*_}          # 19.csv
```

---

### BASH-030 — Pattern Removal from End

```bash copy
filename="backup.tar.gz"

# Remove shortest match from end
echo ${filename%.*}           # backup.tar

# Remove longest match from end
echo ${filename%%.*}          # backup
```

**Memory Aid:**
- `#` = beginning (on keyboard)
- `%` = end (further on keyboard)
- Single = shortest match
- Double = longest match

---

### BASH-031 — Pattern Substitution

```bash copy
text="foo bar foo baz"

# Replace first occurrence
echo ${text/foo/qux}       # qux bar foo baz

# Replace all occurrences
echo ${text//foo/qux}      # qux bar qux baz

# Replace at beginning
path="/usr/local/bin"
echo ${path/#\/usr/\/opt}  # /opt/local/bin

# Replace at end
filename="report.txt"
echo ${filename/%txt/csv}  # report.csv
```

**Use Case:**
```bash copy
# Sanitize log file
log="User john@example.com logged in from 192.168.1.100"
sanitized=${log//[0-9][0-9]*.[0-9][0-9]*.[0-9][0-9]*.[0-9][0-9]*/XXX.XXX.XXX.XXX}
sanitized=${sanitized//*@*.com/user@domain.com}
echo "$sanitized"
# User user@domain.com logged in from XXX.XXX.XXX.XXX
```

---

### BASH-032 — Case Conversion (Bash 4+)

```bash copy
text="Hello DevOps"

# Lowercase
echo ${text,,}             # hello devops
echo ${text,}              # hello DevOps (first char)

# Uppercase
echo ${text^^}             # HELLO DEVOPS
echo ${text^}              # Hello DevOps (first char)
```

**Portable Alternative:**
```bash copy
# For older Bash versions
text="Hello DevOps"
echo "$text" | tr '[:upper:]' '[:lower:]'  # hello devops
echo "$text" | tr '[:lower:]' '[:upper:]'  # HELLO DEVOPS
```

---

### BASH-033 — File Path Manipulation

Common patterns for extracting filename components:

```bash copy
filepath="/var/www/html/app/index.php"

# Directory name
dirname=${filepath%/*}           # /var/www/html/app

# Filename
filename=${filepath##*/}         # index.php

# Basename (without extension)
basename=${filename%%.*}         # index

# Extension
extension=${filename#*.}         # php
```

**Multi-Extension Files:**
```bash copy
file="backup.tar.gz"

# Remove last extension
echo ${file%.*}     # backup.tar

# Remove all extensions
echo ${file%%.*}    # backup

# Get all extensions
echo ${file#*.}     # tar.gz
```

</div>

</details>

---

<details>
<summary><strong>10. Command Substitution</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Command substitution captures command output and assigns it to a variable.

---

### BASH-034 — Modern Syntax

```bash copy
# Modern (preferred)
current_date=$(date +%Y-%m-%d)
file_count=$(ls -1 | wc -l)
hostname=$(hostname)

# Old syntax (avoid)
current_date=`date +%Y-%m-%d`
```

**Why $() is Better:**
- More readable
- Nests properly
- Better escaping

---

### BASH-035 — Nested Command Substitution

```bash copy
# Get directory of symlink target
real_path=$(dirname $(readlink -f /usr/bin/python))

# Top memory consumer
top_process=$(ps aux | sort -k3 -r | head -1 | awk '{print $11}')
```

---

### BASH-036 — Dynamic Configuration

**Example:**
```bash copy
#!/bin/bash
# Gather system metrics

hostname=$(hostname)
ip_address=$(hostname -I | awk '{print $1}')
memory_total=$(free -m | awk 'NR==2 {print $2}')
memory_used=$(free -m | awk 'NR==2 {print $3}')
disk_usage=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')

# Send to monitoring
curl -X POST "https://monitor.example.com/api/metrics" \
  -H "Content-Type: application/json" \
  -d "{
    \"host\": \"$hostname\",
    \"ip\": \"$ip_address\",
    \"memory_total_mb\": $memory_total,
    \"memory_used_mb\": $memory_used,
    \"disk_usage_percent\": $disk_usage
  }"
```

</div>

</details>

---

<details>
<summary><strong>11. Arithmetic Operations</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Bash supports integer arithmetic through several methods.

---

### BASH-037 — Arithmetic Expansion

```bash copy
# Using $(( ))
result=$((5 + 3))         # 8
result=$((10 - 4))        # 6
result=$((6 * 7))         # 42
result=$((20 / 3))        # 6 (integer division)
result=$((20 % 3))        # 2 (modulo)

# With variables
a=10
b=3
sum=$((a + b))            # 13
product=$((a * b))        # 30

# Compound operations
result=$((a * 2 + b - 1)) # 22
```

---

### BASH-038 — Double Parentheses

```bash copy
# Using (( ))
((result = 5 + 3))        # result=8
((count++))               # Increment
((count += 10))           # Add 10

# In conditionals
if ((count > 10)); then
    echo "Count is greater than 10"
fi
```

**Difference:**
- `$((expression))` → returns value
- `((expression))` → executes operation

---

### BASH-039 — Integer Variables

```bash copy
# Declare as integer
declare -i count=0
count=count+1      # Automatic arithmetic
echo $count        # 1

# Without declare -i
regular=0
regular=regular+1
echo $regular      # regular+1 (string)
```

---

### BASH-040 — Arithmetic Operators

| Operator | Operation | Example |
|----------|-----------|---------|
| `+` | Addition | `$((5 + 3))` → 8 |
| `-` | Subtraction | `$((5 - 3))` → 2 |
| `*` | Multiplication | `$((5 * 3))` → 15 |
| `/` | Division | `$((10 / 3))` → 3 |
| `%` | Modulo | `$((10 % 3))` → 1 |
| `**` | Exponentiation | `$((2 ** 3))` → 8 |
| `++` | Increment | `((count++))` |
| `--` | Decrement | `((count--))` |
| `+=` | Add and assign | `((count += 5))` |

---

### BASH-041 — Floating Point Math

Bash doesn't support floating point natively. Use `bc` or `awk`:

**Using bc:**
```bash copy
# Basic calculation
result=$(echo "scale=2; 10 / 3" | bc)  # 3.33

# With variables
price=19.99
quantity=3
total=$(echo "scale=2; $price * $quantity" | bc)  # 59.97
```

**Using awk:**
```bash copy
# Simple calculation
result=$(awk "BEGIN {print 10 / 3}")  # 3.33333

# With variables
total=$(awk "BEGIN {print $price * $quantity}")
```

</div>

</details>

---

<details>
<summary><strong>12. Reading User Input</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

The `read` command captures user input and stores it in variables.

---

### BASH-042 — Basic Input

```bash copy
# Simple read
read name
echo "Hello, $name"

# With prompt
read -p "Enter your name: " name
echo "Hello, $name"
```

---

### BASH-043 — Silent Input (Passwords)

```bash copy
# Hide input
read -s -p "Enter password: " password
echo  # New line after hidden input
echo "Password length: ${#password}"
```

---

### BASH-044 — Input with Timeout

```bash copy
# Timeout after 10 seconds
if read -t 10 -p "Enter value (10s timeout): " value; then
    echo "You entered: $value"
else
    echo "Timeout or error"
fi
```

---

### BASH-045 — Input with Default

```bash copy
# Prompt with default
read -p "Enter port [8080]: " port
port=${port:-8080}
echo "Using port: $port"
```

---

### BASH-046 — Reading from Files

```bash copy
# Read file line by line
while IFS= read -r line; do
    echo "Line: $line"
done < /var/log/app.log
```

**Critical Flags:**
- `IFS=` → preserves leading/trailing whitespace
- `-r` → prevents backslash interpretation

**Always use both** for reliable file reading.

</div>

</details>

---

<details>
<summary><strong>13. Exit Status and Return Codes</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every command returns an exit status: 0 for success, non-zero for failure.

---

### BASH-047 — Checking Exit Status

```bash copy
# Check last command
grep "error" /var/log/app.log
if [ $? -eq 0 ]; then
    echo "Errors found"
fi

# Better: use command directly
if grep -q "error" /var/log/app.log; then
    echo "Errors found"
fi
```

---

### BASH-048 — Setting Exit Status

```bash copy
#!/bin/bash
# backup.sh

database="myapp"
backup_dir="/var/backups"

if pg_dump "$database" > "${backup_dir}/${database}.sql"; then
    echo "Backup completed"
    exit 0
else
    echo "Backup failed" >&2
    exit 1
fi
```

---

### BASH-049 — Exit Status Conventions

| Code | Meaning | When to Use |
|------|---------|-------------|
| 0 | Success | Command completed successfully |
| 1 | General error | Catchall for general errors |
| 2 | Misuse | Invalid arguments or syntax |
| 126 | Cannot execute | Permission problem |
| 127 | Command not found | Typo or PATH issue |
| 130 | Ctrl+C termination | User interrupt |
| 255 | Out of range | Invalid exit code |

---

### BASH-050 — Chain Commands by Status

```bash copy
# AND (&&) - run if previous succeeds
mkdir /tmp/test && cd /tmp/test && touch file.txt

# OR (||) - run if previous fails
command || echo "Command failed"

# Combined
mkdir /tmp/backup && cp file.txt /tmp/backup/ || echo "Backup failed"
```

</div>

</details>

---

<details>
<summary><strong>14. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Deployment Script with Arguments

```bash copy
#!/bin/bash
# deploy.sh - Deploy to specified environment

if [ $# -lt 2 ]; then
    echo "Usage: $0 <environment> <version>" >&2
    echo "Example: $0 production v2.3.1" >&2
    exit 1
fi

environment=$1
version=$2
deployment_id=$$

echo "Deployment ID: $deployment_id"
echo "Deploying $version to $environment..."

# Create deployment directory
deploy_dir="/var/deploys/${environment}/${version}-${deployment_id}"
mkdir -p "$deploy_dir"

# Log deployment
echo "$(date): Deployed $version to $environment (PID: $$)" >> /var/log/deployments.log

echo "Deployment completed"
```

---

### Scenario 2: Log File Processing

```bash copy
#!/bin/bash
# parse_logs.sh - Extract errors from logs

log_file="/var/log/app.log"
output_file="/tmp/errors_$(date +%Y%m%d_%H%M%S).txt"

# Check if log exists
if [ ! -f "$log_file" ]; then
    echo "Log file not found: $log_file" >&2
    exit 1
fi

# Extract errors
grep "ERROR" "$log_file" > "$output_file"

# Count and report
error_count=$(wc -l < "$output_file")
echo "Found $error_count errors"
echo "Output saved to: $output_file"

# Alert if threshold exceeded
if ((error_count > 100)); then
    echo "WARNING: Error count exceeds threshold!" >&2
    # Send alert
    mail -s "High Error Count" admin@example.com < "$output_file"
fi
```

---

### Scenario 3: Interactive Configuration

```bash copy
#!/bin/bash
# setup.sh - Interactive service configuration

echo "=== Service Configuration ==="
echo

# Service name (required)
while true; do
    read -p "Service name: " service_name
    if [ -n "$service_name" ]; then
        break
    fi
    echo "Service name is required"
done

# Environment selection
echo "Environment:"
echo "  1) Development"
echo "  2) Staging"
echo "  3) Production"
read -p "Select (1-3): " env_choice

case $env_choice in
    1) environment="development" ;;
    2) environment="staging" ;;
    3) environment="production" ;;
    *)
        echo "Invalid choice" >&2
        exit 1
        ;;
esac

# Port with default
read -p "Port [8080]: " port
port=${port:-8080}

# Database password
read -s -p "Database password: " db_password
echo

# Summary
echo
echo "=== Summary ==="
echo "Service: $service_name"
echo "Environment: $environment"
echo "Port: $port"
echo

read -p "Proceed? (yes/no): " confirm
if [ "$confirm" = "yes" ]; then
    echo "Deploying $service_name to $environment..."
    # Deployment logic here
else
    echo "Cancelled"
    exit 0
fi
```

---

### Scenario 4: Configuration File Processing

```bash copy
#!/bin/bash
# load_config.sh - Load key=value configuration

config_file="/etc/myapp/config.conf"

if [ ! -f "$config_file" ]; then
    echo "Config file not found: $config_file" >&2
    exit 1
fi

# Read and process
while IFS='=' read -r key value; do
    # Skip comments and empty lines
    [[ $key =~ ^#.*$ || -z $key ]] && continue
    
    # Remove whitespace
    key=$(echo "$key" | xargs)
    value=$(echo "$value" | xargs)
    
    # Export as environment variable
    export "$key"="$value"
    echo "Loaded: $key=$value"
done < "$config_file"

echo "Configuration loaded"
```

---

### Scenario 5: Disk Usage Monitoring

```bash copy
#!/bin/bash
# monitor_disk.sh - Alert on high disk usage

threshold=80
email="admin@example.com"

# Get disk usage
usage=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')

echo "Current disk usage: ${usage}%"

if ((usage >= threshold)); then
    # Calculate details
    overage=$((usage - threshold))
    total=$(df -BG / | awk 'NR==2 {print $2}' | sed 's/G//')
    used=$((total * usage / 100))
    free=$((total - used))
    needed=$((total * (usage - threshold) / 100))
    
    message="ALERT: Disk usage at ${usage}%
Overage: ${overage}%
Total: ${total}GB
Used: ${used}GB
Free: ${free}GB
Need to free: ~${needed}GB"
    
    echo "$message"
    echo "$message" | mail -s "Disk Space Alert" "$email"
else
    remaining=$((threshold - usage))
    echo "Disk usage OK (${remaining}% below threshold)"
fi
```

</div>

</details>

---

<details>
<summary><strong>15. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
# Variable assignment
name="value"
```

```bash copy
# Access variable
echo $name
echo "$name"
echo ${name}
```

```bash copy
# Export environment variable
export DATABASE_URL="postgresql://localhost/mydb"
```

```bash copy
# Show environment variables
env
printenv
```

```bash copy
# Read-only variable
readonly MAX_RETRIES=5
declare -r CONFIG="/etc/app/config"
```

```bash copy
# Integer variable
declare -i count=0
```

```bash copy
# Command substitution
current_date=$(date +%Y-%m-%d)
hostname=$(hostname)
```

```bash copy
# Arithmetic
result=$((5 + 3))
((count++))
```

```bash copy
# String length
echo ${#text}
```

```bash copy
# Substring
echo ${text:0:5}
```

```bash copy
# Pattern removal
echo ${filename#*.}      # extension
echo ${filename%.*}      # without extension
echo ${filepath##*/}     # basename
```

```bash copy
# Pattern substitution
echo ${text/old/new}     # replace first
echo ${text//old/new}    # replace all
```

```bash copy
# Default value
port=${PORT:-8080}
```

```bash copy
# Error if unset
: ${REQUIRED:?"Variable REQUIRED must be set"}
```

```bash copy
# Read user input
read -p "Enter name: " name
read -s -p "Enter password: " password
```

```bash copy
# Read file line by line
while IFS= read -r line; do
    echo "$line"
done < file.txt
```

```bash copy
# Check exit status
if [ $? -eq 0 ]; then
    echo "Success"
fi
```

```bash copy
# Chain commands
command1 && command2     # AND
command1 || command2     # OR
```

</div>

</details>

---

<details>
<summary><strong>16. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Variables store data; use `$` to access
- Always quote variables unless you need word splitting
- Use `${}` syntax when variable name needs explicit boundaries
- Environment variables are inherited by child processes
- Exit status 0 = success, non-zero = failure
- Command substitution captures output: `$(command)`

---

**Variable Naming:**

| Type | Convention | Example |
|------|------------|---------|
| Local | lowercase_with_underscores | `user_name="alice"` |
| Constants | UPPERCASE | `readonly MAX_RETRIES=5` |
| Environment | UPPERCASE | `export DATABASE_URL="..."` |

---

**Quoting Rules:**

| Syntax | Expansion | Use Case |
|--------|-----------|----------|
| `'text'` | None (literal) | Special chars, no expansion |
| `"text"` | Variables, commands | Most common case |
| No quotes | Word splitting | Rarely needed |

---

**Parameter Expansion:**

| Syntax | Description |
|--------|-------------|
| `${var}` | Value of var |
| `${var:-default}` | Use default if unset/empty |
| `${var:=default}` | Assign default if unset |
| `${var:?error}` | Error if unset |
| `${#var}` | String length |
| `${var:offset:length}` | Substring |
| `${var#pattern}` | Remove shortest prefix |
| `${var##pattern}` | Remove longest prefix |
| `${var%pattern}` | Remove shortest suffix |
| `${var%%pattern}` | Remove longest suffix |
| `${var/pat/rep}` | Replace first |
| `${var//pat/rep}` | Replace all |

---

**Special Variables:**

| Variable | Meaning |
|----------|---------|
| `$0` | Script name |
| `$1`, `$2`, ... | Positional parameters |
| `$#` | Number of arguments |
| `$@` | All arguments (separate) |
| `$?` | Last exit status |
| `$$` | Current PID |
| `$!` | Last background PID |

---

**Common Patterns:**

```bash copy
# File components
dirname=${filepath%/*}           # /path/to
filename=${filepath##*/}         # file.txt
basename=${filename%%.*}         # file
extension=${filename#*.}         # txt

# Defaults with validation
: ${REQUIRED:?"Must be set"}
OPTIONAL="${OPTIONAL:-default}"

# Safe iteration
while IFS= read -r line; do
    process "$line"
done < file.txt
```

---

**Exit Status Convention:**

| Code | Meaning |
|------|---------|
| 0 | Success |
| 1 | General error |
| 2 | Invalid usage |
| 126 | Cannot execute |
| 127 | Command not found |

---

**What's Next:**
Now that you understand variables and basic operations, the next file covers conditionals and logic — how to make decisions based on conditions and tests.

</div>

</details>

---
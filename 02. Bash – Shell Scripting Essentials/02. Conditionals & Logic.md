# **02. Conditionals & Logic — Making Decisions in Scripts**
> How to test conditions and control script flow.

---

## Table of Contents
- [1. Why Conditionals Matter](#1-why-conditionals-matter)
- [2. Understanding Test Commands](#2-understanding-test-commands)
- [3. The if Statement](#3-the-if-statement)
- [4. File Tests](#4-file-tests)
- [5. String Comparisons](#5-string-comparisons)
- [6. Numeric Comparisons](#6-numeric-comparisons)
- [7. Logical Operators](#7-logical-operators)
- [8. The case Statement](#8-the-case-statement)
- [9. Test Command Styles](#9-test-command-styles)
- [10. Exit Status in Conditionals](#10-exit-status-in-conditionals)
- [11. Complex Conditions](#11-complex-conditions)
- [12. Common Conditional Patterns](#12-common-conditional-patterns)
- [13. Real-World Scenarios](#13-real-world-scenarios)
- [14. Commands Reference](#14-commands-reference)
- [15. Quick Reference](#15-quick-reference)

---

<details>
<summary><strong>1. Why Conditionals Matter</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Every script needs to make decisions.

Does the file exist? Run this code.
Is the server responding? Continue deployment.
Did the backup succeed? Send notification.
Is disk space low? Alert administrators.

Understanding conditionals means:
- you can write scripts that handle different scenarios
- you can validate input before processing
- you can check prerequisites before operations
- you can handle errors gracefully

This isn't about memorizing syntax.
It's about understanding how Bash evaluates conditions — so you can write scripts that make intelligent decisions.

</div>

</details>

---

<details>
<summary><strong>2. Understanding Test Commands</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Conditionals work by evaluating test commands.

A test command returns:
- **Exit status 0** → condition is true
- **Exit status 1** → condition is false

This inverts normal thinking: 0 = success = true.

---

### BASH-051 — How Tests Work

```bash copy
# Using test command
test -f /etc/passwd
echo $?  # 0 (true - file exists)

test -f /nonexistent
echo $?  # 1 (false - file doesn't exist)
```

**The Flow:**
1. Test command evaluates condition
2. Returns exit status (0 or 1)
3. `if` statement checks the exit status
4. Executes appropriate code block

---

### BASH-052 — Three Ways to Test

```bash copy
# Old: test command
test -f file.txt

# Common: [ ] syntax
[ -f file.txt ]

# Modern: [[ ]] syntax (Bash-specific)
[[ -f file.txt ]]
```

All three do the same thing, but `[[ ]]` is more powerful and safer.

**Why [[ ]] is Better:**
- No word splitting or globbing
- Supports pattern matching
- Supports regex matching
- Better error handling
- Cleaner syntax for complex conditions

**Use [[ ]] for Bash scripts.**
**Use [ ] only for POSIX portability.**

</div>

</details>

---

<details>
<summary><strong>3. The if Statement</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-053 — Basic if Syntax

```bash copy
if [ condition ]; then
    # code if true
fi
```

**Key Points:**
- Semicolon before `then` (or put `then` on next line)
- Spaces around `[` and `]` are required
- Must end with `fi`

**Example:**
```bash copy
if [ -f /etc/passwd ]; then
    echo "Password file exists"
fi
```

---

### BASH-054 — if-else

```bash copy
if [ condition ]; then
    # code if true
else
    # code if false
fi
```

**Example:**
```bash copy
if [ -f backup.tar.gz ]; then
    echo "Backup exists"
else
    echo "No backup found"
fi
```

---

### BASH-055 — if-elif-else

```bash copy
if [ condition1 ]; then
    # code if condition1 true
elif [ condition2 ]; then
    # code if condition2 true
else
    # code if all false
fi
```

**Example:**
```bash copy
disk_usage=85

if [ $disk_usage -lt 70 ]; then
    echo "Disk usage OK"
elif [ $disk_usage -lt 90 ]; then
    echo "Disk usage WARNING"
else
    echo "Disk usage CRITICAL"
fi
```

---

### BASH-056 — One-Line if

```bash copy
# Short form
[ condition ] && command

# Example
[ -f config.txt ] && echo "Config found"

# With else
[ condition ] && command1 || command2

# Example
[ -f backup.tar.gz ] && echo "Backup exists" || echo "No backup"
```

**Caution with ||:**
If `command1` fails, `command2` runs even if condition was true.

```bash copy
# RISKY
[ -f file.txt ] && rm file.txt || echo "Delete failed"

# SAFE
if [ -f file.txt ]; then
    rm file.txt
else
    echo "File not found"
fi
```

</div>

</details>

---

<details>
<summary><strong>4. File Tests</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

File tests check file existence, type, and properties.

---

### BASH-057 — Existence Tests

```bash copy
# File exists (any type)
[ -e file.txt ]

# Regular file exists
[ -f file.txt ]

# Directory exists
[ -d /etc ]

# Symbolic link exists
[ -L /usr/bin/python ]

# File exists and not empty
[ -s file.txt ]
```

**Most Common:**
Use `-f` for files, `-d` for directories.

**Example:**
```bash copy
if [ ! -f /etc/nginx/nginx.conf ]; then
    echo "Nginx config not found" >&2
    exit 1
fi
```

---

### BASH-058 — Permission Tests

```bash copy
# Readable
[ -r file.txt ]

# Writable
[ -w file.txt ]

# Executable
[ -x script.sh ]

# Owned by current user
[ -O file.txt ]

# Owned by current group
[ -G file.txt ]
```

**Example:**
```bash copy
if [ ! -w /var/log ]; then
    echo "Cannot write to /var/log" >&2
    exit 2
fi
```

---

### BASH-059 — File Type Tests

```bash copy
# Block device
[ -b /dev/sda ]

# Character device
[ -c /dev/tty ]

# Named pipe (FIFO)
[ -p /tmp/mypipe ]

# Socket
[ -S /var/run/docker.sock ]
```

---

### BASH-060 — File Comparison

```bash copy
# file1 newer than file2
[ file1.txt -nt file2.txt ]

# file1 older than file2
[ file1.txt -ot file2.txt ]

# Same file (hard links)
[ file1.txt -ef file2.txt ]
```

**Example:**
```bash copy
if [ /etc/nginx/nginx.conf -nt /var/run/nginx.pid ]; then
    echo "Config changed, reloading nginx"
    systemctl reload nginx
fi
```

---

### BASH-061 — File Test Summary

| Test | True If |
|------|---------|
| `-e file` | File exists (any type) |
| `-f file` | Regular file exists |
| `-d file` | Directory exists |
| `-L file` | Symbolic link exists |
| `-s file` | File exists and not empty |
| `-r file` | File is readable |
| `-w file` | File is writable |
| `-x file` | File is executable |
| `-O file` | File owned by current user |
| `-G file` | File owned by current group |
| `f1 -nt f2` | File1 newer than file2 |
| `f1 -ot f2` | File1 older than file2 |

</div>

</details>

---

<details>
<summary><strong>5. String Comparisons</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-062 — String Equality

```bash copy
# Equal
[ "$str1" = "$str2" ]
[[ "$str1" == "$str2" ]]  # Bash-specific

# Not equal
[ "$str1" != "$str2" ]
```

**Always Quote Strings:**
```bash copy
# WRONG - breaks if var is empty
[ $var = "value" ]

# RIGHT - quotes protect empty values
[ "$var" = "value" ]
```

**Example:**
```bash copy
environment="production"

if [ "$environment" = "production" ]; then
    echo "Running in production mode"
    replicas=5
else
    replicas=1
fi
```

---

### BASH-063 — String Length Tests

```bash copy
# String is empty
[ -z "$str" ]

# String is not empty
[ -n "$str" ]

# Simple existence check
[ "$str" ]
```

**Example:**
```bash copy
read -p "Enter username: " username

if [ -z "$username" ]; then
    echo "Username cannot be empty" >&2
    exit 1
fi
```

---

### BASH-064 — Lexicographic Comparison

```bash copy
# Less than
[[ "$str1" < "$str2" ]]

# Greater than
[[ "$str1" > "$str2" ]]
```

**Note:** Use `[[ ]]` for `<` and `>`, not `[ ]`.

**Example:**
```bash copy
version="2.3.1"

if [[ "$version" > "2.0.0" ]]; then
    echo "Version is newer than 2.0.0"
fi
```

---

### BASH-065 — Pattern Matching (Bash-specific)

```bash copy
# Pattern match
[[ $filename == *.txt ]]

# Negated pattern
[[ $filename != *.log ]]

# Multiple patterns
[[ $filename == *.jpg || $filename == *.png ]]
```

**Example:**
```bash copy
for file in *; do
    if [[ $file == *.sh ]]; then
        echo "Shell script: $file"
        chmod +x "$file"
    fi
done
```

---

### BASH-066 — Regex Matching (Bash-specific)

```bash copy
# Regex match
[[ $string =~ pattern ]]
```

**Example:**
```bash copy
# Validate email
email="user@example.com"

if [[ $email =~ ^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$ ]]; then
    echo "Valid email"
else
    echo "Invalid email"
fi

# Extract version number
release="v2.3.1"
if [[ $release =~ v([0-9]+)\.([0-9]+)\.([0-9]+) ]]; then
    major=${BASH_REMATCH[1]}
    minor=${BASH_REMATCH[2]}
    patch=${BASH_REMATCH[3]}
    echo "Major: $major, Minor: $minor, Patch: $patch"
fi
```

**BASH_REMATCH Array:**
- `${BASH_REMATCH[0]}` → entire match
- `${BASH_REMATCH[1]}` → first capture group
- `${BASH_REMATCH[2]}` → second capture group

---

### BASH-067 — String Comparison Summary

| Test | True If |
|------|---------|
| `[ "$s1" = "$s2" ]` | Strings equal |
| `[ "$s1" != "$s2" ]` | Strings not equal |
| `[ -z "$s" ]` | String is empty |
| `[ -n "$s" ]` | String is not empty |
| `[[ "$s1" < "$s2" ]]` | s1 less than s2 (lexicographic) |
| `[[ "$s1" > "$s2" ]]` | s1 greater than s2 |
| `[[ $s == pattern ]]` | Pattern match |
| `[[ $s =~ regex ]]` | Regex match |

</div>

</details>

---

<details>
<summary><strong>6. Numeric Comparisons</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-068 — Integer Comparison Operators

```bash copy
# Equal
[ $a -eq $b ]

# Not equal
[ $a -ne $b ]

# Less than
[ $a -lt $b ]

# Less than or equal
[ $a -le $b ]

# Greater than
[ $a -gt $b ]

# Greater than or equal
[ $a -ge $b ]
```

**Example:**
```bash copy
disk_usage=85
threshold=80

if [ $disk_usage -gt $threshold ]; then
    echo "Disk usage above threshold"
    echo "Current: ${disk_usage}%"
    echo "Threshold: ${threshold}%"
fi
```

---

### BASH-069 — Arithmetic Context (( ))

Inside `(( ))`, you can use C-style operators:

```bash copy
# C-style comparison
if ((count > 10)); then
    echo "Count exceeds 10"
fi

# Multiple conditions
if ((count > 0 && count < 100)); then
    echo "Count is between 1 and 99"
fi
```

**Operators:**
```bash copy
((a == b))    # Equal
((a != b))    # Not equal
((a < b))     # Less than
((a <= b))    # Less than or equal
((a > b))     # Greater than
((a >= b))    # Greater than or equal
```

**Example:**
```bash copy
port=8080

if ((port < 1024)); then
    echo "Privileged port - requires root"
elif ((port > 65535)); then
    echo "Invalid port number"
else
    echo "Port $port is valid"
fi
```

---

### BASH-070 — Numeric Comparison Summary

**Traditional [ ] Syntax:**

| Test | True If |
|------|---------|
| `[ $a -eq $b ]` | a equals b |
| `[ $a -ne $b ]` | a not equals b |
| `[ $a -lt $b ]` | a less than b |
| `[ $a -le $b ]` | a less than or equal b |
| `[ $a -gt $b ]` | a greater than b |
| `[ $a -ge $b ]` | a greater than or equal b |

**Modern (( )) Syntax:**

| Test | True If |
|------|---------|
| `((a == b))` | a equals b |
| `((a != b))` | a not equals b |
| `((a < b))` | a less than b |
| `((a <= b))` | a less than or equal b |
| `((a > b))` | a greater than b |
| `((a >= b))` | a greater than or equal b |

**Recommendation:**
Use `(( ))` for numeric comparisons — it's clearer and more familiar to programmers from other languages.

</div>

</details>

---

<details>
<summary><strong>7. Logical Operators</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-071 — AND Operator

```bash copy
# Using [ ]
[ condition1 ] && [ condition2 ]
[ condition1 -a condition2 ]  # Deprecated

# Using [[ ]]
[[ condition1 && condition2 ]]

# Using (( ))
((condition1 && condition2))
```

**Example:**
```bash copy
# Check file is readable and writable
if [ -r config.txt ] && [ -w config.txt ]; then
    echo "Can read and write config.txt"
fi

# Modern syntax
if [[ -r config.txt && -w config.txt ]]; then
    echo "Can read and write config.txt"
fi
```

---

### BASH-072 — OR Operator

```bash copy
# Using [ ]
[ condition1 ] || [ condition2 ]
[ condition1 -o condition2 ]  # Deprecated

# Using [[ ]]
[[ condition1 || condition2 ]]

# Using (( ))
((condition1 || condition2))
```

**Example:**
```bash copy
# Check if either config file exists
if [ -f config.yaml ] || [ -f config.yml ]; then
    echo "Config file found"
fi

# Modern syntax
if [[ -f config.yaml || -f config.yml ]]; then
    echo "Config file found"
fi
```

---

### BASH-073 — NOT Operator

```bash copy
# Using [ ]
[ ! condition ]

# Using [[ ]]
[[ ! condition ]]

# Using (( ))
((! condition))
```

**Example:**
```bash copy
# Check file doesn't exist
if [ ! -f /tmp/lockfile ]; then
    echo "No lockfile found"
    touch /tmp/lockfile
fi

# Check not empty
if [ -n "$var" ]; then
    echo "Variable is set"
fi

# Equivalent
if [ ! -z "$var" ]; then
    echo "Variable is set"
fi
```

---

### BASH-074 — Combining Operators

```bash copy
# Complex conditions
if [[ -f config.txt && -r config.txt && ! -w config.txt ]]; then
    echo "Config is readable but not writable"
fi

# With parentheses for grouping
if [[ ( -f config.yaml || -f config.yml ) && -r config.yaml ]]; then
    echo "YAML config exists and is readable"
fi
```

**Example:**
```bash copy
# Validate environment
environment=$1

if [[ -z "$environment" || ! ( "$environment" == "dev" || "$environment" == "staging" || "$environment" == "prod" ) ]]; then
    echo "Invalid environment: $environment" >&2
    echo "Must be: dev, staging, or prod" >&2
    exit 1
fi
```

---

### BASH-075 — Logical Operators Summary

**[ ] Syntax:**

| Operator | Meaning | Example |
|----------|---------|---------|
| `[ ! condition ]` | NOT | `[ ! -f file ]` |
| `[ c1 ] && [ c2 ]` | AND | `[ -f f1 ] && [ -f f2 ]` |
| `[ c1 ] \|\| [ c2 ]` | OR | `[ -f f1 ] \|\| [ -f f2 ]` |

**[[ ]] Syntax (Recommended):**

| Operator | Meaning | Example |
|----------|---------|---------|
| `[[ ! condition ]]` | NOT | `[[ ! -f file ]]` |
| `[[ c1 && c2 ]]` | AND | `[[ -f f1 && -f f2 ]]` |
| `[[ c1 \|\| c2 ]]` | OR | `[[ -f f1 \|\| -f f2 ]]` |

</div>

</details>

---

<details>
<summary><strong>8. The case Statement</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

The `case` statement provides clean multi-way branching.

---

### BASH-076 — Basic case Syntax

```bash copy
case $variable in
    pattern1)
        # code
        ;;
    pattern2)
        # code
        ;;
    *)
        # default case
        ;;
esac
```

**Key Points:**
- Each pattern ends with `)`
- Each block ends with `;;`
- `*` is the catch-all default case
- Must end with `esac`

---

### BASH-077 — Simple case Example

```bash copy
environment=$1

case $environment in
    dev)
        echo "Development environment"
        database="dev-db"
        ;;
    staging)
        echo "Staging environment"
        database="staging-db"
        ;;
    production)
        echo "Production environment"
        database="prod-db"
        ;;
    *)
        echo "Unknown environment: $environment" >&2
        exit 1
        ;;
esac

echo "Using database: $database"
```

---

### BASH-078 — Multiple Patterns

```bash copy
# Use | for OR
case $extension in
    jpg|jpeg|png|gif)
        echo "Image file"
        ;;
    mp4|avi|mkv)
        echo "Video file"
        ;;
    mp3|wav|flac)
        echo "Audio file"
        ;;
    *)
        echo "Unknown file type"
        ;;
esac
```

---

### BASH-079 — Pattern Matching

```bash copy
# Supports wildcards
case $filename in
    *.txt)
        echo "Text file"
        ;;
    *.log)
        echo "Log file"
        ;;
    backup_*)
        echo "Backup file"
        ;;
    [0-9]*.dat)
        echo "Data file starting with digit"
        ;;
    *)
        echo "Other file"
        ;;
esac
```

---

### BASH-080 — Case with Commands

```bash copy
read -p "Enter action (start/stop/restart/status): " action

case $action in
    start)
        echo "Starting service..."
        systemctl start myapp
        ;;
    stop)
        echo "Stopping service..."
        systemctl stop myapp
        ;;
    restart)
        echo "Restarting service..."
        systemctl restart myapp
        ;;
    status)
        systemctl status myapp
        ;;
    *)
        echo "Invalid action: $action" >&2
        echo "Valid actions: start, stop, restart, status" >&2
        exit 1
        ;;
esac
```

---

### BASH-081 — Fall-Through with ;&

```bash copy
# ;& falls through to next case (Bash 4+)
case $option in
    verbose)
        verbose=true
        ;&
    debug)
        debug=true
        ;;
esac
```

**Rarely Used:**
Most scripts don't need fall-through behavior.

---

### BASH-082 — case vs if-elif-else

**Use case when:**
- Testing single variable against multiple values
- Pattern matching is useful
- Cleaner than long if-elif chains

**Use if-elif when:**
- Testing different variables
- Complex conditions
- Need comparison operators

**Example - Better with case:**
```bash copy
# Verbose
if [ "$action" = "start" ]; then
    start_service
elif [ "$action" = "stop" ]; then
    stop_service
elif [ "$action" = "restart" ]; then
    restart_service
else
    echo "Invalid"
fi

# Cleaner
case $action in
    start) start_service ;;
    stop) stop_service ;;
    restart) restart_service ;;
    *) echo "Invalid" ;;
esac
```

</div>

</details>

---

<details>
<summary><strong>9. Test Command Styles</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-083 — Three Test Styles

```bash copy
# Style 1: test command
test -f file.txt

# Style 2: [ ] (synonym for test)
[ -f file.txt ]

# Style 3: [[ ]] (Bash keyword)
[[ -f file.txt ]]
```

---

### BASH-084 — When to Use Each

**Use `test` or `[ ]`:**
- POSIX compliance required
- Script must run on any shell
- Maximum portability

**Use `[[ ]]`:**
- Bash-specific scripts
- Pattern matching needed
- Regex matching needed
- Safer word splitting
- Cleaner syntax

**Example Differences:**
```bash copy
# Pattern matching - only [[ ]]
[[ $filename == *.txt ]]  # Works
[ $filename = *.txt ]     # Doesn't work as expected

# Regex - only [[ ]]
[[ $email =~ ^.*@.*\.com$ ]]  # Works
[ $email =~ ^.*@.*\.com$ ]    # Doesn't work

# No quote needed for empty strings in [[ ]]
x=""
[[ -z $x ]]  # Safe
[ -z $x ]    # Safe but should quote: [ -z "$x" ]
```

---

### BASH-085 — Style Comparison

| Feature | `[ ]` | `[[ ]]` |
|---------|-------|---------|
| POSIX compliant | ✅ | ❌ |
| Word splitting | ⚠️ Yes | ✅ No |
| Pattern matching | ❌ | ✅ |
| Regex matching | ❌ | ✅ |
| `&&` and `\|\|` inside | ❌ | ✅ |
| `<` and `>` for strings | ⚠️ Needs escape | ✅ |

**Recommendation for DevOps:**
Use `[[ ]]` in Bash scripts — it's safer and more powerful.

</div>

</details>

---

<details>
<summary><strong>10. Exit Status in Conditionals</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-086 — Testing Command Success

```bash copy
# if checks exit status
if command; then
    echo "Command succeeded"
fi

# Example
if grep -q "error" /var/log/app.log; then
    echo "Errors found in log"
fi
```

**Any Command Works:**
```bash copy
# Test if service is running
if systemctl is-active nginx; then
    echo "Nginx is running"
fi

# Test if package installed
if dpkg -l | grep -q nginx; then
    echo "Nginx is installed"
fi

# Test network connectivity
if ping -c 1 google.com &>/dev/null; then
    echo "Network is up"
fi
```

---

### BASH-087 — Negating Command Status

```bash copy
# if command fails
if ! command; then
    echo "Command failed"
fi

# Example
if ! systemctl is-active postgresql; then
    echo "PostgreSQL is not running"
    systemctl start postgresql
fi
```

---

### BASH-088 — Combining with Test Operators

```bash copy
# Command success AND file exists
if command && [ -f file.txt ]; then
    echo "Command succeeded and file exists"
fi

# Example
if systemctl start myapp && [ -f /var/run/myapp.pid ]; then
    echo "Service started successfully"
fi
```

---

### BASH-089 — Exit Status Best Practices

```bash copy
#!/bin/bash
# Always check critical operations

# Bad - no error checking
cp source.txt destination.txt
echo "Copy completed"

# Good - check status
if cp source.txt destination.txt; then
    echo "Copy completed"
else
    echo "Copy failed" >&2
    exit 1
fi

# Good - using set -e
set -e
cp source.txt destination.txt
echo "Copy completed"
```

</div>

</details>

---

<details>
<summary><strong>11. Complex Conditions</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-090 — Nested Conditions

```bash copy
if [ condition1 ]; then
    if [ condition2 ]; then
        # both true
    fi
fi

# Better with &&
if [ condition1 ] && [ condition2 ]; then
    # both true
fi

# Best with [[ ]]
if [[ condition1 && condition2 ]]; then
    # both true
fi
```

---

### BASH-091 — Multi-Level Validation

```bash copy
#!/bin/bash
# Validate deployment prerequisites

environment=$1
version=$2

# Level 1: Arguments provided
if [ $# -lt 2 ]; then
    echo "Usage: $0 <environment> <version>" >&2
    exit 1
fi

# Level 2: Valid environment
if [[ ! "$environment" =~ ^(dev|staging|prod)$ ]]; then
    echo "Invalid environment: $environment" >&2
    exit 1
fi

# Level 3: Valid version format
if [[ ! "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo "Invalid version format: $version" >&2
    exit 1
fi

# Level 4: Prerequisites exist
if [[ ! -f docker-compose.yml ]]; then
    echo "docker-compose.yml not found" >&2
    exit 1
fi

if ! command -v docker &>/dev/null; then
    echo "Docker not installed" >&2
    exit 1
fi

echo "All validations passed"
echo "Deploying $version to $environment..."
```

---

### BASH-092 — Conditional Variable Assignment

```bash copy
# Ternary-like behavior
result=$([ condition ] && echo "true_value" || echo "false_value")

# Example
status=$([ -f backup.tar.gz ] && echo "Backup exists" || echo "No backup")

# Better with if
if [ -f backup.tar.gz ]; then
    status="Backup exists"
else
    status="No backup"
fi
```

---

### BASH-093 — Function Return Values in Conditions

```bash copy
check_port() {
    local port=$1
    nc -z localhost $port &>/dev/null
}

# Use function in condition
if check_port 8080; then
    echo "Port 8080 is open"
else
    echo "Port 8080 is closed"
fi
```

</div>

</details>

---

<details>
<summary><strong>12. Common Conditional Patterns</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### BASH-094 — Argument Validation

```bash copy
#!/bin/bash
# Standard argument checking pattern

if [ $# -eq 0 ]; then
    echo "Usage: $0 <filename>" >&2
    exit 1
fi

filename=$1

if [ ! -f "$filename" ]; then
    echo "File not found: $filename" >&2
    exit 1
fi

echo "Processing: $filename"
```

---

### BASH-095 — File Existence with Default

```bash copy
# Use config if exists, otherwise default
if [ -f config.local.sh ]; then
    source config.local.sh
else
    source config.default.sh
fi

# Alternative
config_file="config.local.sh"
[ -f "$config_file" ] || config_file="config.default.sh"
source "$config_file"
```

---

### BASH-096 — Required Environment Variables

```bash copy
# Check multiple required variables
required_vars=(DATABASE_HOST DATABASE_NAME API_KEY)

for var in "${required_vars[@]}"; do
    if [ -z "${!var}" ]; then
        echo "Error: $var is not set" >&2
        exit 1
    fi
done

echo "All required variables set"
```

---

### BASH-097 — Interactive Confirmation

```bash copy
# Ask for confirmation before destructive action
read -p "Delete all logs? (yes/no): " confirm

if [ "$confirm" != "yes" ]; then
    echo "Operation cancelled"
    exit 0
fi

echo "Deleting logs..."
rm -rf /var/log/myapp/*
```

---

### BASH-098 — Retry Logic

```bash copy
# Retry command up to N times
max_retries=3
count=0

until command || [ $count -eq $max_retries ]; do
    ((count++))
    echo "Attempt $count failed, retrying..."
    sleep 2
done

if [ $count -eq $max_retries ]; then
    echo "Command failed after $max_retries attempts" >&2
    exit 1
fi
```

---

### BASH-099 — Dry Run Pattern

```bash copy
#!/bin/bash
# Support --dry-run flag

DRY_RUN=false

if [ "$1" = "--dry-run" ]; then
    DRY_RUN=true
    shift
fi

if $DRY_RUN; then
    echo "[DRY RUN] Would delete: file.txt"
else
    echo "Deleting: file.txt"
    rm file.txt
fi
```

</div>

</details>

---

<details>
<summary><strong>13. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Service Health Check

```bash copy
#!/bin/bash
# health_check.sh - Check service health and restart if needed

SERVICE="nginx"
MAX_RETRIES=3

check_service() {
    systemctl is-active $SERVICE &>/dev/null
}

restart_service() {
    echo "Service $SERVICE is down, attempting restart..."
    systemctl restart $SERVICE
    sleep 2
}

# Main check
if check_service; then
    echo "✓ $SERVICE is running"
    exit 0
fi

# Service is down, try to restart
echo "✗ $SERVICE is not running"
retry_count=0

while [ $retry_count -lt $MAX_RETRIES ]; do
    restart_service
    
    if check_service; then
        echo "✓ $SERVICE restarted successfully"
        exit 0
    fi
    
    ((retry_count++))
    echo "Restart attempt $retry_count failed"
done

# All retries failed
echo "✗ Failed to restart $SERVICE after $MAX_RETRIES attempts" >&2
echo "Manual intervention required" >&2
exit 1
```

---

### Scenario 2: Deployment Environment Validation

```bash copy
#!/bin/bash
# deploy.sh - Production-safe deployment script

set -euo pipefail

environment=${1:-}
version=${2:-}

# Validation: Arguments provided
if [[ -z "$environment" || -z "$version" ]]; then
    cat >&2 << EOF
Usage: $0 <environment> <version>

Environments:
  dev        - Development
  staging    - Staging
  production - Production

Examples:
  $0 dev v1.2.3
  $0 production v1.2.3
EOF
    exit 1
fi

# Validation: Environment
case $environment in
    dev|development)
        environment="dev"
        replicas=1
        ;;
    staging|stg)
        environment="staging"
        replicas=2
        ;;
    production|prod)
        environment="production"
        replicas=5
        
        # Extra confirmation for production
        read -p "⚠️  Deploy to PRODUCTION? (type 'yes' to confirm): " confirm
        if [[ "$confirm" != "yes" ]]; then
            echo "Production deployment cancelled"
            exit 0
        fi
        ;;
    *)
        echo "Invalid environment: $environment" >&2
        exit 1
        ;;
esac

# Validation: Version format
if [[ ! "$version" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    echo "Invalid version format: $version" >&2
    echo "Expected format: vX.Y.Z (e.g., v1.2.3)" >&2
    exit 1
fi

# Validation: Docker available
if ! command -v docker &>/dev/null; then
    echo "Docker is not installed" >&2
    exit 1
fi

# Validation: Image exists
image="myapp:${version}"
if ! docker pull "$image" &>/dev/null; then
    echo "Docker image not found: $image" >&2
    exit 1
fi

# All checks passed
echo "✓ Validation complete"
echo "Deploying $version to $environment with $replicas replicas..."

# Deployment logic here
kubectl set image deployment/myapp myapp="$image" --namespace="$environment"
kubectl scale deployment/myapp --replicas="$replicas" --namespace="$environment"

echo "✓ Deployment initiated"
```

---

### Scenario 3: Backup with Space Check

```bash copy
#!/bin/bash
# backup.sh - Smart backup with space validation

set -euo pipefail

SOURCE_DIR="/var/www/html"
BACKUP_DIR="/backups"
MIN_FREE_GB=10

# Check source exists
if [[ ! -d "$SOURCE_DIR" ]]; then
    echo "Source directory not found: $SOURCE_DIR" >&2
    exit 1
fi

# Check backup destination exists
if [[ ! -d "$BACKUP_DIR" ]]; then
    echo "Creating backup directory: $BACKUP_DIR"
    mkdir -p "$BACKUP_DIR"
fi

# Check write permission
if [[ ! -w "$BACKUP_DIR" ]]; then
    echo "No write permission to: $BACKUP_DIR" >&2
    exit 1
fi

# Check available space
available_gb=$(df -BG "$BACKUP_DIR" | awk 'NR==2 {print $4}' | sed 's/G//')

if ((available_gb < MIN_FREE_GB)); then
    echo "Insufficient space in $BACKUP_DIR" >&2
    echo "Available: ${available_gb}GB" >&2
    echo "Required: ${MIN_FREE_GB}GB" >&2
    exit 1
fi

# Calculate source size
source_size=$(du -sh "$SOURCE_DIR" | awk '{print $1}')
echo "Source size: $source_size"
echo "Available space: ${available_gb}GB"

# Create backup
backup_file="$BACKUP_DIR/backup_$(date +%Y%m%d_%H%M%S).tar.gz"
echo "Creating backup: $backup_file"

if tar -czf "$backup_file" -C "$(dirname "$SOURCE_DIR")" "$(basename "$SOURCE_DIR")"; then
    backup_size=$(du -h "$backup_file" | awk '{print $1}')
    echo "✓ Backup completed: $backup_size"
    echo "Saved to: $backup_file"
else
    echo "✗ Backup failed" >&2
    [ -f "$backup_file" ] && rm "$backup_file"
    exit 1
fi

# Clean old backups (keep last 7 days)
echo "Cleaning old backups..."
find "$BACKUP_DIR" -name "backup_*.tar.gz" -mtime +7 -delete
echo "✓ Cleanup complete"
```

---

### Scenario 4: Log Rotation with Compression

```bash copy
#!/bin/bash
# rotate_logs.sh - Intelligent log rotation

set -euo pipefail

LOG_FILE="/var/log/myapp/app.log"
MAX_SIZE_MB=100
KEEP_ROTATIONS=5

# Check if log exists
if [[ ! -f "$LOG_FILE" ]]; then
    echo "Log file not found: $LOG_FILE"
    exit 0
fi

# Get log size in MB
log_size_mb=$(du -m "$LOG_FILE" | awk '{print $1}')

echo "Log file: $LOG_FILE"
echo "Current size: ${log_size_mb}MB"
echo "Max size: ${MAX_SIZE_MB}MB"

# Check if rotation needed
if ((log_size_mb < MAX_SIZE_MB)); then
    echo "Rotation not needed"
    exit 0
fi

echo "Rotation threshold exceeded, rotating..."

# Get log directory
log_dir=$(dirname "$LOG_FILE")
log_name=$(basename "$LOG_FILE")

# Rotate existing logs
for i in $(seq $((KEEP_ROTATIONS - 1)) -1 1); do
    old_log="${log_dir}/${log_name}.${i}.gz"
    new_log="${log_dir}/${log_name}.$((i + 1)).gz"
    
    if [[ -f "$old_log" ]]; then
        mv "$old_log" "$new_log"
        echo "Rotated: $(basename "$old_log") -> $(basename "$new_log")"
    fi
done

# Compress and rotate current log
rotated_log="${log_dir}/${log_name}.1"

if mv "$LOG_FILE" "$rotated_log" && gzip "$rotated_log"; then
    echo "✓ Rotated and compressed: ${log_name} -> ${log_name}.1.gz"
    
    # Create new empty log
    touch "$LOG_FILE"
    chmod 644 "$LOG_FILE"
    
    # Restart service to use new log (if needed)
    if systemctl is-active myapp &>/dev/null; then
        echo "Reloading myapp service..."
        systemctl reload myapp
    fi
else
    echo "✗ Rotation failed" >&2
    exit 1
fi

# Remove oldest rotation if exists
oldest_log="${log_dir}/${log_name}.$((KEEP_ROTATIONS + 1)).gz"
if [[ -f "$oldest_log" ]]; then
    rm "$oldest_log"
    echo "Removed oldest rotation: $(basename "$oldest_log")"
fi

echo "✓ Log rotation complete"
```

---

### Scenario 5: Database Backup with Validation

```bash copy
#!/bin/bash
# db_backup.sh - Database backup with integrity checks

set -euo pipefail

# Configuration
: ${DB_HOST:?"DB_HOST not set"}
: ${DB_NAME:?"DB_NAME not set"}
: ${DB_USER:?"DB_USER not set"}
: ${DB_PASSWORD:?"DB_PASSWORD not set"}

BACKUP_DIR="/var/backups/database"
RETENTION_DAYS=7

# Create backup directory
mkdir -p "$BACKUP_DIR"

# Generate backup filename
timestamp=$(date +%Y%m%d_%H%M%S)
backup_file="$BACKUP_DIR/${DB_NAME}_${timestamp}.sql"
checksum_file="${backup_file}.md5"

echo "Starting backup of database: $DB_NAME"
echo "Host: $DB_HOST"

# Create backup
if PGPASSWORD="$DB_PASSWORD" pg_dump -h "$DB_HOST" -U "$DB_USER" "$DB_NAME" > "$backup_file"; then
    echo "✓ Backup created: $(basename "$backup_file")"
else
    echo "✗ Backup failed" >&2
    [ -f "$backup_file" ] && rm "$backup_file"
    exit 1
fi

# Verify backup is not empty
if [[ ! -s "$backup_file" ]]; then
    echo "✗ Backup file is empty" >&2
    rm "$backup_file"
    exit 1
fi

# Generate checksum
md5sum "$backup_file" > "$checksum_file"
echo "✓ Checksum created"

# Compress backup
if gzip "$backup_file"; then
    backup_file="${backup_file}.gz"
    echo "✓ Backup compressed"
else
    echo "⚠ Compression failed, keeping uncompressed" >&2
fi

# Get final size
backup_size=$(du -h "$backup_file" | awk '{print $1}')
echo "✓ Final backup size: $backup_size"

# Clean old backups
echo "Cleaning backups older than $RETENTION_DAYS days..."
deleted_count=0

while IFS= read -r old_backup; do
    rm "$old_backup"
    # Remove associated checksum if exists
    [[ -f "${old_backup%.gz}.md5" ]] && rm "${old_backup%.gz}.md5"
    ((deleted_count++))
done < <(find "$BACKUP_DIR" -name "${DB_NAME}_*.sql.gz" -mtime +$RETENTION_DAYS)

if ((deleted_count > 0)); then
    echo "✓ Removed $deleted_count old backup(s)"
else
    echo "No old backups to remove"
fi

# Summary
total_backups=$(find "$BACKUP_DIR" -name "${DB_NAME}_*.sql.gz" | wc -l)
total_size=$(du -sh "$BACKUP_DIR" | awk '{print $1}')

echo ""
echo "=== Backup Summary ==="
echo "Current backup: $(basename "$backup_file")"
echo "Total backups: $total_backups"
echo "Total size: $total_size"
echo "✓ Backup completed successfully"
```

</div>

</details>

---

<details>
<summary><strong>14. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
# Basic if
if [ condition ]; then
    command
fi
```

```bash copy
# if-else
if [ condition ]; then
    command1
else
    command2
fi
```

```bash copy
# if-elif-else
if [ condition1 ]; then
    command1
elif [ condition2 ]; then
    command2
else
    command3
fi
```

```bash copy
# One-line if
[ condition ] && command
```

```bash copy
# File exists
[ -f file.txt ]
```

```bash copy
# Directory exists
[ -d /path/to/dir ]
```

```bash copy
# File is readable
[ -r file.txt ]
```

```bash copy
# String equal
[ "$str1" = "$str2" ]
```

```bash copy
# String not empty
[ -n "$str" ]
```

```bash copy
# String empty
[ -z "$str" ]
```

```bash copy
# Numeric comparison
[ $a -eq $b ]    # equal
[ $a -ne $b ]    # not equal
[ $a -lt $b ]    # less than
[ $a -gt $b ]    # greater than
```

```bash copy
# Arithmetic comparison
if ((count > 10)); then
    echo "Greater than 10"
fi
```

```bash copy
# Pattern matching
[[ $filename == *.txt ]]
```

```bash copy
# Regex matching
[[ $email =~ ^.*@.*\.com$ ]]
```

```bash copy
# AND operator
[[ condition1 && condition2 ]]
```

```bash copy
# OR operator
[[ condition1 || condition2 ]]
```

```bash copy
# NOT operator
[[ ! condition ]]
```

```bash copy
# case statement
case $var in
    pattern1)
        command1
        ;;
    pattern2)
        command2
        ;;
    *)
        default_command
        ;;
esac
```

```bash copy
# Test command success
if command; then
    echo "Success"
fi
```

```bash copy
# Test command failure
if ! command; then
    echo "Failed"
fi
```

</div>

</details>

---

<details>
<summary><strong>15. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Exit status 0 = success = true
- Use `[[ ]]` for Bash scripts (safer, more powerful)
- Use `[ ]` only for POSIX portability
- Always quote variables: `[ "$var" = "value" ]`
- `case` is cleaner than long if-elif chains
- Any command can be used in if statements

---

**File Tests:**

| Test | True If |
|------|---------|
| `[ -e file ]` | File exists |
| `[ -f file ]` | Regular file |
| `[ -d file ]` | Directory |
| `[ -L file ]` | Symbolic link |
| `[ -s file ]` | Not empty |
| `[ -r file ]` | Readable |
| `[ -w file ]` | Writable |
| `[ -x file ]` | Executable |

---

**String Tests:**

| Test | True If |
|------|---------|
| `[ "$s1" = "$s2" ]` | Equal |
| `[ "$s1" != "$s2" ]` | Not equal |
| `[ -z "$s" ]` | Empty |
| `[ -n "$s" ]` | Not empty |
| `[[ $s == pattern ]]` | Pattern match |
| `[[ $s =~ regex ]]` | Regex match |

---

**Numeric Tests:**

| Test | True If |
|------|---------|
| `[ $a -eq $b ]` | Equal |
| `[ $a -ne $b ]` | Not equal |
| `[ $a -lt $b ]` | Less than |
| `[ $a -le $b ]` | Less or equal |
| `[ $a -gt $b ]` | Greater than |
| `[ $a -ge $b ]` | Greater or equal |

**Or use (( )) with C-style operators:**

| Test | True If |
|------|---------|
| `((a == b))` | Equal |
| `((a != b))` | Not equal |
| `((a < b))` | Less than |
| `((a > b))` | Greater than |

---

**Logical Operators:**

| Operator | Syntax |
|----------|--------|
| AND | `[[ c1 && c2 ]]` |
| OR | `[[ c1 \|\| c2 ]]` |
| NOT | `[[ ! condition ]]` |

---

**Common Patterns:**

```bash copy
# Argument validation
if [ $# -lt 1 ]; then
    echo "Usage: $0 <arg>" >&2
    exit 1
fi

# File validation
if [ ! -f "$file" ]; then
    echo "File not found: $file" >&2
    exit 1
fi

# Environment variable check
if [ -z "$VAR" ]; then
    echo "VAR not set" >&2
    exit 1
fi

# Multiple patterns
case $ext in
    jpg|png|gif) echo "Image" ;;
    mp4|avi) echo "Video" ;;
    *) echo "Unknown" ;;
esac

# Command success check
if command; then
    echo "Success"
else
    echo "Failed"
    exit 1
fi
```

---

**Test Style Recommendations:**

- Use `[[ ]]` for Bash scripts → safer and more powerful
- Use `[ ]` only when POSIX compliance required
- Use `(( ))` for numeric comparisons → clearer syntax
- Use `case` for multiple value checks → cleaner than if-elif

---

**What's Next:**
Now that you can make decisions with conditionals, the next file covers loops and iteration — how to repeat operations and process collections of data.

</div>

</details>

---
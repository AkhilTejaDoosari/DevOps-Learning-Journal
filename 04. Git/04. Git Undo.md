# Git Undo

## Table of Contents

- [1. Git Rebase](#1-git-rebase) 
- [1. Git Reflog](#2-git-reflog) 


<details>
<summary><strong>1. Git Revert</strong></summary>

## Why do we need Git Revert?  

Sometimes you make a commit and later realize:  
- You added the wrong code.  
- You broke something.  
- You need to roll it back, but without deleting history.  

üëâ In these cases, `git revert` is the safest way to undo because it **creates a new commit that cancels out the changes** of the bad commit.  
It does **not erase history**, so it works perfectly in shared repositories (GitHub, GitLab, Bitbucket).  

*Analogy:* Imagine you wrote something wrong in ink on a whiteboard. Instead of erasing the entire board (losing history), you add a **new note** that says ‚ÄúIgnore the previous line.‚Äù Everyone still sees the history, but also sees the correction.  

---

## How does Git Revert work?  

- Finds the commit you want to undo.  
- Creates a **new commit** that reverses that commit‚Äôs changes.  
- Keeps commit history intact.  

---

## Basic Commands  

| Command | Meaning |
|---------|---------|
| `git revert HEAD` | Revert the latest commit |
| `git revert <commit_id>` | Revert a specific commit |
| `git revert HEAD~2` | Revert a commit two steps back |
| `git revert --no-edit` | Skip opening commit message editor |
| `git log --oneline` | Show commit history to find commits |

---

## Step 1: Find the Commit  

Use `git log --oneline` to see recent commits:  

```bash
git log --oneline
52418f7 (HEAD -> master) Just a regular update, definitely no accidents here...
9a9add8 (origin/master) Added .gitignore
81912ba Corrected spelling error
3fdaa5b Merge pull request #1 from update-readme
...
````

Copy the **commit ID** you want to undo.

---

## Step 2: Run Git Revert

Revert the latest commit:

```bash
git revert HEAD --no-edit
```

**Output example:**

```output
[master e56ba1f] Revert "Just a regular update, definitely no accidents here..."
 Date: Thu Apr 22 10:50:13 2021 +0200
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 img_hello_git.jpg
```

This created a **new commit** that reversed the bad one.

---

## Step 3: Review Changes

Check commit history again:

```bash
git log --oneline
```

Example result:

```output
e56ba1f (HEAD -> master) Revert "Just a regular update, definitely no accidents here..."
52418f7 Just a regular update, definitely no accidents here...
9a9add8 (origin/master) Added .gitignore
...
```

Notice:

* The **bad commit** is still there (history preserved).
* But now there‚Äôs a new commit that cancels it out.

---

## Tips & Best Practices

* ‚úÖ Use **`git revert`** instead of `git reset` in **shared repos** to keep history clean.
* ‚úÖ Use `git log --oneline` to quickly find commit IDs.
* ‚úÖ Use `--no-edit` if you don‚Äôt want to edit the default revert message.

---

## Troubleshooting

* **Problem:** `error: could not revert...`

  * Run:

    ```bash
    git revert --abort
    ```

    (Abort the revert process.)

* **Problem:** `error: could not apply...`

  * Run:

    ```bash
    git revert --continue
    ```

    (Continue after resolving conflicts.)

---

## When to use Git Revert?

* When you want to **undo a commit** but keep project history intact.
* Safe for **collaborative projects** on GitHub, GitLab, Bitbucket.
* Best choice when you don‚Äôt want to **rewrite history**.

</details>

---

<details>
<summary><strong>2. Git Reflog</strong></summary>

---

### Table of Contents (for this section)

1. [What is Git Reflog?](#what-is-git-reflog)
2. [Why Do We Need Git Reflog?](#why-do-we-need-git-reflog)
3. [Basic Usage](#basic-usage)
4. [Recovering Lost Commits](#recovering-lost-commits)
5. [Restoring Deleted Branches](#restoring-deleted-branches)
6. [Cleaning and Expiration](#cleaning-and-expiration)
7. [Best Practices](#best-practices)
8. [Warnings](#warnings)

---

<details>
<summary><strong>1. What is Git Reflog?</strong></summary>

* `git reflog` = **Reference Log**.
* It records every change made to the **tip of branches (HEAD)**.
* Unlike `git log`, it also shows commits that are not reachable from any branch or tag.
* Think of it as a **‚Äútime machine‚Äù** for Git: you can go back to almost any point in your local history.

Example commands that update the reflog:

* `commit`, `merge`, `rebase`, `reset`, `checkout`, `pull`, `clone`

</details>

---

<details>
<summary><strong>2. Why Do We Need Git Reflog?</strong></summary>

Use reflog when:

* You ran `git reset --hard` and lost commits.
* You accidentally deleted a branch and want it back.
* You rewrote history (`git rebase`, `git commit --amend`) and need the old state.
* You want to see **every move HEAD made** in the repo, not just commits.

</details>

---

<details>
<summary><strong>3. Basic Usage</strong></summary>

Run:

```bash
git reflog
```

Example output:

```output
e56ba1f HEAD@{0}: reset: moving to HEAD~1
52418f7 HEAD@{1}: commit: Just a regular update
9a9add8 HEAD@{2}: commit: Added .gitignore
836e5bf HEAD@{3}: checkout: moving from main to feature
```

Explanation:

* `HEAD@{0}` = current HEAD
* `HEAD@{1}`, `HEAD@{2}` = previous states
* Each entry has **commit hash + action + message**

</details>

---

<details>
<summary><strong>4. Recovering Lost Commits</strong></summary>

Find the lost commit hash in reflog:

```bash
git reflog
```

Then restore:

```bash
git checkout <commit-hash>
```

Or move HEAD back:

```bash
git reset --hard <commit-hash>
```

Example:

```bash
git reset --hard HEAD@{2}
```

‚Üí Restores repo to the state of HEAD two moves ago.

</details>

---

<details>
<summary><strong>5. Restoring Deleted Branches</strong></summary>

If you delete a branch accidentally:

```bash
git reflog
```

Find last commit of that branch, then recreate:

```bash
git branch branch-name <commit-hash>
```

Example:

```bash
git branch feature-xyz e56ba1f
```

</details>

---

<details>
<summary><strong>6. Cleaning and Expiration</strong></summary>

* Reflog entries are **local only**.
* Default expiration:

  * 90 days for entries
  * 30 days for unreachable commits

Force cleanup:

```bash
git reflog expire --expire=30.days refs/heads/main
git gc --prune=now
```

</details>

---

<details>
<summary><strong>7. Best Practices</strong></summary>

* Always check reflog before panicking about ‚Äúlost commits.‚Äù
* Combine `git reflog` with `git log` to trace both visible and hidden commits.
* Good habit: when doing risky operations (`rebase`, `reset --hard`), know you can recover with reflog.
* Reflog is **per repo, per machine** ‚Üí it does not sync with remote.

</details>

---

<details>
<summary><strong>8. Warnings</strong></summary>

‚ö†Ô∏è Reflog is **local**: if you delete a branch and push, reflog will not help on the remote.
‚ö†Ô∏è Expired or garbage-collected commits may not be recoverable.
‚ö†Ô∏è Do not rely on reflog as a permanent backup ‚Üí always push important branches.

</details>

---

<details>
<summary><strong> 4. Git Amend</strong></summary>

---

### Table of Contents (for this section)

1. [What is Git Amend?](#what-is-git-amend)
2. [When to Use Git Amend](#when-to-use-git-amend)
3. [Fix Last Commit Message](#fix-last-commit-message)
4. [Add Files to Last Commit](#add-files-to-last-commit)
5. [Remove Files from Last Commit](#remove-files-from-last-commit)
6. [Reviewing Changes](#reviewing-changes)
7. [Best Practices](#best-practices)
8. [Warnings](#warnings)

---

<details>
<summary><strong>1. What is Git Amend?</strong></summary>

* `git commit --amend` modifies the **most recent commit**.
* You can:

  * Change the commit message
  * Add new files you forgot
  * Remove unwanted files
* It **replaces the last commit** with a new one.

</details>

---

<details>
<summary><strong>2. When to Use Git Amend</strong></summary>

‚úÖ Use amend when:

* Fixing typos in commit message
* Adding forgotten changes/files
* Removing wrong files from last commit

‚ö†Ô∏è Don‚Äôt use it to change commits that are already **pushed to remote** (shared history).

</details>

---

<details>
<summary><strong>3. Fix Last Commit Message</strong></summary>

Update only the message:

```bash
git commit --amend -m "Corrected commit message"
```

Example:

```bash
git commit --amend -m "Added lines to README.md"
```

</details>

---

<details>
<summary><strong>4. Add Files to Last Commit</strong></summary>

Forgot to include a file?

```bash
git add forgotten.txt
git commit --amend
```

* Opens editor to confirm/reuse commit message.
* File gets added to the same last commit.

</details>

---

<details>
<summary><strong>5. Remove Files from Last Commit</strong></summary>

To remove a file from previous commit:

```bash
git reset HEAD^ -- unwanted.txt
git commit --amend
```

Example output after amend:

```output
1 file changed, 3 insertions(+), 1 deletion(-)
```

</details>

---

<details>
<summary><strong>6. Reviewing Changes</strong></summary>

Check updated commit log:

```bash
git log --oneline
```

Before amend:

```output
07c5bc5 (HEAD -> master) Adding plines to reddme
```

After amend:

```output
eaa69ce (HEAD -> master) Added lines to README.md
```

* The commit ID changes because it‚Äôs a **new commit**.

</details>

---

<details>
<summary><strong>7. Best Practices</strong></summary>

* Use `--amend` for **small, local fixes**.
* Safe when commits are **not yet pushed**.
* Always verify with `git log` after amending.

</details>

---

<details>
<summary><strong>8. Warnings</strong></summary>

‚ö†Ô∏è `git commit --amend` rewrites history.
‚ö†Ô∏è Avoid amending commits that are already pushed to shared remote repos.
‚ö†Ô∏è If others pulled the old commit, amending can cause conflicts.

</details>

---

Perfect üëç thanks for sharing your raw notes again.
I‚Äôll polish your **Git Rebase** section into the same smooth, story-like style we used for **Git Revert** ‚Äî with analogy, step-by-step flow, commands, tips, and troubleshooting.

Here‚Äôs the improved version:

````markdown
# üêß Git Undo ‚Äì Part 2: Git Rebase  

---

## Why do we need Git Rebase?  

As you work on a project, your commit history can become messy:  
- Many small commits clutter the log.  
- Your feature branch drifts behind `main`.  
- Merge commits pile up, making history harder to read.  

üëâ `git rebase` helps by **moving your commits onto a new base** and giving you a **clean, linear history**.  

*Analogy:* Imagine you‚Äôre writing notes in class. Instead of leaving random scribbles and arrows everywhere, you rewrite them neatly in order so they‚Äôre easier to follow.  

---

## What does Git Rebase do?  

- **Moves commits**: Takes your changes and replays them on top of another branch.  
- **Combines commits**: Lets you squash multiple commits into one.  
- **Cleans history**: Avoids unnecessary merge commits.  
- **Edits history**: Lets you reorder, edit, or reword commits.  

---

## When to Use Git Rebase  

- Keep a **clean, linear project history**.  
- Update your feature branch with the **latest main branch** changes.  
- Combine multiple small commits into one meaningful commit.  
- Reorder or reword commits before sharing.  

‚ö†Ô∏è **Important Rule:** Never rebase commits that have already been pushed to a shared repository.  

---

## Basic Rebase  

To move your feature branch on top of the latest `main`:  

```bash
git checkout feature-branch
git rebase main
````

This takes all commits from `feature-branch` and replays them **after** the latest commits on `main`.

---

## Interactive Rebase

Interactive mode (`-i`) lets you **edit, squash, reorder, or reword commits**.

Start an interactive rebase:

```bash
git rebase -i HEAD~3
```

This opens an editor showing your last 3 commits.

Options you can choose:

* `pick` ‚Üí keep commit as is
* `squash` ‚Üí combine commits together
* `edit` ‚Üí pause and edit a commit
* `reword` ‚Üí change commit message only

**Steps:**

1. Mark commits with the action you want.
2. Save and close the editor.
3. Git replays commits and pauses if needed.
4. Review and continue.

---

## Continue, Abort, or Skip

During a rebase, you may need to:

* **Continue after fixing conflicts:**

  ```bash
  git add fixed_file.txt
  git rebase --continue
  ```

* **Abort the rebase and go back:**

  ```bash
  git rebase --abort
  ```

* **Skip a commit if it can‚Äôt be fixed:**

  ```bash
  git rebase --skip
  ```

---

## Review Changes

After finishing the rebase:

```bash
git log --oneline
```

Check that commits look clean and are in the correct order.

---

## Tips & Best Practices

* ‚úÖ Use `git rebase -i` to **squash, edit, reorder, or reword** commits.
* ‚úÖ Use `git rebase --continue` after fixing conflicts.
* ‚úÖ Use `git rebase --abort` to cancel a rebase.
* ‚úÖ Use `git rebase --skip` if a commit cannot be applied.
* ‚ö†Ô∏è **Don‚Äôt rebase commits that are already pushed** to a shared repo.

---

## Troubleshooting

* **Conflict during rebase** ‚Üí Fix the conflict ‚Üí `git add file` ‚Üí `git rebase --continue`.
* **Too messy?** ‚Üí `git rebase --abort` to reset branch to its previous state.
* **Unfixable commit?** ‚Üí `git rebase --skip` to ignore it.

---

## When to use Git Rebase?

* Before pushing your branch ‚Üí to clean up local history.
* To replay your feature branch on top of the latest `main`.
* To squash multiple ‚Äúwork in progress‚Äù commits into one neat commit.

---

```
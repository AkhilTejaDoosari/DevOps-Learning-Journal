# Git Tutorial – 1  
### From Local Control to Remote Collaboration  

---

## Table of Contents  
- [0. Introduction – Why Version Control Matters](#0-introduction--why-version-control-matters)  
- [1. Git Config – Setting Your Identity](#1-git-config--setting-your-identity)  
- [2. Creating a Repository & Files – Your Project’s Birth](#2-creating-a-repository--files--your-projects-birth)  
- [3. Staging Environment – The Waiting Room](#3-staging-environment--the-waiting-room)  
- [4. Commit – Your Project’s Checkpoint](#4-commit--your-projects-checkpoint)  
- [5. Git Workflow – Putting It All Together](#5-git-workflow--putting-it-all-together)  
- [6. Connecting to a Remote – From Local to the World](#6-connecting-to-a-remote--from-local-to-the-world)  
- [7. Mentor Insight](#7-mentor-insight)  

---

<details>
<summary><strong>0. Introduction – Why Version Control Matters</strong></summary>

Before Git, developers used to zip projects as `final_v3_reallyfinal.zip` and send them by email.  
That chaos ended when **version control** arrived.

Git became the *time machine* of software — tracking every change, mistake, and recovery.  
In DevOps, Git is the **source of truth** behind automation, rollbacks, and teamwork.  

Every tool that comes later — Jenkins, Terraform, Kubernetes — depends on Git knowing  
**what changed, when, and by whom.**

<p align="center">
  <img src="images/workflow.png" alt="Git Workflow Diagram" width="400" height="420" />
</p>

</details>

---

<details>
<summary><strong>1. Git Config – Setting Your Identity</strong></summary>

Before Git can save your work, it needs to know **who you are.**  
This is your digital signature — every commit you make carries your name and email.

### Set Your Identity
```bash
git config --global user.name "Akhil Teja Doosari"
git config --global user.email "doosariakhilteja@gmail.com"
````

### Check Your Settings

```bash
git config --list
```

You’ll see lines like:

```
user.name=Akhil Teja Doosari
user.email=doosariakhilteja@gmail.com
```

That’s Git confirming it knows who’s working.

---

### Understanding Config Levels

Git can store settings in three places — like having three notebooks stacked on top of each other.
The top one (closest to your project) always wins.

| Level      | Flag       | Where It’s Stored             | Who It Affects           | Example Use               |
| ---------- | ---------- | ----------------------------- | ------------------------ | ------------------------- |
| **System** | `--system` | `/etc/gitconfig`              | Everyone on the computer | Company-wide defaults     |
| **Global** | `--global` | `~/.gitconfig`                | You (all your repos)     | Your personal identity    |
| **Local**  | `--local`  | `.git/config` inside the repo | Only this project        | Overrides global settings |

**Rule:**

```
Local → Global → System
```

So:

* Set **global** once for your main name/email.
* Use **local** if you want a different identity in one repo.
* Ignore **system** unless you’re managing shared machines.

Example:

```bash
git config --local user.email "akhil@company.com"
```

Now that project uses the local email, while others still use your global one.

</details>

---

<details>
<summary><strong>2. Creating a Repository & Files – Your Project’s Birth</strong></summary>

A **repository** is Git’s workspace — a folder it watches for changes.
When you initialize one, Git creates a hidden `.git` directory that stores history.

### Initialize a New Repository

```bash
git init
```

Check for the `.git` folder:

```bash
ls -la
```

### Add Your First File

```html
<!DOCTYPE html>
<html>
<head><title>Hello World!</title></head>
<body>
<h1>Hello Git!</h1>
</body>
</html>
```

Check what Git sees:

```bash
git status
```

The file appears **red** — meaning Git can see it but isn’t tracking it yet.
That’s where staging comes in.

</details>

---

<details>
<summary><strong>3. Staging Environment – The Waiting Room</strong></summary>

The **staging area** is like a waiting room before files enter history.
You choose exactly what to include in your next snapshot.

| Command                       | Description                     |
| ----------------------------- | ------------------------------- |
| `git add <file>`              | Stage a specific file           |
| `git add .`                   | Stage all changes in the folder |
| `git restore --staged <file>` | Unstage a file                  |
| `git status`                  | Check what’s staged or not      |

### Example

```bash
git add index.html
git status
```

Your file now appears **green** — ready to be committed.

If you added it by mistake:

```bash
git restore --staged index.html
```

**Flow:**

```
Working Directory → git add → Staging Area → git commit → Local Repository
```

</details>

---

<details>
<summary><strong>4. Commit – Your Project’s Checkpoint</strong></summary>

A **commit** is a permanent snapshot of your staged work — like saving a moment in your project’s timeline.

### Make a Commit

```bash
git commit -m "Add homepage layout"
```

Each commit includes:

* Your name and email
* The exact changes
* A message describing what changed

### Best Practices

* Keep messages short and meaningful: *“Fix login bug”*, *“Add README section”*
* Review what’s staged first with `git status`
* See history with:

  ```bash
  git log --oneline
  ```

If you make a small typo in your last commit (before pushing):

```bash
git commit --amend -m "Correct homepage layout"
```

</details>

---

<details>
<summary><strong>5. Git Workflow – Putting It All Together</strong></summary>

Here’s the complete rhythm of using Git locally and remotely:

```bash
git init                 # Create a new repo
git add .                # Stage files
git commit -m "Initial commit"
git remote add origin https://github.com/username/repo.git
git push -u origin main  # Push to GitHub
```

<p align="center">
  <img src="images/workflow.png" alt="Git Workflow" width="400" height="420" />
</p>

This simple flow — edit → stage → commit → push — forms the backbone of every DevOps pipeline.

</details>

---

<details>
<summary><strong>6. Connecting to a Remote – From Local to the World</strong></summary>

Your local repo is private to your computer.
To share it or collaborate, link it to a **remote repository** (like GitHub).

### Add a Remote

```bash
git remote add origin https://github.com/username/repo.git
```

### Check the Connection

```bash
git remote -v
```

### Push Your Work

```bash
git push -u origin main
```

The `-u` flag sets tracking, so later you can just run:

```bash
git push
```

### Pull Updates

To bring new changes from the remote:

```bash
git pull
```

Now your local and remote repos are in sync.

</details>

---

<details>
<summary><strong>7. Mentor Insight</strong></summary>

Now Git knows who you are, what you’ve built, and how to record it.
Next, we’ll learn how to **pause unfinished work and mark important moments** — with *stash* and *tags.*

</details>

---
# 🐧 EC2 – Part 3: Prerequisite of OSI → OSI Layers → Load Balancer → Auto Scaling

## Table of Contents

1. [Prerequisite of OSI](#1-prerequisite-of-osi)
2. [OSI 7 Layers (with your examples)](#2-osi-7-layers-with-your-examples)
3. [Load Balancers](#3-load-balancers)
4. [Auto Scaling](#4-auto-scaling)
5. [End-to-End Flow](#5-end-to-end-flow)

---

<details>
<summary><strong>1. Prerequisite of OSI</strong></summary>

### Why do we need prerequisites?  
Before the OSI model can even start wrapping and sending data, two steps usually happen first:  
1. Finding the server’s **IP address**.  
2. Making sure there is a **reliable connection**.  

---

### A. Domain Name System (DNS)  
*Analogy:* You know the **restaurant’s name** (“google.com”), but not its **street address**. DNS is the **telephone directory** that gives you the real address (IP).  

Steps:  
1. Browser checks its cache.  
2. If not found → asks router → ISP’s DNS.  
3. ISP may ask root → TLD (.com) → authoritative server.  
4. Returns the **IP** (e.g., 142.250.xx.xx).  

👉 Without DNS, you’d have to memorize raw IP numbers.  

---

### B. Transmission Control Protocol (TCP) – 3-Way Handshake  
*Analogy:* Starting a phone call:  
- You say: **“Hello, can you hear me?”**  
- They reply: **“Yes, I can.”**  
- You confirm: **“Great, let’s talk.”**  

Steps: 
1. **SYN** → Client: “I want to connect.”  
2. **SYN-ACK** → Server: “I hear you, I’m ready.”  
3. **ACK** → Client: “Confirmed.”  

✅ Now the connection is reliable.  
(If using **HTTPS**, TLS encryption handshake happens right after this.)  

</details>

---

<details>
<summary><strong>2. OSI 7 Layers</strong></summary>

### Why do we need OSI?

When you open a website like **google.com**, a lot happens in the background:

* Your browser makes a request.
* The request travels through wires, routers, and servers.
* The response comes back in the right order.

If everyone used their own random method, devices could **never understand each other**.

👉 The **OSI (Open Systems Interconnection) model** was created as a **common language** — so computers, networks, and software all agree on **how to send and receive data**.

Think of it like sending a **gift package**:

* You write the message,
* wrap it in boxes,
* add addresses,
* ship it using roads,
* and finally the receiver unwraps it layer by layer.

---

### Layer 7 — Application Layer

* This is where the **user interacts**.
* Example: You type **[https://www.google.com](https://www.google.com)** in your browser.
* Browser sends an **HTTP/HTTPS request** because **you asked for it**.
* Different protocols live here: HTTP/HTTPS for web, FTP for files, SMTP for email, etc.

👉 **Analogy:** You write the **letter** or **message** you want to send.

---

### Layer 6 — Presentation Layer

* Handles **formatting, compression, and encryption**.
* Example: HTTPS encrypts your data so hackers can’t read it while it travels.
* Without this layer, your message might look like gibberish on the other end.

👉 **Analogy:** You put your letter inside an **envelope and lock it** for security.

---

### Layer 5 — Session Layer

* Manages **sessions**: starts, maintains, and ends communication.
* Example: You log in to **Instagram**. For the next \~20 minutes, you don’t have to log in again because the session is still valid.
* If you clear cookies or the session expires, you must log in again.

👉 **Analogy:** This is like **keeping the phone call alive** until one side hangs up.

---

### Layer 4 — Transport Layer

* Breaks large data into **segments** and numbers them.

* Ensures data arrives **reliably and in order**.

* Uses two main protocols:

  * **TCP (Transmission Control Protocol)** → reliable, ordered, connection-oriented (used by HTTPS).
  * **UDP (User Datagram Protocol)** → faster but no guarantee (used by video calls, DNS).

* Example: Sending a **10 GB wedding video** → broken into smaller pieces, then reassembled correctly at the receiver.

👉 **Analogy:** You split the gift into **multiple numbered boxes** so nothing gets lost.

---

### Layer 3 — Network Layer

* Adds **IP addresses** (source + destination).
* Routers use these to decide the **best route** to reach the server.
* Example: Going from **Delhi → Mumbai**, there are many roads. The router picks the **shortest/best path**.

👉 **Analogy:** Writing the **from and to addresses** on the package.

---

### Layer 2 — Data Link Layer

* Works on the **local network** (LAN, Wi-Fi, Ethernet).
* Converts **packets → frames**.
* Adds **MAC addresses** (unique hardware IDs) for local delivery.
* Example: Your router knows exactly which device (phone, laptop) to send data to based on MAC.

👉 **Analogy:** The local **delivery truck** picks up your package and takes it to the right house on the street.

---

### Layer 1 — Physical Layer

* Converts frames into **bits (0s and 1s)**.
* Sends them as **electrical, optical, or radio signals**.
* Examples: Fiber optic cables, copper wires, Wi-Fi signals.

👉 **Analogy:** The **roads themselves** — the physical path that moves the trucks carrying your packages.

---

### Encapsulation & Decapsulation Flow

Think of sending and receiving a gift:

```
Sender:   L7 → L6 → L5 → L4 → L3 → L2 → L1  (wrap data step by step)
Network:  --- bits travel across wire/fiber/Wi-Fi ---
Receiver: L1 → L2 → L3 → L4 → L5 → L6 → L7  (unwrap data step by step)
```

---

✅ With this flow, the reader gets:

1. **Why OSI exists** → common rules.
2. **Each layer as a story** → with clear analogies.
3. **Your examples polished** → Google request, Instagram login, wedding video, Delhi–Mumbai, MAC addresses, HTTPS, etc.
4. **Smooth transition** → not jumping straight to technical points.

---

Do you want me to also **draw a clean diagram of OSI stack** (layers 7 → 1 with your analogies in one chart) so you can paste it in your notes?


</details>

---

<details>
<summary><strong>3. Load Balancers</strong></summary>

### Why do we even need a Load Balancer?

Imagine you built a website and put it on **one EC2 server**. At first, things look fine: a few users visit and the server replies quickly.

But as the site grows:

1. **More requests come in** – one server has to handle everything.
2. The server becomes **slower** because it’s overloaded.
3. If the server **crashes**, your entire website goes down.
4. Even small delays can make the user unhappy.

👉 This setup is risky because it has a **single point of failure**.

---

### Enter the Load Balancer (LB)

Think of a **traffic police officer** at a busy intersection. If everyone tries to rush into one road, there will be traffic jams. The officer **splits the cars into multiple roads** so traffic flows smoothly.

Similarly, a **Load Balancer sits in front of your servers**.

* All users send requests to the LB first.
* The LB then **distributes the requests** across multiple servers.
* It also checks which servers are **healthy** and avoids sending traffic to broken ones.

---

### How does it distribute requests?

One of the simplest methods is called **Round Robin**.

*Analogy:* Imagine you’re handing out exam papers to three students sitting in a row.

* The **first paper** goes to Student 1,
* the **second paper** goes to Student 2,
* the **third paper** goes to Student 3,
* the **fourth paper** again goes back to Student 1 … and so on.

The Load Balancer does the same with user requests:

* 1st request → EC2 #1
* 2nd request → EC2 #2
* 3rd request → EC2 #3
* 4th request → back to EC2 #1

👉 This ensures that **no single server gets overloaded**.

---

### Benefits of Load Balancer

1. **Distributes traffic** → no one server carries all the load.
2. **Better performance** → users get faster responses.
3. **High availability** → if one server goes down, LB routes to healthy ones.
4. **Scalability** → easy to add/remove servers behind the LB.

---

### AWS Load Balancer Types

AWS provides different types of Load Balancers for different needs:

1. **Application Load Balancer (ALB)** – Works at **Layer 7 (Application layer)**.

   * Can route requests based on **path (/login vs /images)**, **host name**, or even **headers**.
   * Best for web apps (HTTP/HTTPS).

2. **Network Load Balancer (NLB)** – Works at **Layer 4 (Transport layer)**.

   * Handles **TCP/UDP traffic** at very high speed.
   * Good for apps that need **millisecond latency**.

3. **Gateway Load Balancer (GWLB)** – Special type used with **firewalls or packet inspection tools**.

4. **Classic Load Balancer (CLB)** – The old version. Still works, but AWS recommends **ALB or NLB** for new applications.

---

### Diagram: Round Robin Flow

```
                +---------------------+
Internet ───►   |   Load Balancer     |
                +---------------------+
                     |      |      |
         ┌───────────┘      |      └───────────┐
         v                  v                  v
     [ EC2 #1 ]        [ EC2 #2 ]         [ EC2 #3 ]
       (Req 1)           (Req 2)            (Req 3)
       (Req 4)           (Req 5)            (Req 6)
```

</details>

---

<details>
<summary><strong>4. Auto Scaling</strong></summary>

### Why do we need Auto Scaling?

Let’s say your website is running on **two EC2 servers** behind a Load Balancer.

* During the day, traffic is **normal** → two servers are enough.
* But at night, suddenly a viral post brings **thousands of new visitors**.
* Two servers can’t handle it → users face **slow loading** or even **errors**.

On the other hand:

* Early morning traffic drops again.
* Now two servers are just **sitting idle**, wasting money.

👉 Without Auto Scaling, you either **over-provision** (paying extra for unused servers) or **under-provision** (risking downtime when traffic spikes).

---

### Enter Auto Scaling

Think of a **shop with counters (cash registers)**:

* When the line gets long, the manager **opens more counters**.
* When customers leave, the manager **closes some counters**.

Auto Scaling does the same with EC2 servers:

* **Scale out** → adds new EC2s when traffic is high.
* **Scale in** → removes extra EC2s when traffic is low.

---

### How does Auto Scaling work?

1. **Launch Template / Configuration**

   * Defines what each new EC2 should look like (AMI, instance type, security groups, user-data script).

2. **Auto Scaling Group (ASG)**

   * A logical group of EC2 instances.
   * Has **Min / Desired / Max** capacity (e.g., Min=1, Desired=2, Max=5).

3. **Scaling Policies**

   * **Target Tracking** → keep average CPU at 50%.
   * **Step Scaling** → if CPU > 70%, add 1 EC2; if > 90%, add 2 EC2s.
   * **Scheduled Scaling** → scale up at 9 AM, scale down at midnight.

4. **Health Checks**

   * Uses **EC2 status checks** and **Load Balancer health checks** to ensure only healthy instances stay in rotation.

5. **Lifecycle Hooks**

   * Let you run scripts **before adding or removing** an instance (e.g., configure software or save logs).

---

### Benefits of Auto Scaling

1. **Cost Efficiency** → Pay only for the capacity you need.
2. **Performance** → Automatically handles traffic spikes.
3. **High Availability** → Replaces unhealthy instances automatically.
4. **Flexibility** → Works with Load Balancers to ensure smooth distribution.

---

### Diagram: Auto Scaling Flow

```
            Internet Users
                  │
                  ▼
           [ Load Balancer ]
                  │
   ┌──────────────┴───────────────┐
   ▼                              ▼
[ EC2 #1 ]                   [ EC2 #2 ]
   ▲                              ▲
   └──────────────┬───────────────┘
                  │
        Auto Scaling Group (ASG)
  - Min = 1
  - Desired = 2
  - Max = 5

   Scale Out: Traffic ↑ → add EC2s
   Scale In : Traffic ↓ → remove EC2s
```

---
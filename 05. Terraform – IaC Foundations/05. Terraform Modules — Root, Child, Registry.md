# **05. Terraform Modules — Root, Child & Registry**

> *A quiet chapter on how Terraform breaks big ideas into reusable pieces.*

---

## Table of Contents

1. [Why Terraform Needs Modules](#1-why-terraform-needs-modules)
2. [Root vs Child Modules](#2-root-vs-child-modules)
3. [Passing Inputs & Returning Outputs](#3-passing-inputs--returning-outputs)
4. [Local Modules in a Real Project](#4-local-modules-in-a-real-project)
5. [Using Registry Modules](#5-using-registry-modules)
6. [When to Use (and Not Use) Modules](#6-when-to-use-and-not-use-modules)
7. [Diagrams](#7-diagrams)

---

<details>
<summary><strong>1. Why Terraform Needs Modules</strong></summary>

As your Terraform grows, a single `main.tf` quietly turns into a wall of resources.
A VPC here, subnets there, security groups, EC2, maybe some S3. It all works, but reading it starts to feel like opening a novel in the middle and trying to guess the plot.

Modules exist to bring structure back.

Instead of one giant configuration, you group related resources into small, focused units: a VPC module, an EC2 module, a database module. Each unit does one job and does it repeatedly well.

The goal isn’t clever abstraction.
It’s simple organization:

* keep related resources together
* reuse them safely
* understand the system at a glance

Modules let Terraform projects grow without becoming heavy or fragile.

</details>

---

<details>
<summary><strong>2. Root vs Child Modules</strong></summary>

Every Terraform run already has a module, even if you never created one.
That top-level folder where you run `terraform init` is the **root module**.

The root module is the entry point:
it holds your main configuration, your providers, and the calls to other modules. It’s the story’s first chapter.

A **child module** is just a directory with `.tf` files that the root (or another module) calls. It might define a VPC, a group of subnets, or a standard EC2 pattern. When you “use a module,” you are calling one of these child directories.

Terraform doesn’t treat them as anything magical.
A module is simply:

* a folder
* with Terraform files
* that can be called with inputs
* and can return outputs

Root calls child.
Child focuses on one concern.
Together, they turn a long script into a set of small, calm building blocks.

</details>

---

<details>
<summary><strong>3. Passing Inputs & Returning Outputs</strong></summary>

Modules are only useful if they can adapt.

You give a module information through **inputs** and get useful details back through **outputs**. The pattern is the same as the variables and outputs you already know, just applied at a higher level.

Inputs let you say things like:

* “Use this VPC CIDR here.”
* “Create these many subnets.”
* “Tag resources with this project name.”

Inside the module, those values behave like normal variables.
Outside the module, you call it with a simple `module "name" { ... }` block and pass what it needs.

Outputs travel in the other direction.

A VPC module might return:

* the VPC ID
* the public subnet IDs
* the private subnet IDs

Those outputs become inputs to other modules or resources in the root module.
Over time, your configuration starts to look like a small system of functions: each module takes a few arguments, does its work, and hands back the pieces others depend on.

The flow stays predictable:
inputs in, outputs out, wiring done at the root.

</details>

---

<details>
<summary><strong>4. Local Modules in a Real Project</strong></summary>

Most teams start with **local modules** — modules that live in the same repository.

You might have a layout like:

* a root folder with your main configuration
* a `modules/` directory holding subfolders like `vpc`, `ec2`, `security_groups`

Each child module owns its slice of infrastructure.
The VPC module sets up networks.
The EC2 module knows how to launch instances in those networks.
A security-group module standardizes rules across services.

The root module then feels lighter:

* it calls the VPC module once
* calls the EC2 module a few times
* and stitches everything together with variables and outputs

Local modules make the project feel like a set of chapters instead of one long page.
You still see the whole system, but you don’t have to hold every detail in your head at once.

</details>

---

<details>
<summary><strong>5. Using Registry Modules</strong></summary>

Not every building block needs to be written from scratch.

The **Terraform Registry** contains public modules for common patterns: VPCs, security baselines, load balancers, and more. When you use one, you’re essentially saying:

> “Someone already solved this pattern.
> I’ll reuse it instead of reinventing it.”

Registry modules are called just like local ones, but their `source` points to a published location rather than a local folder. You still provide inputs and still read outputs — the interaction model doesn’t change.

They’re especially useful for:

* standard network setups
* opinionated best-practice layouts
* speeding up initial project scaffolding

The main responsibility on your side is simple:
read the module’s documentation, understand what it creates, and decide whether it fits your environment and standards.

Used wisely, registry modules give you a head start without locking you into someone else’s style.

</details>

---

<details>
<summary><strong>6. When to Use (and Not Use) Modules</strong></summary>

Modules are powerful, but they’re not a rule that “everything must be a module.”

They help most when:

* the same pattern appears in multiple places
* a set of resources clearly belong together
* you want a stable interface for teams to consume

A VPC layout reused across environments is a good module.
A single one-off S3 bucket buried in a corner is usually not.

Over-modularizing can make a project harder to read, not easier. Too many thin modules scatter logic into small files that don’t carry real meaning.

A simple guide:

* start without modules
* notice repetition or repeated patterns
* extract those into clear, named modules

You don’t get points for abstraction.
You get value when modules reduce noise and make the system easier to reason about.

</details>

---

<details>
<summary><strong>7. Diagrams</strong></summary>

### **Root and Child Modules**

```txt
        Root Module
   (entrypoint of the run)
              |
      +-------+--------+
      |                |
   VPC Module       EC2 Module
 (networks)        (instances)
      |                |
   AWS VPCs        AWS EC2s
```

The root module stays small.
It doesn’t manage every single resource; it orchestrates modules that do.

---

### **Local vs Registry Modules**

```txt
      Local Module                  Registry Module
   (in your repo)                 (published online)
   source = "./modules/vpc"       source = "hashicorp/vpc/aws"
            |                               |
            v                               v
       Your code                       Community code
```

In both cases, Terraform sees “a module with inputs and outputs.”
The difference is only where the implementation lives.

---

Modules shift your mindset from “writing long files” to “designing small, reusable units.”
Once that clicks, Terraform stops feeling like isolated resources and starts feeling like a system you can grow calmly over time.

</details>

---
# **03. Providers, Resources & Data Sources — How Terraform Talks to APIs**
> Understanding the building blocks of Terraform infrastructure.

---

## Table of Contents
- [1. What are Providers?](#1-what-are-providers)
- [2. Provider Configuration](#2-provider-configuration)
- [3. Provider Versions and Locking](#3-provider-versions-and-locking)
- [4. Multiple Provider Instances](#4-multiple-provider-instances)
- [5. Resources: Creating Infrastructure](#5-resources-creating-infrastructure)
- [6. Resource Syntax and Structure](#6-resource-syntax-and-structure)
- [7. Resource Dependencies](#7-resource-dependencies)
- [8. Data Sources: Reading Existing Infrastructure](#8-data-sources-reading-existing-infrastructure)
- [9. Resource vs Data Source](#9-resource-vs-data-source)
- [10. Real-World Scenarios](#10-real-world-scenarios)
- [11. Commands Reference](#11-commands-reference)
- [12. Quick Reference](#12-quick-reference)

---

<details>
<summary><strong>1. What are Providers?</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Providers are plugins that let Terraform talk to APIs.

Without providers, Terraform can't create infrastructure. Providers translate your HCL code into API calls.

**The Flow:**
```
Your Code → Provider → API → Real Infrastructure
```

**Example:**
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
}
```

**What Happens:**
1. Terraform reads your code
2. AWS provider translates to EC2 API call
3. AWS creates the instance
4. Provider returns instance details
5. Terraform stores in state

---

### TF-065 — Providers are Plugins

Providers are separate binaries, not part of Terraform core.

**Location After Init:**
```
.terraform/
└── providers/
    └── registry.terraform.io/
        └── hashicorp/
            └── aws/
                └── 5.31.0/
                    └── linux_amd64/
                        └── terraform-provider-aws_v5.31.0
```

**Why Separate:**
- Providers update independently from Terraform
- Community can create providers
- Different release cycles
- Smaller Terraform binary

---

### TF-066 — Official vs Community Providers

**Official Providers (HashiCorp):**
- AWS, Azure, GCP, Kubernetes
- Well-maintained
- Comprehensive documentation
- Namespace: `hashicorp/aws`

**Partner Providers:**
- Datadog, Cloudflare, MongoDB
- Maintained by vendors
- Official support from vendor
- Namespace: `datadog/datadog`

**Community Providers:**
- Everything else
- Varying quality
- Community maintained
- Namespace: `community/provider`

**Finding Providers:**
https://registry.terraform.io/browse/providers

---

### TF-067 — Common Providers

| Provider | Use Case | Namespace |
|----------|----------|-----------|
| `aws` | AWS resources | `hashicorp/aws` |
| `azurerm` | Azure resources | `hashicorp/azurerm` |
| `google` | GCP resources | `hashicorp/google` |
| `kubernetes` | Kubernetes objects | `hashicorp/kubernetes` |
| `helm` | Helm charts | `hashicorp/helm` |
| `null` | Placeholder resources | `hashicorp/null` |
| `random` | Generate random values | `hashicorp/random` |
| `local` | Local files | `hashicorp/local` |
| `tls` | TLS certificates | `hashicorp/tls` |
| `http` | HTTP requests | `hashicorp/http` |

---

### TF-068 — Provider Responsibilities

**What Providers Do:**
- Authenticate with APIs
- Translate Terraform code to API calls
- Handle API rate limiting
- Map Terraform resources to API endpoints
- Manage resource lifecycle (CRUD operations)
- Return resource attributes

**What Providers Don't Do:**
- Store state (Terraform core handles this)
- Plan changes (Terraform core handles this)
- Manage dependencies (Terraform core handles this)

</div>

</details>

---

<details>
<summary><strong>2. Provider Configuration</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-069 — Basic Provider Block

**Syntax:**
```hcl
provider "aws" {
  region = "us-east-1"
}
```

**What This Does:**
- Declares AWS provider
- Sets region to us-east-1
- Uses default credentials

**Minimal Working Example:**
```hcl
# providers.tf
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "us-east-1"
}

# main.tf
resource "aws_instance" "app" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"
}
```

---

### TF-070 — Provider Authentication

**AWS Provider (Multiple Methods):**

**1. Environment Variables (Recommended for CI/CD):**
```bash copy
export AWS_ACCESS_KEY_ID="AKIAIOSFODNN7EXAMPLE"
export AWS_SECRET_ACCESS_KEY="wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
export AWS_DEFAULT_REGION="us-east-1"
```

```hcl
provider "aws" {
  # Credentials from env vars
}
```

**2. Shared Credentials File (Recommended for Local):**
```bash copy
# ~/.aws/credentials
[default]
aws_access_key_id = AKIAIOSFODNN7EXAMPLE
aws_secret_access_key = wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
```

```hcl
provider "aws" {
  region  = "us-east-1"
  profile = "default"  # Optional
}
```

**3. Static Credentials (NOT Recommended):**
```hcl
provider "aws" {
  region     = "us-east-1"
  access_key = "AKIAIOSFODNN7EXAMPLE"
  secret_key = "wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"
}
```

**Why Not Static:**
- Credentials in code
- Committed to Git (security risk)
- Hard to rotate

**4. IAM Role (Recommended for EC2/ECS):**
```hcl
provider "aws" {
  region = "us-east-1"
  # Automatically uses instance IAM role
}
```

---

### TF-071 — Provider Configuration Arguments

**Common Arguments:**

```hcl
provider "aws" {
  region  = "us-east-1"
  profile = "production"
  
  # Assume role
  assume_role {
    role_arn     = "arn:aws:iam::123456789012:role/TerraformRole"
    session_name = "terraform-session"
  }
  
  # Default tags
  default_tags {
    tags = {
      ManagedBy   = "Terraform"
      Environment = "production"
    }
  }
  
  # Rate limiting
  max_retries = 3
  
  # Custom endpoints (for testing)
  endpoints {
    ec2 = "http://localhost:4566"  # LocalStack
  }
}
```

---

### TF-072 — Required Providers Block

**Modern Syntax (Terraform 0.13+):**
```hcl
terraform {
  required_version = ">= 1.5.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
    random = {
      source  = "hashicorp/random"
      version = "~> 3.5"
    }
  }
}
```

**Why Required:**
- Explicitly declares providers
- Locks versions
- Documents dependencies
- Enables provider caching

**Version Constraints:**
- `= 5.0.0` → Exactly 5.0.0
- `>= 5.0.0` → 5.0.0 or newer
- `~> 5.0` → 5.0.x (any patch version)
- `~> 5.0.0` → 5.0.x only
- `>= 5.0, < 6.0` → 5.x only

**Best Practice:**
Use `~> 5.0` for minor version flexibility.

---

### TF-073 — Provider Configuration File

**Recommended Structure:**

```hcl
# providers.tf
terraform {
  required_version = ">= 1.5.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
  
  default_tags {
    tags = var.common_tags
  }
}
```

**Why Separate File:**
- Clear provider configuration
- Easy to find and update
- Doesn't clutter main.tf

</div>

</details>

---

<details>
<summary><strong>3. Provider Versions and Locking</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-074 — Version Constraints

**Constraint Operators:**

```hcl
version = "5.0.0"      # Exactly 5.0.0
version = ">= 5.0.0"   # 5.0.0 or newer
version = "<= 5.0.0"   # 5.0.0 or older
version = "~> 5.0"     # 5.x (any patch, same minor)
version = "~> 5.0.0"   # 5.0.x (same major.minor)
version = ">= 5.0, < 6.0"  # 5.x only
```

**Examples:**

```hcl
# Allow patch updates (recommended)
version = "~> 5.31.0"
# Allows: 5.31.1, 5.31.2, etc.
# Blocks: 5.32.0, 6.0.0

# Allow minor updates
version = "~> 5.0"
# Allows: 5.1.0, 5.31.0, 5.99.0
# Blocks: 6.0.0

# Pessimistic constraint
version = ">= 5.0, < 6.0"
# Allows: 5.x
# Blocks: 4.x, 6.x
```

---

### TF-075 — The Lock File (.terraform.lock.hcl)

**Purpose:**
Lock exact provider versions across team.

**Example Lock File:**
```hcl
provider "registry.terraform.io/hashicorp/aws" {
  version     = "5.31.0"
  constraints = "~> 5.0"
  hashes = [
    "h1:abc123def456...",
    "zh:789xyz321qwe...",
  ]
}
```

**What Gets Locked:**
- Exact version number
- Binary checksums
- Provider source

**When Lock File Updates:**
- `terraform init` → creates/updates lock
- `terraform init -upgrade` → upgrades to newer versions

---

### TF-076 — Upgrading Provider Versions

**Current Version:**
```bash copy
terraform providers
```

Output:
```
provider[registry.terraform.io/hashicorp/aws] 5.31.0
```

**Check for Updates:**
```bash copy
terraform init -upgrade
```

Output:
```
Upgrading hashicorp/aws from 5.31.0 to 5.35.0...
```

**Lock File Updated:**
Lock file now contains 5.35.0.

**Review Changes:**
Check provider changelog before upgrading:
```
https://github.com/hashicorp/terraform-provider-aws/releases
```

---

### TF-077 — Version Pinning Strategy

**Too Strict (Not Recommended):**
```hcl
version = "5.31.0"  # Exact version
```

**Problem:**
- No bug fixes
- No security patches
- Manual work to update

**Too Loose (Risky):**
```hcl
version = ">= 5.0"  # Any 5.x
```

**Problem:**
- Breaking changes in minor versions
- Unpredictable behavior
- Hard to reproduce issues

**Recommended (Balanced):**
```hcl
version = "~> 5.31"  # 5.31.x
```

**Benefits:**
- Automatic patch updates
- Bug fixes and security patches
- Controlled minor version changes

</div>

</details>

---

<details>
<summary><strong>4. Multiple Provider Instances</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-078 — Why Multiple Providers?

**Common Scenarios:**
- Multi-region deployments
- Multi-account AWS setup
- DR (disaster recovery) infrastructure
- Cross-region replication

**Example: Multi-Region AWS**
```hcl
# Primary region
provider "aws" {
  region = "us-east-1"
}

# DR region
provider "aws" {
  alias  = "west"
  region = "us-west-2"
}
```

---

### TF-079 — Provider Aliases

**Configuration:**
```hcl
# providers.tf
provider "aws" {
  region = "us-east-1"
  # Default provider (no alias)
}

provider "aws" {
  alias  = "west"
  region = "us-west-2"
}

provider "aws" {
  alias  = "eu"
  region = "eu-west-1"
}
```

**Using Aliases:**
```hcl
# main.tf

# Uses default provider (us-east-1)
resource "aws_instance" "primary" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
}

# Uses west alias (us-west-2)
resource "aws_instance" "dr" {
  provider = aws.west
  
  ami           = "ami-xyz789"
  instance_type = "t3.micro"
}

# Uses eu alias (eu-west-1)
resource "aws_instance" "eu" {
  provider = aws.eu
  
  ami           = "ami-def456"
  instance_type = "t3.micro"
}
```

**Key Point:**
`provider = aws.west` tells Terraform which provider to use.

---

### TF-080 — Multi-Account AWS Setup

**Configuration:**
```hcl
# providers.tf
provider "aws" {
  region = "us-east-1"
  # Uses default credentials
}

provider "aws" {
  alias  = "prod"
  region = "us-east-1"
  
  assume_role {
    role_arn = "arn:aws:iam::111111111111:role/TerraformRole"
  }
}

provider "aws" {
  alias  = "dev"
  region = "us-east-1"
  
  assume_role {
    role_arn = "arn:aws:iam::222222222222:role/TerraformRole"
  }
}
```

**Usage:**
```hcl
# Production account
resource "aws_instance" "prod_app" {
  provider = aws.prod
  
  ami           = "ami-abc123"
  instance_type = "t3.large"
}

# Dev account
resource "aws_instance" "dev_app" {
  provider = aws.dev
  
  ami           = "ami-abc123"
  instance_type = "t3.micro"
}
```

---

### TF-081 — Default Provider Behavior

**Without Alias:**
```hcl
provider "aws" {
  region = "us-east-1"
}

resource "aws_instance" "app" {
  # Implicitly uses default provider
  ami           = "ami-abc123"
  instance_type = "t3.micro"
}
```

**With Multiple Providers:**
```hcl
provider "aws" {
  region = "us-east-1"
}

provider "aws" {
  alias  = "west"
  region = "us-west-2"
}

resource "aws_instance" "app" {
  # Uses default (us-east-1) because no provider specified
  ami           = "ami-abc123"
  instance_type = "t3.micro"
}
```

**Best Practice:**
Always specify `provider` when using aliases to avoid confusion.

</div>

</details>

---

<details>
<summary><strong>5. Resources: Creating Infrastructure</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Resources are the core of Terraform. They define infrastructure to create.

---

### TF-082 — Resource Syntax

**Basic Structure:**
```hcl
resource "TYPE" "NAME" {
  argument1 = "value1"
  argument2 = "value2"
  
  nested_block {
    argument3 = "value3"
  }
}
```

**Example:**
```hcl
resource "aws_instance" "web" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  tags = {
    Name = "web-server"
  }
}
```

**Components:**
- `resource` → keyword
- `"aws_instance"` → resource type
- `"web"` → resource name (local identifier)
- `ami`, `instance_type`, `tags` → arguments
- `tags { }` → nested block

---

### TF-083 — Resource Addressing

**Format:**
```
resource_type.resource_name
```

**Examples:**
```hcl
resource "aws_instance" "web" { }
# Address: aws_instance.web

resource "aws_vpc" "main" { }
# Address: aws_vpc.main

resource "aws_subnet" "public" { }
# Address: aws_subnet.public
```

**Usage:**
```hcl
# Reference in other resources
resource "aws_instance" "app" {
  subnet_id = aws_subnet.public.id
}

# Reference in outputs
output "instance_id" {
  value = aws_instance.app.id
}
```

---

### TF-084 — Required vs Optional Arguments

**Every resource has:**
- Required arguments (must provide)
- Optional arguments (have defaults)

**Example: aws_instance**
```hcl
resource "aws_instance" "app" {
  # Required
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  # Optional
  key_name               = "my-key"
  vpc_security_group_ids = [aws_security_group.app.id]
  subnet_id              = aws_subnet.public.id
  
  tags = {
    Name = "app-server"
  }
}
```

**Finding Arguments:**
Provider documentation:
```
https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance
```

---

### TF-085 — Computed Attributes

Some attributes are only known after creation.

**Example:**
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  # id, private_ip, public_ip are computed
}
```

**Before Apply:**
```
(known after apply)
```

**After Apply:**
```hcl
# These become available
aws_instance.app.id         # "i-0a1b2c3d4e5f"
aws_instance.app.private_ip # "10.0.1.45"
aws_instance.app.public_ip  # "54.123.45.67"
```

**Usage:**
```hcl
output "instance_ip" {
  value = aws_instance.app.public_ip
}
```

---

### TF-086 — Resource Lifecycle

**Default Lifecycle:**
```
Create → Update → Destroy
```

**Terraform Determines:**
- Can resource be updated in-place? → Update
- Must resource be replaced? → Destroy, then Create

**Example: In-Place Update**
```hcl
# Change tags
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  tags = {
    Name = "app-server-v2"  # Changed
  }
}
```

Output:
```
~ tags = {
    - Name = "app-server"
    + Name = "app-server-v2"
  }
```

Updated in-place (no downtime).

**Example: Replacement Required**
```hcl
# Change AMI
resource "aws_instance" "app" {
  ami           = "ami-xyz789"  # Changed
  instance_type = "t3.micro"
}
```

Output:
```
-/+ resource "aws_instance" "app" {
      ami = "ami-abc123" -> "ami-xyz789" # forces replacement
    }
```

Instance destroyed and recreated (downtime).

</div>

</details>

---

<details>
<summary><strong>6. Resource Syntax and Structure</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-087 — Block Types

**Argument Block:**
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
}
```

**Nested Block:**
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  ebs_block_device {
    device_name = "/dev/sda1"
    volume_size = 20
  }
}
```

**Map Block:**
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  tags = {
    Name        = "app-server"
    Environment = "production"
  }
}
```

---

### TF-088 — Complex Example

**Real-World EC2 Instance:**
```hcl
resource "aws_instance" "app" {
  # Required
  ami           = var.ami_id
  instance_type = var.instance_type
  
  # Network
  subnet_id                   = aws_subnet.private.id
  vpc_security_group_ids      = [aws_security_group.app.id]
  associate_public_ip_address = false
  
  # Storage
  root_block_device {
    volume_type           = "gp3"
    volume_size           = 20
    encrypted             = true
    delete_on_termination = true
  }
  
  ebs_block_device {
    device_name           = "/dev/sdf"
    volume_size           = 100
    volume_type           = "gp3"
    encrypted             = true
    delete_on_termination = false
  }
  
  # IAM
  iam_instance_profile = aws_iam_instance_profile.app.name
  
  # User data
  user_data = file("${path.module}/user-data.sh")
  
  # Tags
  tags = {
    Name        = "app-server"
    Environment = var.environment
    ManagedBy   = "Terraform"
  }
  
  # Lifecycle
  lifecycle {
    create_before_destroy = true
    ignore_changes        = [user_data]
  }
}
```

---

### TF-089 — Meta-Arguments

**Special arguments that work on all resources:**

**1. depends_on**
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  depends_on = [aws_iam_role_policy.app]
}
```

Forces explicit dependency.

**2. count**
```hcl
resource "aws_instance" "app" {
  count = 3
  
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  tags = {
    Name = "app-${count.index}"
  }
}
```

Creates 3 instances: app-0, app-1, app-2

**3. for_each**
```hcl
resource "aws_instance" "app" {
  for_each = toset(["web", "api", "worker"])
  
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  tags = {
    Name = "${each.key}-server"
  }
}
```

Creates: web-server, api-server, worker-server

**4. provider**
```hcl
resource "aws_instance" "dr" {
  provider = aws.west
  
  ami           = "ami-abc123"
  instance_type = "t3.micro"
}
```

Uses specific provider.

**5. lifecycle**
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  lifecycle {
    create_before_destroy = true
    prevent_destroy       = true
    ignore_changes        = [ami, user_data]
  }
}
```

Controls resource behavior.

*We'll cover count, for_each, and lifecycle deeply in File 05 and File 09.*

---

### TF-090 — Referencing Resources

**Accessing Attributes:**
```hcl
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "public" {
  vpc_id     = aws_vpc.main.id  # Reference VPC ID
  cidr_block = "10.0.1.0/24"
}

resource "aws_instance" "app" {
  subnet_id = aws_subnet.public.id  # Reference subnet ID
  ami       = "ami-abc123"
}
```

**Syntax:**
```
<resource_type>.<resource_name>.<attribute>
```

**Chaining References:**
```hcl
output "instance_subnet_vpc_id" {
  value = aws_instance.app.subnet_id
  # This gives subnet ID, not VPC ID
}

# For VPC ID, reference the VPC directly
output "vpc_id" {
  value = aws_vpc.main.id
}
```

</div>

</details>

---

<details>
<summary><strong>7. Resource Dependencies</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-091 — Implicit Dependencies

Terraform automatically detects dependencies from references.

**Example:**
```hcl
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "public" {
  vpc_id     = aws_vpc.main.id  # Implicit dependency
  cidr_block = "10.0.1.0/24"
}

resource "aws_instance" "app" {
  subnet_id = aws_subnet.public.id  # Implicit dependency
  ami       = "ami-abc123"
}
```

**Dependency Graph:**
```
aws_vpc.main
    ↓
aws_subnet.public
    ↓
aws_instance.app
```

**Creation Order:**
1. VPC created first
2. Subnet created after VPC
3. Instance created after subnet

**Destruction Order:**
Reverse order:
1. Instance destroyed first
2. Subnet destroyed after instance
3. VPC destroyed last

---

### TF-092 — Explicit Dependencies (depends_on)

Sometimes dependencies aren't obvious from references.

**When to Use depends_on:**
- Dependency on resource behavior, not attributes
- Ordering requirements
- Hidden dependencies

**Example:**
```hcl
resource "aws_iam_role" "app" {
  name = "app-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [{
      Effect = "Allow"
      Principal = {
        Service = "ec2.amazonaws.com"
      }
      Action = "sts:AssumeRole"
    }]
  })
}

resource "aws_iam_role_policy" "app" {
  role   = aws_iam_role.app.name
  policy = jsonencode({ /* policy */ })
}

resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  # Instance needs policy to be attached
  depends_on = [aws_iam_role_policy.app]
}
```

**Why:**
Instance doesn't reference the policy directly, but needs it to exist.

---

### TF-093 — Viewing Dependencies

**Dependency Graph:**
```bash copy
terraform graph | dot -Tpng > graph.png
```

Requires Graphviz installed.

**Text Output:**
```bash copy
terraform graph
```

Shows DOT format graph.

**Use Case:**
Visualizing complex infrastructure dependencies.

---

### TF-094 — Circular Dependencies (Error)

**Invalid:**
```hcl
resource "aws_security_group" "web" {
  ingress {
    from_port       = 443
    to_port         = 443
    security_groups = [aws_security_group.app.id]  # References app
  }
}

resource "aws_security_group" "app" {
  ingress {
    from_port       = 8080
    to_port         = 8080
    security_groups = [aws_security_group.web.id]  # References web
  }
}
```

**Error:**
```
Error: Cycle: aws_security_group.web, aws_security_group.app
```

**Fix:**
Use security group rules instead:
```hcl
resource "aws_security_group" "web" {
  name = "web"
}

resource "aws_security_group" "app" {
  name = "app"
}

resource "aws_security_group_rule" "web_to_app" {
  type                     = "ingress"
  from_port                = 8080
  to_port                  = 8080
  protocol                 = "tcp"
  security_group_id        = aws_security_group.app.id
  source_security_group_id = aws_security_group.web.id
}

resource "aws_security_group_rule" "app_to_web" {
  type                     = "ingress"
  from_port                = 443
  to_port                  = 443
  protocol                 = "tcp"
  security_group_id        = aws_security_group.web.id
  source_security_group_id = aws_security_group.app.id
}
```

</div>

</details>

---

<details>
<summary><strong>8. Data Sources: Reading Existing Infrastructure</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Data sources read information from existing infrastructure.

---

### TF-095 — What are Data Sources?

**Resources:** Create infrastructure
**Data Sources:** Read existing infrastructure

**Example:**
```hcl
# Read existing VPC (not managed by Terraform)
data "aws_vpc" "existing" {
  id = "vpc-abc123"
}

# Use its attributes
resource "aws_subnet" "new" {
  vpc_id     = data.aws_vpc.existing.id
  cidr_block = "10.0.1.0/24"
}
```

**Key Point:**
Data sources don't create or modify infrastructure. They only read.

---

### TF-096 — Data Source Syntax

**Structure:**
```hcl
data "TYPE" "NAME" {
  filter_argument = "value"
}
```

**Example:**
```hcl
data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]
  
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}
```

**Referencing:**
```hcl
resource "aws_instance" "app" {
  ami = data.aws_ami.amazon_linux.id  # Use AMI from data source
  instance_type = "t3.micro"
}
```

**Address Format:**
```
data.<type>.<name>.<attribute>
```

---

### TF-097 — Common Data Sources

**AWS AMI (Latest Amazon Linux):**
```hcl
data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]
  
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}
```

**AWS Availability Zones:**
```hcl
data "aws_availability_zones" "available" {
  state = "available"
}

# Use in resource
resource "aws_subnet" "public" {
  count             = 2
  availability_zone = data.aws_availability_zones.available.names[count.index]
  cidr_block        = cidrsubnet("10.0.0.0/16", 8, count.index)
}
```

**AWS VPC (Existing):**
```hcl
data "aws_vpc" "selected" {
  filter {
    name   = "tag:Name"
    values = ["production"]
  }
}
```

**AWS Subnet (Existing):**
```hcl
data "aws_subnet" "selected" {
  filter {
    name   = "tag:Environment"
    values = ["production"]
  }
}
```

**AWS Caller Identity (Current Account):**
```hcl
data "aws_caller_identity" "current" {}

output "account_id" {
  value = data.aws_caller_identity.current.account_id
}
```

**AWS Region (Current):**
```hcl
data "aws_region" "current" {}

output "region" {
  value = data.aws_region.current.name
}
```

---

### TF-098 — Using Data Sources for Dynamic Values

**Get Latest AMI:**
```hcl
data "aws_ami" "latest_ubuntu" {
  most_recent = true
  owners      = ["099720109477"]  # Canonical
  
  filter {
    name   = "name"
    values = ["ubuntu/images/hvm-ssd/ubuntu-focal-20.04-amd64-server-*"]
  }
}

resource "aws_instance" "app" {
  ami           = data.aws_ami.latest_ubuntu.id  # Always latest
  instance_type = "t3.micro"
}
```

**Get All AZs:**
```hcl
data "aws_availability_zones" "available" {
  state = "available"
}

locals {
  az_count = length(data.aws_availability_zones.available.names)
}
```

---

### TF-099 — Data Sources vs Remote State

**Data Source (Reading from Provider):**
```hcl
data "aws_vpc" "network" {
  id = "vpc-abc123"
}
```

Queries AWS API for VPC details.

**Remote State (Reading from Another Terraform Project):**
```hcl
data "terraform_remote_state" "network" {
  backend = "s3"
  config = {
    bucket = "terraform-state"
    key    = "network/terraform.tfstate"
    region = "us-east-1"
  }
}

# Access outputs from network project
subnet_id = data.terraform_remote_state.network.outputs.subnet_id
```

Reads another Terraform project's outputs.

*We'll cover remote state deeply in File 08.*

</div>

</details>

---

<details>
<summary><strong>9. Resource vs Data Source</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-100 — Key Differences

| Aspect | Resource | Data Source |
|--------|----------|-------------|
| Purpose | Create/manage infrastructure | Read existing infrastructure |
| Keyword | `resource` | `data` |
| State | Tracked in state | Not tracked in state |
| Lifecycle | Create, update, destroy | Read only |
| Example | `resource "aws_instance"` | `data "aws_ami"` |

---

### TF-101 — When to Use Each

**Use Resources When:**
- Creating new infrastructure
- Managing infrastructure lifecycle
- Terraform should own the resource

**Example:**
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
}
```

**Use Data Sources When:**
- Reading existing infrastructure
- Infrastructure managed elsewhere
- Need dynamic values (latest AMI, etc.)
- Querying cloud metadata

**Example:**
```hcl
data "aws_vpc" "existing" {
  default = true
}

resource "aws_subnet" "new" {
  vpc_id = data.aws_vpc.existing.id  # Use existing VPC
  cidr_block = "10.0.1.0/24"
}
```

---

### TF-102 — Combined Example

**Scenario:**
Deploy EC2 in existing VPC with latest AMI.

```hcl
# Data: Read existing VPC
data "aws_vpc" "production" {
  filter {
    name   = "tag:Name"
    values = ["production"]
  }
}

# Data: Read existing subnet
data "aws_subnet" "public" {
  vpc_id = data.aws_vpc.production.id
  
  filter {
    name   = "tag:Type"
    values = ["public"]
  }
}

# Data: Get latest Amazon Linux AMI
data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]
  
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}

# Resource: Create new security group
resource "aws_security_group" "app" {
  name_prefix = "app-"
  vpc_id      = data.aws_vpc.production.id
  
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }
}

# Resource: Create new EC2 instance
resource "aws_instance" "app" {
  ami                    = data.aws_ami.amazon_linux.id
  instance_type          = "t3.micro"
  subnet_id              = data.aws_subnet.public.id
  vpc_security_group_ids = [aws_security_group.app.id]
  
  tags = {
    Name = "app-server"
  }
}
```

**What This Does:**
- Reads existing VPC and subnet (data sources)
- Gets latest AMI (data source)
- Creates new security group (resource)
- Creates new EC2 instance (resource)

</div>

</details>

---

<details>
<summary><strong>10. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Provider Version Conflict

**Symptom:**
```
Error: Inconsistent dependency lock file
```

**Cause:**
Lock file specifies different provider version than code.

**Fix:**
```bash copy
# Update lock file to match code
terraform init -upgrade

# Or force specific version
terraform init -upgrade=true
```

**Prevention:**
Commit `.terraform.lock.hcl` to Git.

---

### Scenario 2: Wrong Provider Region

**Symptom:**
Resources created in wrong region.

**Cause:**
Provider region misconfigured.

**Fix:**
```hcl
# Before
provider "aws" {
  region = "us-west-1"  # Wrong
}

# After
provider "aws" {
  region = "us-east-1"  # Correct
}
```

```bash copy
# Destroy resources in wrong region
AWS_REGION=us-west-1 terraform destroy

# Recreate in correct region
terraform apply
```

**Prevention:**
Use variables for region:
```hcl
provider "aws" {
  region = var.aws_region
}
```

---

### Scenario 3: Data Source Returns Multiple Results

**Symptom:**
```
Error: multiple results found, expected 1
```

**Cause:**
Data source filter too broad.

**Before:**
```hcl
data "aws_subnet" "selected" {
  filter {
    name   = "vpc-id"
    values = [aws_vpc.main.id]
  }
}
```

Returns all subnets in VPC (error if more than one).

**After:**
```hcl
data "aws_subnet" "selected" {
  filter {
    name   = "vpc-id"
    values = [aws_vpc.main.id]
  }
  
  filter {
    name   = "tag:Name"
    values = ["public-1"]
  }
}
```

Now returns specific subnet.

---

### Scenario 4: Resource Depends on Data Source

**Situation:**
Need to use latest AMI for instance.

**Solution:**
```hcl
data "aws_ami" "latest" {
  most_recent = true
  owners      = ["amazon"]
  
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
}

resource "aws_instance" "app" {
  ami           = data.aws_ami.latest.id  # Implicit dependency
  instance_type = "t3.micro"
}
```

**Flow:**
1. Terraform queries AWS for latest AMI
2. Data source returns AMI ID
3. Instance created with that AMI ID

---

### Scenario 5: Multi-Region Deployment

**Situation:**
Deploy infrastructure in two regions.

**Solution:**
```hcl
# providers.tf
provider "aws" {
  alias  = "primary"
  region = "us-east-1"
}

provider "aws" {
  alias  = "dr"
  region = "us-west-2"
}

# main.tf

# Primary region resources
resource "aws_vpc" "primary" {
  provider   = aws.primary
  cidr_block = "10.0.0.0/16"
}

resource "aws_instance" "primary" {
  provider = aws.primary
  
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  vpc_id        = aws_vpc.primary.id
}

# DR region resources
resource "aws_vpc" "dr" {
  provider   = aws.dr
  cidr_block = "10.1.0.0/16"
}

resource "aws_instance" "dr" {
  provider = aws.dr
  
  ami           = "ami-xyz789"
  instance_type = "t3.micro"
  vpc_id        = aws_vpc.dr.id
}
```

---

### Scenario 6: Finding Resource Documentation

**Situation:**
Don't know what arguments a resource accepts.

**Solution:**
```
https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/<resource_name>
```

**Example:**
For `aws_instance`:
```
https://registry.terraform.io/providers/hashicorp/aws/latest/docs/resources/instance
```

**CLI Help:**
```bash copy
terraform providers schema -json | jq '.provider_schemas'
```

Shows all available resources and arguments.

</div>

</details>

---

<details>
<summary><strong>11. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
terraform providers
```
List required providers and versions

```bash copy
terraform providers schema
```
Show provider schemas (resources, data sources, arguments)

```bash copy
terraform providers schema -json
```
JSON output of schemas

```bash copy
terraform providers lock
```
Update lock file with current provider versions

```bash copy
terraform init
```
Download and install providers

```bash copy
terraform init -upgrade
```
Upgrade providers to latest allowed versions

```bash copy
terraform init -get=false
```
Skip module download (providers still downloaded)

```bash copy
terraform init -plugin-dir=/custom/path
```
Use custom provider plugin directory

```bash copy
terraform graph
```
Generate dependency graph (DOT format)

```bash copy
terraform graph | dot -Tpng > graph.png
```
Generate visual dependency graph (requires Graphviz)

```bash copy
terraform state list | grep aws_instance
```
List only instance resources

```bash copy
terraform show -json | jq '.values.root_module.resources[] | select(.type=="aws_instance")'
```
Query specific resource types in state

</div>

</details>

---

<details>
<summary><strong>12. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Providers = plugins that talk to APIs
- Resources = infrastructure to create/manage
- Data Sources = read existing infrastructure
- Providers are separate from Terraform core
- Always lock provider versions

---

**Provider Configuration:**

```hcl
terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = "us-east-1"
}
```

---

**Version Constraints:**

| Constraint | Meaning | Example |
|------------|---------|---------|
| `= 5.0.0` | Exact version | 5.0.0 only |
| `>= 5.0.0` | Minimum version | 5.0.0 or newer |
| `~> 5.0` | Minor updates | 5.x (not 6.0) |
| `~> 5.0.0` | Patch updates | 5.0.x only |
| `>= 5.0, < 6.0` | Range | 5.x only |

---

**Resource Syntax:**

```hcl
resource "TYPE" "NAME" {
  argument1 = "value1"
  argument2 = "value2"
}
```

**Addressing:**
```
resource_type.resource_name.attribute
```

**Example:**
```
aws_instance.app.id
aws_instance.app.public_ip
```

---

**Data Source Syntax:**

```hcl
data "TYPE" "NAME" {
  filter_argument = "value"
}
```

**Addressing:**
```
data.type.name.attribute
```

**Example:**
```
data.aws_ami.latest.id
data.aws_vpc.selected.cidr_block
```

---

**Resource vs Data Source:**

| Aspect | Resource | Data Source |
|--------|----------|-------------|
| Purpose | Create infrastructure | Read infrastructure |
| Keyword | `resource` | `data` |
| State | Tracked | Not tracked |
| Lifecycle | Create/Update/Destroy | Read only |
| Prefix | None | `data.` |

---

**Meta-Arguments (All Resources):**

- `depends_on` = explicit dependencies
- `count` = create multiple copies
- `for_each` = create multiple with keys
- `provider` = specify provider instance
- `lifecycle` = control behavior

---

**Dependencies:**

**Implicit (Automatic):**
```hcl
subnet_id = aws_subnet.public.id  # Auto-detected
```

**Explicit (Manual):**
```hcl
depends_on = [aws_iam_role_policy.app]
```

---

**Common Data Sources:**

```hcl
# Latest AMI
data "aws_ami" "latest" {
  most_recent = true
  owners      = ["amazon"]
}

# Availability Zones
data "aws_availability_zones" "available" {
  state = "available"
}

# Current Account ID
data "aws_caller_identity" "current" {}

# Current Region
data "aws_region" "current" {}

# Existing VPC
data "aws_vpc" "selected" {
  filter {
    name   = "tag:Name"
    values = ["production"]
  }
}
```

---

**Multiple Providers (Aliases):**

```hcl
provider "aws" {
  region = "us-east-1"  # Default
}

provider "aws" {
  alias  = "west"
  region = "us-west-2"
}

resource "aws_instance" "dr" {
  provider = aws.west  # Use west provider
}
```

---

**What's Next:**
Now that you understand providers, resources, and data sources — the building blocks of Terraform — the next file covers Variables, Outputs, and Locals: how to make your infrastructure code flexible and reusable.

</div>

</details>

---

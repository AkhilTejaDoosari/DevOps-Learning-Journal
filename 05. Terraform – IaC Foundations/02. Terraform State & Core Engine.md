# **02. Terraform State & The Core Engine — How Terraform Remembers and Decides**

> *A simple, practical chapter on how Terraform thinks, remembers, and decides what to change.*

---

## Table of Contents

1. [Why Terraform Needs Memory](#1-why-terraform-needs-memory)
2. [What State Actually Contains](#2-what-state-actually-contains)
3. [How Terraform Builds Its Plan](#3-how-terraform-builds-its-plan)
4. [State Drift](#4-state-drift)
5. [Why You Shouldn’t Edit State](#5-why-you-shouldnt-edit-state)
6. [Refreshing vs Planning](#6-refreshing-vs-planning)
7. [Diagrams](#7-diagrams)

---

<details>
<summary><strong>1. Why Terraform Needs Memory</strong></summary>

Terraform doesn’t run inside AWS — it stands outside, reading your configuration and checking what already exists. To make smart decisions in that position, it needs a way to remember what it created last time so every run doesn’t feel like starting from scratch.

That memory lives in **terraform.tfstate**.

State is Terraform’s notebook.
It quietly records the details AWS returns — resource IDs, attributes, and relationships — so Terraform can make accurate decisions on the next run. Without it, Terraform would end up guessing, and guessing isn’t reliable when infrastructure is involved.

</details>

---

<details>
<summary><strong>2. What State Actually Contains</strong></summary>

State is simply a snapshot of your infrastructure from Terraform’s perspective. It isn’t complicated — just the information Terraform needs to stay grounded.

For a VPC, state might hold:  
* the VPC ID   
* the CIDR block   
* AWS-generated attributes   

For an EC2 instance, it remembers:  
* the instance ID  
* the IPs  
* the AMI  
* and settings Terraform applied  

This gives Terraform the full picture before it decides anything.

</details>

---

<details>
<summary><strong>3. How Terraform Builds Its Plan</strong></summary>

`terraform plan` is Terraform thinking out loud.  

It reads your `.tf` files — what you want.  
It reads the state — what it remembers.  
Then it asks AWS — what actually exists right now.  

With those three inputs, Terraform compares everything and builds a plan showing the exact actions needed. Nothing more, nothing less.  

The plan isn’t a guess — it’s simply the difference between intention and reality.  
If nothing changed, the plan shows zero changes.  
If something changed, the plan shows exactly what.  

</details>

---

<details>
<summary><strong>4. State Drift</strong></summary>

If you modify infrastructure directly in AWS — deleting an instance, tweaking a security group, or changing a subnet — Terraform won’t automatically know. This creates **drift**, a mismatch between the state file and real AWS.

On the next run, Terraform notices the difference and responds:  
* recreate missing resources  
* update changed settings  
* or remove things that don’t belong  

Drift isn’t a problem by itself — it’s just something Terraform needs to correct. Keeping most changes inside Terraform helps avoid surprises.

</details>

---

<details>
<summary><strong>5. Why You Shouldn’t Edit State</strong></summary>

The state file is readable, but it isn’t meant to be edited manually. Small mistakes — even a single missing attribute — can break Terraform’s understanding of your setup.  

If something in state needs updating, Terraform provides safer tools:  
* refresh  
* taint
* import
* apply

Let Terraform manage its own memory.
It’s designed to do that better than we can.

</details>

---

<details>
<summary><strong>6. Refreshing vs Planning</strong></summary>

Before planning changes, Terraform often needs to update its understanding of AWS.  

`terraform refresh` updates the state so Terraform knows the current reality.  
`terraform plan` compares your blueprint against that updated state.  

Refreshing answers, “What exists right now?”  
Planning answers, “Given what exists, what should I change?”  

These two steps keep the entire process consistent and predictable.  

</details>

---

<details>
<summary><strong>7. Diagrams</strong></summary>

### **How Terraform Uses State**

```
      terraform.tfstate
             |
             v
      Terraform Engine
       (Reads + Compares)
             |
             v
      AWS Infrastructure
             ^
             |
      Your .tf Files
```

State sits between your configuration and the real cloud. It gives Terraform a stable reference of what already exists, so it doesn’t rebuild or destroy things blindly. Terraform looks at your files to see what you want, checks the state to see what it remembers, and then confirms everything with AWS before acting. With that full picture, Terraform can make deliberate, safe decisions every time.

</details>

---
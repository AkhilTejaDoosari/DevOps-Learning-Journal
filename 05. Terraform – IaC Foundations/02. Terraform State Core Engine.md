# **02. Terraform State & Core Engine — How Terraform Tracks Reality**
> Understanding state: the most critical concept in Terraform.

---

## Table of Contents
- [1. Why State Exists](#1-why-state-exists)
- [2. What State Contains](#2-what-state-contains)
- [3. State File Structure](#3-state-file-structure)
- [4. How Terraform Uses State](#4-how-terraform-uses-state)
- [5. The Three-Way Merge](#5-the-three-way-merge)
- [6. State Commands](#6-state-commands)
- [7. State Locking](#7-state-locking)
- [8. Local vs Remote State](#8-local-vs-remote-state)
- [9. State Drift and Refresh](#9-state-drift-and-refresh)
- [10. Real-World Scenarios](#10-real-world-scenarios)
- [11. Commands Reference](#11-commands-reference)
- [12. Quick Reference](#12-quick-reference)

---

<details>
<summary><strong>1. Why State Exists</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

State is how Terraform remembers what it built.

Without state, Terraform would be useless. It couldn't:
- Update existing resources
- Delete what it created
- Track dependencies
- Know what infrastructure it manages

**The Problem Without State:**
```bash
# First run
terraform apply  # Creates EC2 instance

# Second run (no state)
terraform apply  # Creates ANOTHER EC2 instance (duplicate!)
```

**With State:**
```bash
# First run
terraform apply  # Creates EC2, saves to state

# Second run (with state)
terraform apply  # Sees instance exists, does nothing
```

State enables idempotency — running the same code produces the same result.

---

### TF-022 — State is the Source of Truth

Think of state as Terraform's memory:

```
┌─────────────────────────────────────────┐
│     Your .tf Files (Desired State)     │
├─────────────────────────────────────────┤
│   terraform.tfstate (Current State)    │
├─────────────────────────────────────────┤
│     Real Infrastructure (Reality)       │
└─────────────────────────────────────────┘
```

**The Relationship:**
- Your code = what you WANT
- State file = what Terraform THINKS exists
- Real infrastructure = what ACTUALLY exists

Terraform compares your code to state, then makes API calls to match reality.

---

### TF-023 — What Happens Without State

**Example: Creating an EC2 instance**

**Without state:**
```bash
# Day 1
terraform apply  # Creates i-abc123

# Day 2 (state file lost)
terraform apply  # Creates i-def456 (duplicate!)

# Day 3
terraform destroy  # Deletes i-def456, but i-abc123 is orphaned
```

**With state:**
```bash
# Day 1
terraform apply  # Creates i-abc123, records in state

# Day 2
terraform apply  # Checks state, sees i-abc123 exists, no changes

# Day 3
terraform destroy  # Reads state, deletes i-abc123
```

State prevents orphaned resources and duplicate infrastructure.

---

### TF-024 — State Enables Updates

State tracks resource attributes so Terraform can update them.

**Example:**
```hcl
# Initial code
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
}
```

After apply, state records:
```json
{
  "id": "i-0a1b2c3d4e5f",
  "ami": "ami-abc123",
  "instance_type": "t3.micro",
  "private_ip": "10.0.1.45"
}
```

Now you change instance type:
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.small"  # Changed
}
```

**Terraform's Logic:**
1. Reads state → sees `instance_type = "t3.micro"`
2. Reads code → sees `instance_type = "t3.small"`
3. Plans update → change instance type
4. Applies → calls AWS API to modify instance
5. Updates state → records new instance_type

Without state, Terraform wouldn't know the instance exists or what needs updating.

</div>

</details>

---

<details>
<summary><strong>2. What State Contains</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-025 — State File Contents

State stores everything Terraform needs to manage infrastructure.

**Key Information:**
- Resource IDs (EC2 instance ID, VPC ID, etc.)
- Resource attributes (IP addresses, DNS names, etc.)
- Resource metadata (dependencies, provider config)
- Outputs from modules
- Data source results

**Example State (simplified):**
```json
{
  "version": 4,
  "terraform_version": "1.9.0",
  "serial": 3,
  "lineage": "abc-123-def-456",
  "resources": [
    {
      "mode": "managed",
      "type": "aws_instance",
      "name": "app",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "id": "i-0a1b2c3d4e5f",
            "ami": "ami-abc123",
            "instance_type": "t3.micro",
            "private_ip": "10.0.1.45",
            "public_ip": "54.123.45.67",
            "subnet_id": "subnet-xyz789",
            "vpc_security_group_ids": ["sg-abc123"]
          }
        }
      ]
    }
  ]
}
```

---

### TF-026 — Why State Contains Sensitive Data

State files often contain:
- Database passwords
- Private keys
- API tokens
- Private IP addresses
- Internal architecture details

**Example:**
```json
{
  "type": "aws_db_instance",
  "attributes": {
    "password": "SuperSecret123!",  // ← Sensitive
    "username": "admin",
    "endpoint": "mydb.abc123.us-east-1.rds.amazonaws.com"
  }
}
```

**Critical Rules:**
1. Never commit state to Git
2. Use remote state with encryption
3. Restrict access to state files
4. Use `.gitignore` properly

---

### TF-027 — State Versioning

Every state file has a version number.

**Fields:**
- `version` → state file format version (currently 4)
- `terraform_version` → Terraform version that wrote state
- `serial` → increments on every state change
- `lineage` → unique ID for this state file

**Why Serial Matters:**
Prevents concurrent modifications.

```
# User A
serial: 5 → applies change → serial: 6

# User B (still on serial 5)
serial: 5 → tries to apply → Terraform detects conflict
```

State locking (covered later) handles this automatically.

---

### TF-028 — Resource Dependencies in State

State tracks implicit dependencies.

**Example:**
```hcl
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "public" {
  vpc_id     = aws_vpc.main.id  # Depends on VPC
  cidr_block = "10.0.1.0/24"
}
```

**State Records:**
```json
{
  "type": "aws_subnet",
  "dependencies": [
    "aws_vpc.main"
  ]
}
```

**Why This Matters:**
Terraform knows to:
1. Create VPC first
2. Then create subnet
3. Delete subnet before VPC

Without dependency tracking, deletions would fail.

</div>

</details>

---

<details>
<summary><strong>3. State File Structure</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-029 — Local State File

By default, Terraform stores state locally.

**Location:**
```
project/
├── main.tf
├── terraform.tfstate         # Current state
└── terraform.tfstate.backup  # Previous state
```

**terraform.tfstate:**
Contains current infrastructure state.

**terraform.tfstate.backup:**
Previous version (before last apply).
Useful for manual recovery.

---

### TF-030 — State File Format

State is JSON (version 4).

**Structure:**
```json
{
  "version": 4,
  "terraform_version": "1.9.0",
  "serial": 1,
  "lineage": "abc-123-def-456",
  "outputs": {},
  "resources": [
    {
      "mode": "managed",
      "type": "aws_instance",
      "name": "app",
      "provider": "provider[\"registry.terraform.io/hashicorp/aws\"]",
      "instances": [
        {
          "schema_version": 1,
          "attributes": {
            "id": "i-abc123",
            "ami": "ami-xyz789",
            "instance_type": "t3.micro"
          },
          "dependencies": []
        }
      ]
    }
  ]
}
```

**Key Sections:**
- `version` → state format version
- `terraform_version` → Terraform version used
- `serial` → change counter
- `lineage` → unique state identifier
- `resources` → all managed resources
- `outputs` → output values

---

### TF-031 — Reading State (Don't Edit Directly)

You can inspect state, but **never edit it manually**.

**View State:**
```bash copy
terraform show
```

Shows human-readable state.

**View Specific Resource:**
```bash copy
terraform state show aws_instance.app
```

**Why Not Edit State Directly:**
- Easy to corrupt
- Break dependencies
- Cause state/reality mismatch
- Serial number issues

Instead, use `terraform state` commands (covered later).

---

### TF-032 — State Backup Files

Terraform creates backups automatically.

**After First Apply:**
```
terraform.tfstate
```

**After Second Apply:**
```
terraform.tfstate         # Current
terraform.tfstate.backup  # Previous
```

**Each apply:**
- Current state → moved to `.backup`
- New state → written to `terraform.tfstate`

**Manual Recovery:**
```bash copy
# If state corrupted
cp terraform.tfstate.backup terraform.tfstate
```

**Better Approach:**
Use remote state with versioning (covered in File 08).

</div>

</details>

---

<details>
<summary><strong>4. How Terraform Uses State</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-033 — The Terraform Execution Flow

Every Terraform command follows this pattern:

```
1. Read .tf files (desired state)
   ↓
2. Read terraform.tfstate (current state)
   ↓
3. Refresh (query real infrastructure)
   ↓
4. Calculate diff (plan)
   ↓
5. Execute changes (apply)
   ↓
6. Update state file
```

---

### TF-034 — Plan Phase (Read + Compare)

**What happens during `terraform plan`:**

```
Step 1: Read Code
--------
resource "aws_instance" "app" {
  instance_type = "t3.small"
}

Step 2: Read State
--------
{
  "type": "aws_instance",
  "attributes": {
    "id": "i-abc123",
    "instance_type": "t3.micro"
  }
}

Step 3: Compare
--------
Code says: t3.small
State says: t3.micro
→ Plan: Update instance_type
```

**Output:**
```
~ resource "aws_instance" "app" {
    ~ instance_type = "t3.micro" -> "t3.small"
  }

Plan: 0 to add, 1 to change, 0 to destroy.
```

---

### TF-035 — Apply Phase (Execute + Update State)

**What happens during `terraform apply`:**

```
Step 1: Execute Plan
--------
Call AWS API: ModifyInstanceType(i-abc123, "t3.small")

Step 2: Update State
--------
{
  "type": "aws_instance",
  "attributes": {
    "id": "i-abc123",
    "instance_type": "t3.small"  # Updated
  }
}

Step 3: Write State File
--------
Save updated state to terraform.tfstate
Backup old state to terraform.tfstate.backup
```

---

### TF-036 — Refresh Phase (Sync with Reality)

Before planning, Terraform refreshes state.

**Default Behavior (Terraform 1.5+):**
Refresh happens automatically during plan.

**What Refresh Does:**
Queries real infrastructure and updates state.

**Example:**
```
State says:    instance_type = "t3.micro"
Reality says:  instance_type = "t3.small"  (someone changed it manually)

After refresh: State updated to "t3.small"
```

**Manual Refresh:**
```bash copy
terraform refresh
```

**Why Refresh Matters:**
Detects drift (manual changes outside Terraform).

---

### TF-037 — State During Resource Creation

**Before Apply:**
```json
{
  "resources": []
}
```

State is empty.

**After Apply:**
```json
{
  "resources": [
    {
      "type": "aws_instance",
      "name": "app",
      "instances": [
        {
          "attributes": {
            "id": "i-abc123",
            "instance_type": "t3.micro",
            "private_ip": "10.0.1.45"
          }
        }
      ]
    }
  ]
}
```

State now tracks the instance.

**Key Point:**
Terraform doesn't know about resources until they're in state.

</div>

</details>

---

<details>
<summary><strong>5. The Three-Way Merge</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-038 — Understanding the Three Sources

Terraform reconciles three sources of truth:

```
┌─────────────────────────────────────────┐
│  1. Configuration (.tf files)          │  What you WANT
│     "instance_type = t3.medium"         │
├─────────────────────────────────────────┤
│  2. State (terraform.tfstate)           │  What Terraform THINKS exists
│     "instance_type = t3.micro"          │
├─────────────────────────────────────────┤
│  3. Reality (AWS API)                   │  What ACTUALLY exists
│     "instance_type = t3.small"          │
└─────────────────────────────────────────┘
```

**Terraform's Job:**
Make reality match configuration, updating state along the way.

---

### TF-039 — Scenario: No Drift (Normal Case)

**Configuration:**
```hcl
instance_type = "t3.micro"
```

**State:**
```json
"instance_type": "t3.micro"
```

**Reality:**
```
instance_type = "t3.micro"
```

**Result:**
```
No changes. Infrastructure is up-to-date.
```

Everything matches. Terraform does nothing.

---

### TF-040 — Scenario: Configuration Changed

**Configuration:**
```hcl
instance_type = "t3.small"  # Changed
```

**State:**
```json
"instance_type": "t3.micro"
```

**Reality:**
```
instance_type = "t3.micro"
```

**Terraform Plan:**
```
~ instance_type = "t3.micro" -> "t3.small"

Plan: 0 to add, 1 to change, 0 to destroy.
```

**After Apply:**
- Reality updated to t3.small
- State updated to t3.small
- Configuration unchanged (t3.small)

---

### TF-041 — Scenario: Manual Change (Drift)

**Configuration:**
```hcl
instance_type = "t3.micro"
```

**State:**
```json
"instance_type": "t3.micro"
```

**Reality:**
```
instance_type = "t3.small"  # Someone changed it manually!
```

**Terraform Refresh (automatic during plan):**
State updated to match reality:
```json
"instance_type": "t3.small"
```

**Terraform Plan:**
```
~ instance_type = "t3.small" -> "t3.micro"

Plan: 0 to add, 1 to change, 0 to destroy.
```

Terraform will revert to configuration (t3.micro).

**Why:**
Configuration is the source of truth, not reality.

---

### TF-042 — Scenario: Resource Deleted Manually

**Configuration:**
```hcl
resource "aws_instance" "app" {
  instance_type = "t3.micro"
}
```

**State:**
```json
{
  "id": "i-abc123",
  "instance_type": "t3.micro"
}
```

**Reality:**
```
Instance i-abc123 does not exist  # Deleted in AWS console
```

**Terraform Refresh:**
Detects resource missing.

**Terraform Plan:**
```
+ resource "aws_instance" "app" {
    instance_type = "t3.micro"
  }

Plan: 1 to add, 0 to change, 0 to destroy.
```

Terraform will recreate the instance.

**Lesson:**
Never delete Terraform-managed resources manually.

</div>

</details>

---

<details>
<summary><strong>6. State Commands</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-043 — terraform state list

List all resources in state.

```bash copy
terraform state list
```

**Example Output:**
```
aws_vpc.main
aws_subnet.public
aws_subnet.private
aws_instance.app
aws_security_group.app
```

**Use Case:**
Quick inventory of managed resources.

---

### TF-044 — terraform state show

Show detailed attributes of a resource.

```bash copy
terraform state show aws_instance.app
```

**Example Output:**
```
# aws_instance.app:
resource "aws_instance" "app" {
    ami                          = "ami-abc123"
    instance_type                = "t3.micro"
    id                           = "i-0a1b2c3d4e5f"
    private_ip                   = "10.0.1.45"
    public_ip                    = "54.123.45.67"
    subnet_id                    = "subnet-xyz789"
    vpc_security_group_ids       = [
        "sg-abc123",
    ]
}
```

**Use Case:**
Inspect resource attributes without querying AWS.

---

### TF-045 — terraform state mv (Rename Resource)

Rename a resource in state.

**Scenario:**
You renamed a resource in code:
```hcl
# Old name
resource "aws_instance" "server" { }

# New name
resource "aws_instance" "app" { }
```

Without `state mv`, Terraform would:
- Delete `server`
- Create `app` (same as server)

**Fix:**
```bash copy
terraform state mv aws_instance.server aws_instance.app
```

Now state matches code. No infrastructure changes.

**Use Case:**
Refactoring code without recreating resources.

---

### TF-046 — terraform state rm (Remove from State)

Remove a resource from state **without destroying it**.

```bash copy
terraform state rm aws_instance.app
```

**What Happens:**
- Resource removed from state
- Real infrastructure still exists
- Terraform no longer manages it

**Use Case:**
- Migrating resources to another Terraform project
- Importing existing resources elsewhere
- Manually managing a resource going forward

**Warning:**
Resource becomes orphaned. Terraform can't destroy it later.

---

### TF-047 — terraform state pull

Download state file (for remote state).

```bash copy
terraform state pull > state.json
```

**Output:**
Raw JSON state file.

**Use Case:**
- Inspecting remote state locally
- Backup before major changes
- Debugging state issues

**Note:**
Read-only. Don't modify and push back.

---

### TF-048 — terraform state push

Upload state file (use with extreme caution).

```bash copy
terraform state push state.json
```

**Warning:**
Can corrupt state if done incorrectly.

**Use Cases:**
- Restoring from backup
- Migrating state between backends
- Advanced recovery scenarios

**Best Practice:**
Use remote state with versioning instead.

---

### TF-049 — terraform state replace-provider

Change provider source in state.

**Scenario:**
Provider moved from community to official:
```hcl
# Old
provider "custom" {
  source = "community/custom"
}

# New
provider "custom" {
  source = "hashicorp/custom"
}
```

**Fix:**
```bash copy
terraform state replace-provider \
  registry.terraform.io/community/custom \
  registry.terraform.io/hashicorp/custom
```

State updated to new provider source.

**Use Case:**
Provider migrations.

</div>

</details>

---

<details>
<summary><strong>7. State Locking</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-050 — Why State Locking Matters

Without locking, concurrent applies corrupt state.

**The Problem:**

```
Time   User A                    User B
----   ------                    ------
10:00  terraform apply starts
10:01  Reading state (serial: 5)
10:02                            terraform apply starts
10:03                            Reading state (serial: 5)
10:04  Writing state (serial: 6)
10:05                            Writing state (serial: 6)  ← CONFLICT!
```

Result: Corrupted state, lost changes.

---

### TF-051 — How State Locking Works

**With Locking:**

```
Time   User A                    User B
----   ------                    ------
10:00  Acquire lock ✓
10:01  Reading state
10:02                            Try to acquire lock...
10:03  Applying changes          BLOCKED (waiting for lock)
10:04  Writing state
10:05  Release lock ✓
10:06                            Acquire lock ✓
10:07                            Reading state
```

One operation at a time. No conflicts.

---

### TF-052 — State Locking with Local State

Local state has no automatic locking.

**Risk:**
Two terminal windows, same directory:
```bash
# Terminal 1
terraform apply  # No lock

# Terminal 2 (simultaneously)
terraform apply  # No lock, potential corruption
```

**Solution:**
Use remote state with locking (DynamoDB, S3, etc.).

---

### TF-053 — Force Unlock (Emergency)

If a lock is stuck (process crashed):

```bash copy
terraform force-unlock <LOCK_ID>
```

**Example:**
```bash copy
terraform force-unlock 12345678-abcd-1234-5678-123456789abc
```

**Warning:**
Only use if you're certain no other process is running.

**When to Use:**
- Process crashed mid-apply
- CI/CD job killed
- Network timeout during apply

**Danger:**
Force-unlocking during an active apply causes corruption.

---

### TF-054 — Viewing Lock Information

When locked, Terraform shows:

```
Error: Error locking state: Error acquiring the state lock

Lock Info:
  ID:        12345678-abcd-1234-5678-123456789abc
  Path:      terraform.tfstate
  Operation: OperationTypeApply
  Who:       user@hostname
  Version:   1.9.0
  Created:   2024-11-20 10:30:45 UTC
```

**Key Fields:**
- `ID` → lock identifier
- `Who` → user and hostname
- `Created` → when lock acquired

**Action:**
Wait for operation to complete or investigate stuck process.

</div>

</details>

---

<details>
<summary><strong>8. Local vs Remote State</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-055 — Local State (Default)

**Location:**
```
terraform.tfstate
```

**Pros:**
- Simple (no setup required)
- Fast (no network latency)
- Good for learning

**Cons:**
- No locking (corruption risk)
- No versioning (hard to recover)
- Can't share (team collaboration impossible)
- State in Git (security risk)
- No encryption

**Use Case:**
Personal projects, learning, temporary testing.

---

### TF-056 — Remote State (Production)

**Common Backends:**
- S3 + DynamoDB (AWS)
- Azure Blob Storage
- Google Cloud Storage
- Terraform Cloud
- Consul

**Pros:**
- Locking (prevents corruption)
- Versioning (easy recovery)
- Shared (team collaboration)
- Encrypted (security)
- No state in Git

**Cons:**
- Requires setup
- Network dependency
- Backend-specific configuration

**Use Case:**
All production infrastructure, team projects.

---

### TF-057 — When to Use Remote State

**Use remote state when:**
- Working in a team (multiple people)
- Production infrastructure
- CI/CD automation
- Need audit trail
- Need to share outputs between projects

**Example Team Scenario:**

Without remote state:
```
User A applies → state on User A's laptop
User B applies → state on User B's laptop
→ Divergent states, conflicts, chaos
```

With remote state:
```
User A applies → state in S3
User B applies → uses same state in S3
→ Single source of truth, coordination works
```

---

### TF-058 — State Security Considerations

**Local State Risks:**
- Contains sensitive data (passwords, keys)
- If committed to Git → exposed in history
- Hard to remove from Git history
- Accessible to anyone with filesystem access

**Remote State Security:**
- Encryption at rest
- Encryption in transit
- Access control (IAM, RBAC)
- Audit logging
- Versioning (recover from accidents)

**Best Practice:**
Always use remote state for anything beyond local development.

---

### TF-059 — Migrating from Local to Remote State

**Step 1: Add backend configuration**
```hcl
# backend.tf
terraform {
  backend "s3" {
    bucket         = "my-terraform-state"
    key            = "project/terraform.tfstate"
    region         = "us-east-1"
    dynamodb_table = "terraform-locks"
    encrypt        = true
  }
}
```

**Step 2: Initialize**
```bash copy
terraform init
```

Terraform asks:
```
Do you want to copy existing state to the new backend?
  Enter a value: yes
```

**Step 3: Verify**
```bash copy
terraform state list
```

State now in S3.

**Step 4: Delete local state**
```bash copy
rm terraform.tfstate
rm terraform.tfstate.backup
```

**Step 5: Update .gitignore**
```bash copy
echo "terraform.tfstate*" >> .gitignore
```

State migration complete.

</div>

</details>

---

<details>
<summary><strong>9. State Drift and Refresh</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-060 — What is State Drift?

**Drift:**
When reality doesn't match state.

**Common Causes:**
- Manual changes in AWS console
- Changes by other automation tools
- Direct API calls
- Emergency hotfixes

**Example:**
```
State:   instance_type = "t3.micro"
Reality: instance_type = "t3.small"  (changed manually)
→ Drift detected
```

---

### TF-061 — Detecting Drift

**Terraform 1.5+ (Automatic):**
```bash copy
terraform plan
```

Refresh happens automatically, drift detected:
```
Note: Objects have changed outside of Terraform

  ~ resource "aws_instance" "app" {
      ~ instance_type = "t3.micro" -> "t3.small"
    }
```

**Manual Refresh:**
```bash copy
terraform refresh
```

Updates state to match reality.

**Check for Drift:**
```bash copy
terraform plan -refresh-only
```

Shows what changed without proposing fixes.

---

### TF-062 — Handling Drift

**Option 1: Accept Manual Changes (Update Code)**
```hcl
# Update code to match reality
resource "aws_instance" "app" {
  instance_type = "t3.small"  # Match manual change
}
```

Then apply:
```bash copy
terraform apply
```

No changes needed. Code now matches reality.

---

**Option 2: Revert Manual Changes (Enforce Code)**
```bash copy
# Code stays as-is
terraform apply
```

Terraform reverts manual change to match code.

```
~ instance_type = "t3.small" -> "t3.micro"
```

Reality forced back to code's desired state.

---

**Option 3: Ignore Drift (Use lifecycle)**
```hcl
resource "aws_instance" "app" {
  instance_type = "t3.micro"

  lifecycle {
    ignore_changes = [instance_type]
  }
}
```

Terraform won't revert manual instance_type changes.

**Use Case:**
Some attributes managed outside Terraform.

---

### TF-063 — Preventing Drift

**Best Practices:**

**1. Disable Manual Changes**
Use IAM policies to prevent console access:
```json
{
  "Effect": "Deny",
  "Action": "ec2:ModifyInstanceAttribute",
  "Resource": "*",
  "Condition": {
    "StringNotEquals": {
      "aws:userid": "TERRAFORM_SERVICE_ACCOUNT"
    }
  }
}
```

**2. Monitor Drift**
Run scheduled drift detection:
```bash copy
# Cron job
0 */6 * * * cd /terraform && terraform plan -refresh-only
```

**3. Use Sentinel Policies (Terraform Cloud)**
Enforce policies before apply.

**4. Educate Team**
Everyone uses Terraform, not console.

---

### TF-064 — Understanding refresh-only Mode

**Terraform 1.5+ Feature:**
```bash copy
terraform plan -refresh-only
```

**What It Does:**
- Refreshes state from reality
- Shows what changed
- Does NOT propose remediation

**vs Normal Plan:**
```bash copy
terraform plan
```
- Refreshes state
- Shows drift
- Proposes changes to fix drift

**Use Case:**
See what changed without committing to fix it yet.

</div>

</details>

---

<details>
<summary><strong>10. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: State File Corrupted

**Symptom:**
```
Error: Failed to load state
```

**Cause:**
State file corrupted (disk failure, interrupt during write).

**Fix:**
```bash copy
# Restore from backup (local state)
cp terraform.tfstate.backup terraform.tfstate

# Or restore from S3 versioning (remote state)
aws s3api list-object-versions \
  --bucket my-terraform-state \
  --prefix terraform.tfstate

aws s3api get-object \
  --bucket my-terraform-state \
  --key terraform.tfstate \
  --version-id <VERSION_ID> \
  terraform.tfstate
```

**Confirm:**
```bash copy
terraform state list
```

**Lesson:**
Always use remote state with versioning.

---

### Scenario 2: Multiple People Applied Simultaneously

**Symptom:**
State conflicts, resources missing or duplicated.

**Cause:**
No state locking (local state).

**Fix:**
```bash copy
# Immediate: Manually reconcile state
terraform refresh

# Long-term: Migrate to remote state with locking
# See TF-059 for migration steps
```

**Prevention:**
Use S3 + DynamoDB for state locking.

---

### Scenario 3: Accidentally Deleted Resource in Console

**Symptom:**
```
Error: resource not found
```

**Cause:**
Someone deleted EC2 instance in AWS console.

**Fix:**
```bash copy
# Refresh state
terraform plan

# Terraform detects missing resource
# Apply recreates it
terraform apply
```

**Output:**
```
+ resource "aws_instance" "app" {
    instance_type = "t3.micro"
  }

Plan: 1 to add, 0 to change, 0 to destroy.
```

Instance recreated automatically.

**Prevention:**
Use IAM policies to prevent manual deletions.

---

### Scenario 4: Need to Remove Resource from State

**Situation:**
Resource should no longer be managed by Terraform.

**Steps:**
```bash copy
# Remove from state (keeps real resource)
terraform state rm aws_instance.legacy

# Remove from code
# (delete resource block from .tf files)

# Verify
terraform plan
# Should show no changes
```

**Use Case:**
- Handing off resource to another team
- Migrating to different Terraform project
- Resource needs manual management

---

### Scenario 5: Renamed Resource in Code

**Situation:**
Refactored code, changed resource name.

**Before:**
```hcl
resource "aws_instance" "server" {
  instance_type = "t3.micro"
}
```

**After:**
```hcl
resource "aws_instance" "app" {
  instance_type = "t3.micro"
}
```

**Without Fix:**
```bash copy
terraform plan
```
```
- resource "aws_instance" "server" will be destroyed
+ resource "aws_instance" "app" will be created
```

Terraform would destroy and recreate (downtime!).

**Fix:**
```bash copy
terraform state mv aws_instance.server aws_instance.app
terraform plan
```
```
No changes. Infrastructure is up-to-date.
```

No downtime.

---

### Scenario 6: Investigating What Changed

**Situation:**
Infrastructure changed, need to know what.

**Steps:**
```bash copy
# List all resources
terraform state list

# Show specific resource
terraform state show aws_instance.app

# Check for drift
terraform plan -refresh-only

# View state history (remote state with versioning)
aws s3api list-object-versions \
  --bucket my-terraform-state \
  --prefix terraform.tfstate
```

**Use Case:**
Troubleshooting unexpected behavior.

</div>

</details>

---

<details>
<summary><strong>11. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
terraform state list
```
List all resources in state

```bash copy
terraform state show aws_instance.app
```
Show detailed attributes of specific resource

```bash copy
terraform state mv aws_instance.old aws_instance.new
```
Rename resource in state (no infrastructure change)

```bash copy
terraform state rm aws_instance.app
```
Remove resource from state (keeps real resource)

```bash copy
terraform state pull
```
Download remote state to stdout

```bash copy
terraform state push state.json
```
Upload state file (use with caution)

```bash copy
terraform state replace-provider old new
```
Change provider source in state

```bash copy
terraform refresh
```
Update state to match reality

```bash copy
terraform plan -refresh-only
```
Show drift without proposing fixes

```bash copy
terraform show
```
Show current state or saved plan

```bash copy
terraform force-unlock <LOCK_ID>
```
Force release stuck state lock

```bash copy
terraform state pull > state.json
```
Backup remote state locally

```bash copy
terraform state list | grep aws_instance
```
Filter resources in state

```bash copy
terraform show -json | jq '.values.root_module.resources'
```
Query state with jq

</div>

</details>

---

<details>
<summary><strong>12. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- State = Terraform's memory of infrastructure
- State enables updates, deletions, and dependency tracking
- State contains sensitive data (passwords, IPs)
- Never commit state to Git
- Always use remote state for teams and production

---

**The Three Sources:**

| Source | Represents | Priority |
|--------|------------|----------|
| Configuration (.tf) | What you WANT | Highest (source of truth) |
| State (.tfstate) | What Terraform THINKS exists | Middle (synced to reality) |
| Reality (cloud API) | What ACTUALLY exists | Lowest (forced to match config) |

---

**State File Contents:**

- Resource IDs (i-abc123, vpc-xyz789)
- Resource attributes (IPs, DNS names)
- Dependencies (which resources depend on others)
- Outputs (values to expose)
- Metadata (provider versions, serial number)

---

**Common State Commands:**

| Command | Purpose | Safe? |
|---------|---------|-------|
| `state list` | List all resources | ✅ Read-only |
| `state show` | Show resource details | ✅ Read-only |
| `state mv` | Rename resource | ✅ Safe |
| `state rm` | Remove from state | ⚠️ Resource orphaned |
| `state pull` | Download state | ✅ Read-only |
| `state push` | Upload state | ❌ Dangerous |
| `refresh` | Sync state with reality | ✅ Safe |
| `force-unlock` | Release stuck lock | ⚠️ Use carefully |

---

**Local vs Remote State:**

| Feature | Local State | Remote State |
|---------|-------------|--------------|
| Locking | ❌ No | ✅ Yes |
| Versioning | ❌ No | ✅ Yes |
| Encryption | ❌ No | ✅ Yes |
| Team Sharing | ❌ No | ✅ Yes |
| Audit Trail | ❌ No | ✅ Yes |
| Use Case | Learning | Production |

---

**State Drift:**

| Scenario | Detection | Resolution |
|----------|-----------|------------|
| Manual change in console | `terraform plan` | Accept or revert |
| Resource deleted | `terraform plan` | Recreate automatically |
| Configuration changed | `terraform plan` | Apply change |
| State lost | Error on plan | Restore from backup |

---

**State Security Rules:**

1. ❌ Never commit state to Git
2. ✅ Always use remote state for production
3. ✅ Enable encryption at rest
4. ✅ Restrict access with IAM
5. ✅ Enable versioning for recovery
6. ✅ Use state locking
7. ❌ Never edit state manually

---

**Emergency Recovery:**

```bash copy
# Restore local state from backup
cp terraform.tfstate.backup terraform.tfstate

# Restore remote state from S3 versioning
aws s3api get-object \
  --bucket my-state \
  --key terraform.tfstate \
  --version-id <VERSION> \
  terraform.tfstate

# Force unlock stuck lock
terraform force-unlock <LOCK_ID>

# Refresh state to sync with reality
terraform refresh
```

---

**What's Next:**
Now that you understand state — Terraform's memory — the next file covers Providers, Resources, and Data Sources: how Terraform talks to cloud APIs and creates actual infrastructure.

</div>

</details>

---

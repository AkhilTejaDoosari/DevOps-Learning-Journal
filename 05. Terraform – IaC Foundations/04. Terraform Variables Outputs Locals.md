# **04. Variables, Outputs & Locals — Making Terraform Code Flexible**
> Understanding how to parameterize and expose infrastructure values.

---

## Table of Contents
- [1. Why Variables Matter](#1-why-variables-matter)
- [2. Input Variables: Syntax and Types](#2-input-variables-syntax-and-types)
- [3. Variable Definition and Assignment](#3-variable-definition-and-assignment)
- [4. Variable Validation](#4-variable-validation)
- [5. Output Values: Exposing Results](#5-output-values-exposing-results)
- [6. Local Values: Internal Computation](#6-local-values-internal-computation)
- [7. Variable Precedence](#7-variable-precedence)
- [8. Sensitive Data Handling](#8-sensitive-data-handling)
- [9. Complex Variable Types](#9-complex-variable-types)
- [10. Real-World Scenarios](#10-real-world-scenarios)
- [11. Commands Reference](#11-commands-reference)
- [12. Quick Reference](#12-quick-reference)

---

<details>
<summary><strong>1. Why Variables Matter</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Variables make infrastructure code reusable and flexible.

Without variables, you'd hardcode everything:
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  tags = {
    Environment = "production"
  }
}
```

**Problems:**
- Can't reuse for dev/staging
- Have to duplicate code
- Hard to change values
- No validation

**With variables:**
```hcl
resource "aws_instance" "app" {
  ami           = var.ami_id
  instance_type = var.instance_type
  
  tags = {
    Environment = var.environment
  }
}
```

**Benefits:**
- One codebase for all environments
- Values validated at plan time
- Easy to change configurations
- Self-documenting code

---

### TF-103 — The Three Value Types

**Input Variables (`var.`):**
- Values passed INTO your module/project
- Like function parameters
- Can have defaults, validation, descriptions

**Output Values (`output`):**
- Values exposed FROM your module/project
- Like function return values
- Can be used by other Terraform projects

**Local Values (`local.`):**
- Internal computed values
- Like local variables in functions
- Not exposed outside

**The Flow:**
```
Input (var) → Compute (local) → Create (resource) → Expose (output)
```

</div>

</details>

---

<details>
<summary><strong>2. Input Variables: Syntax and Types</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-104 — Basic Variable Declaration

**Syntax:**
```hcl
variable "name" {
  description = "Human-readable description"
  type        = string
  default     = "default-value"
}
```

**Example:**
```hcl
variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}
```

**Using Variables:**
```hcl
resource "aws_instance" "app" {
  instance_type = var.instance_type
}
```

**Syntax:** `var.variable_name`

---

### TF-105 — Variable Types

**Primitive Types:**

**String:**
```hcl
variable "region" {
  type    = string
  default = "us-east-1"
}
```

**Number:**
```hcl
variable "instance_count" {
  type    = number
  default = 3
}
```

**Bool:**
```hcl
variable "enable_monitoring" {
  type    = bool
  default = true
}
```

---

**Collection Types:**

**List (ordered, duplicates allowed):**
```hcl
variable "availability_zones" {
  type    = list(string)
  default = ["us-east-1a", "us-east-1b", "us-east-1c"]
}
```

**Set (unordered, no duplicates):**
```hcl
variable "security_group_ids" {
  type    = set(string)
  default = ["sg-abc123", "sg-def456"]
}
```

**Map (key-value pairs):**
```hcl
variable "tags" {
  type = map(string)
  default = {
    Environment = "production"
    ManagedBy   = "Terraform"
  }
}
```

---

**Structural Types:**

**Object (structured data):**
```hcl
variable "instance_config" {
  type = object({
    instance_type = string
    ami           = string
    monitoring    = bool
  })
  default = {
    instance_type = "t3.micro"
    ami           = "ami-abc123"
    monitoring    = true
  }
}
```

**Tuple (fixed-length list with different types):**
```hcl
variable "subnet_config" {
  type    = tuple([string, number, bool])
  default = ["10.0.1.0/24", 1, true]
}
```

---

### TF-106 — Variable Without Default (Required)

**Variables without defaults are required:**
```hcl
variable "environment" {
  description = "Environment name (required)"
  type        = string
  # No default = must be provided
}
```

**Must provide value:**
```bash copy
terraform apply -var="environment=production"
```

Or in `terraform.tfvars`:
```hcl
environment = "production"
```

**Error if not provided:**
```
Error: No value for required variable
  on variables.tf line 1:
   1: variable "environment" {
```

---

### TF-107 — Variable Descriptions

**Always add descriptions:**
```hcl
variable "vpc_cidr" {
  description = "CIDR block for VPC. Must be valid IPv4 CIDR."
  type        = string
  default     = "10.0.0.0/16"
}
```

**Why:**
- Self-documenting code
- Shows in `terraform plan`
- Helps team members
- Generated documentation

**Viewing Descriptions:**
```bash copy
terraform console
> var.vpc_cidr
"10.0.0.0/16"
```

</div>

</details>

---

<details>
<summary><strong>3. Variable Definition and Assignment</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-108 — Variable Files (variables.tf)

**Convention:**
Declare variables in `variables.tf`:

```hcl
# variables.tf
variable "aws_region" {
  description = "AWS region for resources"
  type        = string
  default     = "us-east-1"
}

variable "environment" {
  description = "Environment name"
  type        = string
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}

variable "enable_monitoring" {
  description = "Enable CloudWatch monitoring"
  type        = bool
  default     = false
}
```

---

### TF-109 — Assigning Values (terraform.tfvars)

**File: `terraform.tfvars`**
```hcl
# terraform.tfvars
aws_region         = "us-west-2"
environment        = "production"
instance_type      = "t3.large"
enable_monitoring  = true
```

**Auto-loaded files:**
- `terraform.tfvars`
- `terraform.tfvars.json`
- `*.auto.tfvars`
- `*.auto.tfvars.json`

**Environment-specific files:**
```
terraform.tfvars          # Default
production.tfvars         # Production (manual load)
staging.tfvars            # Staging (manual load)
dev.tfvars                # Dev (manual load)
```

**Load specific file:**
```bash copy
terraform apply -var-file="production.tfvars"
```

---

### TF-110 — Command-Line Variables

**Single variable:**
```bash copy
terraform apply -var="environment=production"
```

**Multiple variables:**
```bash copy
terraform apply \
  -var="environment=production" \
  -var="instance_type=t3.large" \
  -var="enable_monitoring=true"
```

**From file:**
```bash copy
terraform apply -var-file="production.tfvars"
```

**Multiple files:**
```bash copy
terraform apply \
  -var-file="common.tfvars" \
  -var-file="production.tfvars"
```

---

### TF-111 — Environment Variables

**Format:** `TF_VAR_name`

```bash copy
export TF_VAR_environment="production"
export TF_VAR_instance_type="t3.large"
export TF_VAR_enable_monitoring="true"

terraform apply
```

**Use case:**
- CI/CD pipelines
- Secrets management
- Non-committed values

**Example:**
```bash copy
# In CI/CD pipeline
export TF_VAR_db_password="$DB_PASSWORD_FROM_VAULT"
terraform apply
```

---

### TF-112 — Variable File Formats

**HCL Format (terraform.tfvars):**
```hcl
environment      = "production"
instance_type    = "t3.large"
availability_zones = ["us-east-1a", "us-east-1b"]

tags = {
  Environment = "production"
  ManagedBy   = "Terraform"
}
```

**JSON Format (terraform.tfvars.json):**
```json
{
  "environment": "production",
  "instance_type": "t3.large",
  "availability_zones": ["us-east-1a", "us-east-1b"],
  "tags": {
    "Environment": "production",
    "ManagedBy": "Terraform"
  }
}
```

---

### TF-113 — .gitignore for Variable Files

**Critical:** Don't commit secrets!

```gitignore
# .gitignore

# Variable files may contain secrets
*.tfvars
terraform.tfvars
terraform.tfvars.json

# Exception: commit example files
!example.tfvars
!terraform.tfvars.example
```

**Recommended: Example file**
```hcl
# terraform.tfvars.example
# Copy to terraform.tfvars and fill in values

environment      = "production"
instance_type    = "t3.micro"
# db_password    = "your-secure-password-here"
```

</div>

</details>

---

<details>
<summary><strong>4. Variable Validation</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-114 — Basic Validation

**Syntax:**
```hcl
variable "name" {
  type = string
  
  validation {
    condition     = <boolean expression>
    error_message = "Human-readable error message"
  }
}
```

---

### TF-115 — Validation Examples

**Validate String Pattern:**
```hcl
variable "environment" {
  type        = string
  description = "Environment name"
  
  validation {
    condition     = contains(["dev", "staging", "production"], var.environment)
    error_message = "Environment must be dev, staging, or production."
  }
}
```

**Validate String Length:**
```hcl
variable "project_name" {
  type = string
  
  validation {
    condition     = length(var.project_name) >= 3 && length(var.project_name) <= 20
    error_message = "Project name must be 3-20 characters."
  }
}
```

**Validate CIDR Block:**
```hcl
variable "vpc_cidr" {
  type = string
  
  validation {
    condition     = can(cidrhost(var.vpc_cidr, 0))
    error_message = "VPC CIDR must be a valid IPv4 CIDR block."
  }
}
```

**Validate Number Range:**
```hcl
variable "instance_count" {
  type = number
  
  validation {
    condition     = var.instance_count >= 1 && var.instance_count <= 10
    error_message = "Instance count must be between 1 and 10."
  }
}
```

**Validate Instance Type:**
```hcl
variable "instance_type" {
  type = string
  
  validation {
    condition     = can(regex("^t[2-3]\\.(nano|micro|small|medium|large)$", var.instance_type))
    error_message = "Instance type must be t2 or t3 (nano, micro, small, medium, or large)."
  }
}
```

**Validate Email:**
```hcl
variable "admin_email" {
  type = string
  
  validation {
    condition     = can(regex("^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$", var.admin_email))
    error_message = "Admin email must be a valid email address."
  }
}
```

---

### TF-116 — Multiple Validations

**You can have multiple validation blocks:**
```hcl
variable "instance_type" {
  type = string
  
  validation {
    condition     = can(regex("^t[2-3]\\.", var.instance_type))
    error_message = "Instance type must be t2 or t3 family."
  }
  
  validation {
    condition     = !can(regex(".*\\.xlarge$", var.instance_type))
    error_message = "Instance type cannot be xlarge (cost control)."
  }
}
```

**All validations must pass.**

---

### TF-117 — Validation Functions

**Common functions for validation:**

**`contains(list, value)`** - Check if value in list
```hcl
condition = contains(["us-east-1", "us-west-2"], var.region)
```

**`can(expression)`** - Try expression, return true if succeeds
```hcl
condition = can(cidrhost(var.cidr, 0))
```

**`regex(pattern, string)`** - Match regex pattern
```hcl
condition = can(regex("^[a-z0-9-]+$", var.name))
```

**`length(collection)`** - Get length
```hcl
condition = length(var.name) >= 3
```

**`tonumber(string)`** - Convert to number
```hcl
condition = can(tonumber(var.port)) && tonumber(var.port) >= 1024
```

</div>

</details>

---

<details>
<summary><strong>5. Output Values: Exposing Results</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-118 — Why Outputs Matter

Outputs expose values after infrastructure creation.

**Use Cases:**
- Show important information (IPs, DNS names)
- Pass values to other Terraform projects
- Display results in CI/CD logs
- Reference in scripts

---

### TF-119 — Output Syntax

**Basic Structure:**
```hcl
output "name" {
  description = "Description of output"
  value       = <expression>
}
```

**Example:**
```hcl
output "instance_id" {
  description = "ID of the EC2 instance"
  value       = aws_instance.app.id
}

output "instance_public_ip" {
  description = "Public IP of the EC2 instance"
  value       = aws_instance.app.public_ip
}

output "instance_private_ip" {
  description = "Private IP of the EC2 instance"
  value       = aws_instance.app.private_ip
}
```

---

### TF-120 — Output File (outputs.tf)

**Convention:**
Put outputs in `outputs.tf`:

```hcl
# outputs.tf

output "vpc_id" {
  description = "ID of the VPC"
  value       = aws_vpc.main.id
}

output "subnet_ids" {
  description = "IDs of the subnets"
  value       = aws_subnet.public[*].id
}

output "instance_ips" {
  description = "Public IPs of instances"
  value = {
    web    = aws_instance.web.public_ip
    api    = aws_instance.api.public_ip
    worker = aws_instance.worker.public_ip
  }
}
```

---

### TF-121 — Viewing Outputs

**After Apply:**
```bash copy
terraform apply
```

Output shown automatically:
```
Apply complete! Resources: 3 added, 0 changed, 0 destroyed.

Outputs:

instance_id = "i-0a1b2c3d4e5f"
instance_public_ip = "54.123.45.67"
vpc_id = "vpc-abc123def456"
```

**Query Specific Output:**
```bash copy
terraform output instance_id
```

Output:
```
"i-0a1b2c3d4e5f"
```

**All Outputs (JSON):**
```bash copy
terraform output -json
```

**Raw Value (No Quotes):**
```bash copy
terraform output -raw instance_id
```

Output:
```
i-0a1b2c3d4e5f
```

---

### TF-122 — Sensitive Outputs

**Mark outputs as sensitive:**
```hcl
output "db_password" {
  description = "Database password"
  value       = aws_db_instance.main.password
  sensitive   = true
}
```

**Effect:**
```bash copy
terraform apply
```

Output:
```
Outputs:

db_password = <sensitive>
```

**View sensitive output:**
```bash copy
terraform output db_password
```

Shows actual value (use carefully).

**JSON output still includes sensitive values:**
```bash copy
terraform output -json
```

---

### TF-123 — Complex Outputs

**List Output:**
```hcl
output "subnet_ids" {
  description = "List of subnet IDs"
  value       = aws_subnet.public[*].id
}
```

Result:
```
subnet_ids = [
  "subnet-abc123",
  "subnet-def456",
  "subnet-ghi789",
]
```

**Map Output:**
```hcl
output "instance_details" {
  description = "Instance details"
  value = {
    id         = aws_instance.app.id
    public_ip  = aws_instance.app.public_ip
    private_ip = aws_instance.app.private_ip
    az         = aws_instance.app.availability_zone
  }
}
```

Result:
```
instance_details = {
  az         = "us-east-1a"
  id         = "i-0a1b2c3d4e5f"
  private_ip = "10.0.1.45"
  public_ip  = "54.123.45.67"
}
```

**Object Output:**
```hcl
output "load_balancer" {
  value = {
    dns_name = aws_lb.main.dns_name
    arn      = aws_lb.main.arn
    zone_id  = aws_lb.main.zone_id
  }
}
```

---

### TF-124 — Using Outputs in Scripts

**Bash Script:**
```bash copy
#!/bin/bash

# Get instance IP
INSTANCE_IP=$(terraform output -raw instance_public_ip)

# SSH to instance
ssh -i key.pem ec2-user@$INSTANCE_IP

# Or use in curl
API_URL=$(terraform output -raw api_endpoint)
curl $API_URL/health
```

**JSON Processing:**
```bash copy
# Get all outputs as JSON
terraform output -json > outputs.json

# Parse with jq
INSTANCE_ID=$(terraform output -json | jq -r '.instance_id.value')
```

</div>

</details>

---

<details>
<summary><strong>6. Local Values: Internal Computation</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-125 — What are Locals?

Local values are computed values used within your module.

**Purpose:**
- Avoid repeating complex expressions
- Compute derived values
- Clean up code
- No external exposure (unlike outputs)

---

### TF-126 — Locals Syntax

**Basic Structure:**
```hcl
locals {
  name1 = <expression>
  name2 = <expression>
}
```

**Example:**
```hcl
locals {
  environment  = "production"
  project_name = "myapp"
  common_tags = {
    Environment = local.environment
    Project     = local.project_name
    ManagedBy   = "Terraform"
  }
}
```

**Using Locals:**
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  tags = local.common_tags
}
```

**Syntax:** `local.name` (singular, not `locals.`)

---

### TF-127 — Locals File (locals.tf)

**Convention:**
Put locals in `locals.tf`:

```hcl
# locals.tf

locals {
  # Computed environment prefix
  env_prefix = "${var.environment}-${var.project_name}"
  
  # Common tags for all resources
  common_tags = {
    Environment = var.environment
    Project     = var.project_name
    ManagedBy   = "Terraform"
    CostCenter  = var.cost_center
  }
  
  # Availability zones
  availability_zones = data.aws_availability_zones.available.names
  
  # Subnet count
  subnet_count = length(local.availability_zones)
  
  # CIDR calculations
  public_subnets = [
    for i in range(local.subnet_count) :
    cidrsubnet(var.vpc_cidr, 8, i)
  ]
  
  private_subnets = [
    for i in range(local.subnet_count) :
    cidrsubnet(var.vpc_cidr, 8, i + 100)
  ]
}
```

---

### TF-128 — Common Local Patterns

**Naming Convention:**
```hcl
locals {
  name_prefix = "${var.environment}-${var.project_name}"
}

resource "aws_instance" "app" {
  tags = {
    Name = "${local.name_prefix}-app"
  }
}

resource "aws_s3_bucket" "data" {
  bucket = "${local.name_prefix}-data"
}
```

**Conditional Values:**
```hcl
locals {
  instance_type = var.environment == "production" ? "t3.large" : "t3.micro"
  
  enable_backup = var.environment == "production" ? true : false
  
  replica_count = var.environment == "production" ? 3 : 1
}
```

**Computed CIDR Blocks:**
```hcl
locals {
  vpc_cidr = "10.0.0.0/16"
  
  public_subnets = [
    cidrsubnet(local.vpc_cidr, 8, 0),  # 10.0.0.0/24
    cidrsubnet(local.vpc_cidr, 8, 1),  # 10.0.1.0/24
    cidrsubnet(local.vpc_cidr, 8, 2),  # 10.0.2.0/24
  ]
  
  private_subnets = [
    cidrsubnet(local.vpc_cidr, 8, 10), # 10.0.10.0/24
    cidrsubnet(local.vpc_cidr, 8, 11), # 10.0.11.0/24
    cidrsubnet(local.vpc_cidr, 8, 12), # 10.0.12.0/24
  ]
}
```

**Merged Tags:**
```hcl
locals {
  common_tags = {
    ManagedBy   = "Terraform"
    Environment = var.environment
  }
}

resource "aws_instance" "app" {
  tags = merge(
    local.common_tags,
    {
      Name = "app-server"
      Role = "application"
    }
  )
}
```

---

### TF-129 — Locals vs Variables

| Aspect | Variables | Locals |
|--------|-----------|--------|
| Input | External (user provides) | Internal (computed) |
| Syntax | `var.name` | `local.name` |
| Can have default | Yes | N/A (always has value) |
| Validation | Yes | No |
| Exposed | No (unless output) | No |
| Use case | Configuration | Computation |

**Example:**
```hcl
# Variable: User provides
variable "environment" {
  type = string
}

# Local: Computed from variable
locals {
  is_production = var.environment == "production"
  instance_type = local.is_production ? "t3.large" : "t3.micro"
}

# Resource: Uses local
resource "aws_instance" "app" {
  instance_type = local.instance_type
}
```

</div>

</details>

---

<details>
<summary><strong>7. Variable Precedence</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-130 — Order of Precedence

**Terraform loads variables in this order (last wins):**

1. Environment variables (`TF_VAR_name`)
2. `terraform.tfvars` file
3. `terraform.tfvars.json` file
4. `*.auto.tfvars` files (alphabetical order)
5. `-var` and `-var-file` command-line flags (left to right)

**Highest Priority:** Command-line `-var` flags
**Lowest Priority:** Environment variables

---

### TF-131 — Precedence Example

**Setup:**
```hcl
# variables.tf
variable "instance_type" {
  default = "t3.micro"
}
```

**Different Sources:**
```bash copy
# Environment variable
export TF_VAR_instance_type="t3.small"

# terraform.tfvars
instance_type = "t3.medium"

# Command line
terraform apply -var="instance_type=t3.large"
```

**Result:**
`t3.large` is used (command-line has highest priority).

**Priority Order:**
```
t3.micro    (default - lowest)
  ↓
t3.small    (TF_VAR_)
  ↓
t3.medium   (terraform.tfvars)
  ↓
t3.large    (command-line - highest)
```

---

### TF-132 — Multiple Variable Files

**Files:**
```
common.tfvars
production.tfvars
```

**Command:**
```bash copy
terraform apply \
  -var-file="common.tfvars" \
  -var-file="production.tfvars"
```

**Order Matters:**
If both files define `instance_type`, `production.tfvars` wins (loaded last).

**Common Pattern:**
```
common.tfvars        # Shared defaults
dev.tfvars           # Dev overrides
staging.tfvars       # Staging overrides
production.tfvars    # Production overrides
```

Usage:
```bash copy
terraform apply -var-file="common.tfvars" -var-file="production.tfvars"
```

</div>

</details>

---

<details>
<summary><strong>8. Sensitive Data Handling</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-133 — Marking Variables as Sensitive

**Declaration:**
```hcl
variable "db_password" {
  description = "Database password"
  type        = string
  sensitive   = true
}
```

**Effect:**
- Value hidden in plan output
- Value hidden in apply output
- Still visible in state file

**Plan Output:**
```
~ db_password = (sensitive value)
```

---

### TF-134 — Sensitive Outputs

**Output Declaration:**
```hcl
output "db_password" {
  description = "Database password"
  value       = var.db_password
  sensitive   = true
}
```

**Effect:**
```bash copy
terraform output
```

Shows:
```
db_password = <sensitive>
```

**View Sensitive Output:**
```bash copy
terraform output db_password
```

Shows actual value.

---

### TF-135 — Passing Sensitive Variables

**Never in Code:**
```hcl
# DON'T DO THIS
variable "db_password" {
  default   = "SuperSecret123"  # ❌ Never hardcode
  sensitive = true
}
```

**Environment Variable (Good):**
```bash copy
export TF_VAR_db_password="SuperSecret123"
terraform apply
```

**Variable File (OK if not committed):**
```hcl
# secrets.tfvars (in .gitignore)
db_password = "SuperSecret123"
```

```bash copy
terraform apply -var-file="secrets.tfvars"
```

**Command Line (OK):**
```bash copy
terraform apply -var="db_password=SuperSecret123"
```

**From Vault/Secrets Manager (Best):**
```bash copy
export TF_VAR_db_password=$(aws secretsmanager get-secret-value \
  --secret-id prod/db/password \
  --query SecretString \
  --output text)

terraform apply
```

---

### TF-136 — Sensitive Data in State

**Critical:** State files contain sensitive data in plaintext.

**Example State:**
```json
{
  "resources": [{
    "type": "aws_db_instance",
    "instances": [{
      "attributes": {
        "password": "SuperSecret123",  // ← Plaintext
        "username": "admin"
      }
    }]
  }]
}
```

**Mitigation:**
1. Use remote state with encryption
2. Restrict access to state
3. Enable state file encryption (S3, etc.)
4. Use IAM policies to control access

**Best Practice:**
```hcl
terraform {
  backend "s3" {
    bucket         = "terraform-state"
    key            = "prod/terraform.tfstate"
    region         = "us-east-1"
    encrypt        = true  # ← Encrypt state at rest
    dynamodb_table = "terraform-locks"
  }
}
```

</div>

</details>

---

<details>
<summary><strong>9. Complex Variable Types</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-137 — List of Objects

**Declaration:**
```hcl
variable "instances" {
  description = "List of instance configurations"
  type = list(object({
    name          = string
    instance_type = string
    ami           = string
    monitoring    = bool
  }))
}
```

**Value:**
```hcl
# terraform.tfvars
instances = [
  {
    name          = "web"
    instance_type = "t3.micro"
    ami           = "ami-abc123"
    monitoring    = true
  },
  {
    name          = "api"
    instance_type = "t3.small"
    ami           = "ami-abc123"
    monitoring    = true
  },
  {
    name          = "worker"
    instance_type = "t3.medium"
    ami           = "ami-abc123"
    monitoring    = false
  }
]
```

**Usage:**
```hcl
resource "aws_instance" "app" {
  for_each = { for i in var.instances : i.name => i }
  
  ami           = each.value.ami
  instance_type = each.value.instance_type
  monitoring    = each.value.monitoring
  
  tags = {
    Name = each.value.name
  }
}
```

---

### TF-138 — Map of Objects

**Declaration:**
```hcl
variable "environments" {
  description = "Environment configurations"
  type = map(object({
    instance_type = string
    instance_count = number
    enable_backup = bool
  }))
}
```

**Value:**
```hcl
# terraform.tfvars
environments = {
  dev = {
    instance_type  = "t3.micro"
    instance_count = 1
    enable_backup  = false
  }
  staging = {
    instance_type  = "t3.small"
    instance_count = 2
    enable_backup  = true
  }
  production = {
    instance_type  = "t3.large"
    instance_count = 3
    enable_backup  = true
  }
}
```

**Usage:**
```hcl
locals {
  env_config = var.environments[var.environment]
}

resource "aws_instance" "app" {
  count         = local.env_config.instance_count
  instance_type = local.env_config.instance_type
}
```

---

### TF-139 — Nested Objects

**Declaration:**
```hcl
variable "vpc_config" {
  type = object({
    cidr_block = string
    subnets = object({
      public = list(object({
        cidr_block = string
        az         = string
      }))
      private = list(object({
        cidr_block = string
        az         = string
      }))
    })
  })
}
```

**Value:**
```hcl
vpc_config = {
  cidr_block = "10.0.0.0/16"
  subnets = {
    public = [
      { cidr_block = "10.0.1.0/24", az = "us-east-1a" },
      { cidr_block = "10.0.2.0/24", az = "us-east-1b" }
    ]
    private = [
      { cidr_block = "10.0.10.0/24", az = "us-east-1a" },
      { cidr_block = "10.0.11.0/24", az = "us-east-1b" }
    ]
  }
}
```

---

### TF-140 — Optional Object Attributes (Terraform 1.3+)

**With Defaults:**
```hcl
variable "instance_config" {
  type = object({
    instance_type = string
    monitoring    = optional(bool, false)  # Default: false
    ami           = optional(string, "ami-abc123")
  })
}
```

**Can omit optional fields:**
```hcl
instance_config = {
  instance_type = "t3.micro"
  # monitoring and ami will use defaults
}
```

</div>

</details>

---

<details>
<summary><strong>10. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Multi-Environment Configuration

**variables.tf:**
```hcl
variable "environment" {
  description = "Environment name"
  type        = string
  
  validation {
    condition     = contains(["dev", "staging", "production"], var.environment)
    error_message = "Environment must be dev, staging, or production."
  }
}

variable "instance_configs" {
  description = "Instance configurations per environment"
  type = map(object({
    instance_type  = string
    instance_count = number
    enable_backup  = bool
  }))
  
  default = {
    dev = {
      instance_type  = "t3.micro"
      instance_count = 1
      enable_backup  = false
    }
    staging = {
      instance_type  = "t3.small"
      instance_count = 2
      enable_backup  = true
    }
    production = {
      instance_type  = "t3.large"
      instance_count = 3
      enable_backup  = true
    }
  }
}
```

**locals.tf:**
```hcl
locals {
  config = var.instance_configs[var.environment]
}
```

**main.tf:**
```hcl
resource "aws_instance" "app" {
  count         = local.config.instance_count
  instance_type = local.config.instance_type
  ami           = data.aws_ami.latest.id
  
  tags = {
    Name        = "${var.environment}-app-${count.index + 1}"
    Environment = var.environment
  }
}
```

**Usage:**
```bash copy
terraform apply -var="environment=production"
```

---

### Scenario 2: Dynamic Tagging

**variables.tf:**
```hcl
variable "environment" {
  type = string
}

variable "project_name" {
  type = string
}

variable "cost_center" {
  type = string
}

variable "additional_tags" {
  description = "Additional tags to apply"
  type        = map(string)
  default     = {}
}
```

**locals.tf:**
```hcl
locals {
  common_tags = merge(
    {
      Environment = var.environment
      Project     = var.project_name
      CostCenter  = var.cost_center
      ManagedBy   = "Terraform"
      CreatedAt   = timestamp()
    },
    var.additional_tags
  )
}
```

**main.tf:**
```hcl
resource "aws_instance" "app" {
  ami           = "ami-abc123"
  instance_type = "t3.micro"
  
  tags = merge(
    local.common_tags,
    {
      Name = "app-server"
      Role = "application"
    }
  )
}

resource "aws_s3_bucket" "data" {
  bucket = "${var.project_name}-data"
  tags   = merge(
    local.common_tags,
    {
      Name = "data-bucket"
      Type = "storage"
    }
  )
}
```

---

### Scenario 3: CIDR Calculation

**variables.tf:**
```hcl
variable "vpc_cidr" {
  description = "VPC CIDR block"
  type        = string
  default     = "10.0.0.0/16"
  
  validation {
    condition     = can(cidrhost(var.vpc_cidr, 0))
    error_message = "VPC CIDR must be valid."
  }
}

variable "availability_zones" {
  description = "List of availability zones"
  type        = list(string)
}
```

**locals.tf:**
```hcl
locals {
  az_count = length(var.availability_zones)
  
  # Public subnets: 10.0.0.0/24, 10.0.1.0/24, etc.
  public_subnet_cidrs = [
    for i in range(local.az_count) :
    cidrsubnet(var.vpc_cidr, 8, i)
  ]
  
  # Private subnets: 10.0.100.0/24, 10.0.101.0/24, etc.
  private_subnet_cidrs = [
    for i in range(local.az_count) :
    cidrsubnet(var.vpc_cidr, 8, i + 100)
  ]
}
```

**main.tf:**
```hcl
resource "aws_subnet" "public" {
  count             = local.az_count
  vpc_id            = aws_vpc.main.id
  cidr_block        = local.public_subnet_cidrs[count.index]
  availability_zone = var.availability_zones[count.index]
  
  tags = {
    Name = "public-${count.index + 1}"
    Type = "public"
  }
}

resource "aws_subnet" "private" {
  count             = local.az_count
  vpc_id            = aws_vpc.main.id
  cidr_block        = local.private_subnet_cidrs[count.index]
  availability_zone = var.availability_zones[count.index]
  
  tags = {
    Name = "private-${count.index + 1}"
    Type = "private"
  }
}
```

**outputs.tf:**
```hcl
output "public_subnet_ids" {
  description = "IDs of public subnets"
  value       = aws_subnet.public[*].id
}

output "private_subnet_ids" {
  description = "IDs of private subnets"
  value       = aws_subnet.private[*].id
}

output "subnet_mapping" {
  description = "Subnet ID to CIDR mapping"
  value = {
    for subnet in aws_subnet.public :
    subnet.id => subnet.cidr_block
  }
}
```

---

### Scenario 4: Using Outputs in Scripts

**outputs.tf:**
```hcl
output "instance_details" {
  description = "Instance connection details"
  value = {
    public_ip  = aws_instance.app.public_ip
    private_ip = aws_instance.app.private_ip
    id         = aws_instance.app.id
  }
}

output "api_endpoint" {
  description = "API endpoint URL"
  value       = "https://${aws_lb.api.dns_name}"
}
```

**deploy.sh:**
```bash copy
#!/bin/bash

# Apply Terraform
terraform apply -auto-approve

# Get outputs
INSTANCE_IP=$(terraform output -raw instance_details | jq -r '.public_ip')
API_ENDPOINT=$(terraform output -raw api_endpoint)

# Wait for instance to be ready
echo "Waiting for instance at $INSTANCE_IP..."
until ssh -o ConnectTimeout=5 -i key.pem ec2-user@$INSTANCE_IP 'exit' 2>/dev/null
do
  echo "Waiting..."
  sleep 5
done

# Deploy application
echo "Deploying application..."
scp -i key.pem app.tar.gz ec2-user@$INSTANCE_IP:/tmp/
ssh -i key.pem ec2-user@$INSTANCE_IP 'cd /tmp && tar xzf app.tar.gz && ./install.sh'

# Test API
echo "Testing API at $API_ENDPOINT..."
curl -f "$API_ENDPOINT/health" || exit 1

echo "Deployment complete!"
```

---

### Scenario 5: Variable Validation Failed

**Symptom:**
```
Error: Invalid value for variable

  on variables.tf line 5:
   5: variable "environment" {

Environment must be dev, staging, or production.
```

**Cause:**
Provided value doesn't pass validation.

**Fix:**
```bash copy
# Wrong
terraform apply -var="environment=prod"

# Correct
terraform apply -var="environment=production"
```

**Or Update Code:**
```hcl
validation {
  condition = contains(["dev", "staging", "prod", "production"], var.environment)
  error_message = "Environment must be dev, staging, prod, or production."
}
```

</div>

</details>

---

<details>
<summary><strong>11. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
terraform apply -var="key=value"
```
Pass single variable via command line

```bash copy
terraform apply -var="env=prod" -var="count=3"
```
Pass multiple variables

```bash copy
terraform apply -var-file="production.tfvars"
```
Load variables from file

```bash copy
terraform apply -var-file="common.tfvars" -var-file="prod.tfvars"
```
Load multiple variable files

```bash copy
export TF_VAR_environment="production"
```
Set variable via environment variable

```bash copy
terraform output
```
Show all outputs

```bash copy
terraform output instance_id
```
Show specific output (with quotes)

```bash copy
terraform output -raw instance_id
```
Show output without quotes

```bash copy
terraform output -json
```
Show all outputs in JSON format

```bash copy
terraform output -json | jq '.instance_id.value'
```
Parse output with jq

```bash copy
terraform console
```
Interactive console to test expressions

```bash copy
terraform console
> var.environment
"production"
> local.common_tags
{
  "Environment" = "production"
  "ManagedBy" = "Terraform"
}
```
Test variables and locals

```bash copy
terraform validate
```
Validate syntax and variable types

</div>

</details>

---

<details>
<summary><strong>12. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Variables = input parameters (external)
- Locals = computed values (internal)
- Outputs = exported values (for other projects)
- Variables can have defaults and validation
- Outputs can be marked sensitive

---

**Variable Declaration:**

```hcl
variable "name" {
  description = "Description"
  type        = string
  default     = "default-value"
  sensitive   = false
  
  validation {
    condition     = <boolean>
    error_message = "Error message"
  }
}
```

---

**Variable Types:**

| Type | Example |
|------|---------|
| `string` | `"hello"` |
| `number` | `42` |
| `bool` | `true` |
| `list(string)` | `["a", "b", "c"]` |
| `set(string)` | `["a", "b"]` (no duplicates) |
| `map(string)` | `{key = "value"}` |
| `object({...})` | Complex structure |
| `tuple([...])` | Fixed-length list |

---

**Variable Assignment (Precedence):**

1. `TF_VAR_name` environment variables (lowest)
2. `terraform.tfvars`
3. `terraform.tfvars.json`
4. `*.auto.tfvars` (alphabetical)
5. `-var` and `-var-file` flags (highest)

---

**Output Declaration:**

```hcl
output "name" {
  description = "Description"
  value       = <expression>
  sensitive   = false
}
```

---

**Local Values:**

```hcl
locals {
  name1 = <expression>
  name2 = <expression>
}

# Usage
resource "type" "name" {
  argument = local.name1
}
```

---

**Variable Files:**

```
variables.tf         # Declare variables
terraform.tfvars     # Assign values (auto-loaded)
production.tfvars    # Environment-specific (manual load)
dev.auto.tfvars      # Auto-loaded
```

---

**Sensitive Data:**

```hcl
# Variable
variable "password" {
  type      = string
  sensitive = true
}

# Output
output "password" {
  value     = var.password
  sensitive = true
}

# Pass securely
export TF_VAR_password=$(vault read -field=password secret/db)
terraform apply
```

---

**Validation Examples:**

```hcl
# String in list
validation {
  condition     = contains(["dev", "prod"], var.env)
  error_message = "Must be dev or prod"
}

# Regex
validation {
  condition     = can(regex("^t[2-3]\\.", var.type))
  error_message = "Must be t2 or t3 instance"
}

# Number range
validation {
  condition     = var.count >= 1 && var.count <= 10
  error_message = "Must be 1-10"
}

# CIDR block
validation {
  condition     = can(cidrhost(var.cidr, 0))
  error_message = "Must be valid CIDR"
}
```

---

**Common Patterns:**

```hcl
# Environment-specific config
locals {
  config = var.environment == "production" ? {
    instance_type = "t3.large"
    count         = 3
  } : {
    instance_type = "t3.micro"
    count         = 1
  }
}

# Common tags
locals {
  common_tags = {
    Environment = var.environment
    ManagedBy   = "Terraform"
  }
}

# CIDR calculation
locals {
  subnets = [
    for i in range(3) :
    cidrsubnet(var.vpc_cidr, 8, i)
  ]
}
```

---

**What's Next:**
Now that you understand variables, outputs, and locals — how to parameterize infrastructure — the next file covers Loops and Conditionals: how to create multiple resources dynamically using count, for_each, and conditional logic.

</div>

</details>

---

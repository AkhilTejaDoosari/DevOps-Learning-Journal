# **01. Terraform Foundations & Installation — Understanding Infrastructure as Code**
> The calm, inside-out view of how Terraform actually works.

---

## Table of Contents
- [1. Why Infrastructure as Code Matters](#1-why-infrastructure-as-code-matters)
- [2. What Terraform Solves](#2-what-terraform-solves)
- [3. How Terraform Thinks](#3-how-terraform-thinks)
- [4. Terraform vs Alternatives](#4-terraform-vs-alternatives)
- [5. Installation and Setup](#5-installation-and-setup)
- [6. Your First Terraform Init](#6-your-first-terraform-init)
- [7. Understanding the Workflow](#7-understanding-the-workflow)
- [8. Directory Structure](#8-directory-structure)
- [9. Real-World Scenarios](#9-real-world-scenarios)
- [10. Commands Reference](#10-commands-reference)
- [11. Quick Reference](#11-quick-reference)

---

<details>
<summary><strong>1. Why Infrastructure as Code Matters</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Most production infrastructure is managed through code now.

AWS resources? Code.
Kubernetes clusters? Code.
Network configurations? Code.
Database instances? Code.

Understanding Infrastructure as Code means you can:
- version control your infrastructure
- reproduce environments exactly
- audit all infrastructure changes
- automate deployments reliably
- scale infrastructure confidently

This isn't about memorizing HCL syntax.
It's about understanding how Terraform translates desired state into reality — so you can build infrastructure that works.

</div>

</details>

---

<details>
<summary><strong>2. What Terraform Solves</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Before Infrastructure as Code became standard, infrastructure management was fragmented.

**Traditional Infrastructure Problems:**
- clicking through web consoles
- inconsistent environments (dev ≠ prod)
- no audit trail (who changed what?)
- hard to reproduce infrastructure
- knowledge lives in someone's head
- manual changes introduce drift

**What Terraform Fixed:**
- Declarative → describe what you want, not how to build it
- Version controlled → infrastructure lives in Git
- Reproducible → same code = same infrastructure
- Auditable → all changes tracked in Git history
- Automated → no more manual clicking
- Multi-cloud → one tool for AWS, Azure, GCP, Kubernetes

**Why This Matters Now:**
When you need to deploy infrastructure, consistency is critical. Terraform gives you one mental model that works across all cloud providers and services.

</div>

</details>

---

<details>
<summary><strong>3. How Terraform Thinks</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

Terraform isn't procedural. It's declarative.

**Traditional Scripting (Procedural):**
```bash
# Tell AWS HOW to do it
aws ec2 create-vpc --cidr-block 10.0.0.0/16
aws ec2 create-subnet --vpc-id vpc-123 --cidr-block 10.0.1.0/24
aws ec2 run-instances --image-id ami-123 --subnet-id subnet-456
```

Problems:
- If you run it twice, you get duplicate resources
- Hard to update or modify infrastructure
- No understanding of current state
- Error recovery is manual

**Terraform (Declarative):**
```hcl
# Tell Terraform WHAT you want
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}

resource "aws_subnet" "main" {
  vpc_id     = aws_vpc.main.id
  cidr_block = "10.0.1.0/24"
}

resource "aws_instance" "app" {
  ami           = "ami-123"
  subnet_id     = aws_subnet.main.id
  instance_type = "t3.micro"
}
```

Benefits:
- Run it 100 times → same result (idempotent)
- Terraform knows what exists (state tracking)
- Can update in place or destroy cleanly
- Shows you changes before applying

---

### TF-001 — The Terraform Execution Model

Think of Terraform as three connected layers:

```
┌─────────────────────────────────────────┐
│     Your HCL Code (.tf files)          │
├─────────────────────────────────────────┤
│   Terraform Core (Plan & Apply)        │
├─────────────────────────────────────────┤
│  Providers (AWS, Azure, GCP, etc.)     │
├─────────────────────────────────────────┤
│     Cloud APIs (Real Infrastructure)    │
└─────────────────────────────────────────┘
```

**The Flow:**
1. You write `.tf` files describing desired state
2. Terraform reads your code and current state
3. Terraform calculates difference (plan)
4. You review and approve changes
5. Terraform calls provider APIs to reconcile state
6. Terraform updates state file with actual infrastructure

**Example:**
When you define `aws_instance`:
- Terraform Core parses your HCL
- AWS Provider translates it to EC2 API calls
- AWS creates the actual instance
- Terraform records the result in state

This Inside-Out model explains everything in Terraform.

---

### TF-002 — State: The Source of Truth

Terraform tracks what it created in a state file (`terraform.tfstate`).

**Why State Exists:**
- Terraform needs to know what infrastructure it manages
- Maps your code to real resources
- Tracks metadata (IDs, dependencies)
- Enables updates and deletions

**Critical Concept:**
```
Your Code → Desired State
State File → Current Reality
Terraform Plan → Difference Between Them
```

**Without state:**
- Terraform can't update resources
- Can't delete what it created
- Would create duplicates every run

**With state:**
- Terraform knows exactly what exists
- Can modify in place
- Can destroy cleanly
- Tracks dependencies

We'll cover state deeply in File 02. For now, understand: **state is how Terraform remembers what it built**.

---

### TF-003 — Declarative vs Imperative

**Imperative (Traditional Scripts):**
```bash
# Step-by-step instructions
if ! vpc_exists; then
    create_vpc
fi
if ! subnet_exists; then
    create_subnet
fi
# ...more steps
```

You tell the system HOW to do it.

**Declarative (Terraform):**
```hcl
# Describe the end state
resource "aws_vpc" "main" {
  cidr_block = "10.0.0.0/16"
}
```

You tell the system WHAT you want.

**Why Declarative Wins:**
- No "if vpc exists" logic needed
- Terraform figures out HOW
- Same code works for create/update/delete
- Self-documenting (code is the design)

</div>

</details>

---

<details>
<summary><strong>4. Terraform vs Alternatives</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-004 — Terraform vs CloudFormation

**CloudFormation (AWS-only):**
- Deep AWS integration
- Free (no additional cost)
- YAML/JSON (verbose)
- AWS-only (vendor lock-in)
- Automatic rollback on errors
- Native AWS support and updates

**Terraform:**
- Multi-cloud (AWS, Azure, GCP, K8s, etc.)
- Clean HCL syntax
- Massive provider ecosystem
- Large community
- More flexible for hybrid/multi-cloud

**When to use CloudFormation:**
You're 100% AWS-only forever and want tight AWS integration.

**When to use Terraform:**
Multi-cloud, hybrid cloud, or want flexibility.

---

### TF-005 — Terraform vs Ansible

**Ansible (Configuration Management):**
- Purpose: Configure existing servers
- Model: Procedural (step-by-step)
- Best for: Installing software, managing configs
- Execution: SSH-based, agentless
- Example: Install nginx, copy config, restart

**Terraform (Infrastructure Provisioning):**
- Purpose: Create infrastructure
- Model: Declarative (desired state)
- Best for: Creating VPCs, launching instances
- Execution: API calls to providers
- Example: Create VPC, launch EC2, attach EBS

**The Reality:**
You often use **both**.
- Terraform creates the infrastructure (VPC, EC2, RDS)
- Ansible configures the servers (install apps, configs)

**Workflow:**
```
Terraform: Create infrastructure
    ↓
Ansible: Configure servers
    ↓
Application: Deploy code
```

---

### TF-006 — Terraform vs Pulumi

**Pulumi:**
- Write infrastructure in real programming languages (TypeScript, Python, Go)
- Same declarative model as Terraform
- Uses existing language ecosystems
- Smaller community than Terraform

**Terraform:**
- Custom HCL language
- Purpose-built for infrastructure
- Largest IaC community
- More providers and modules

**When to use Pulumi:**
You strongly prefer TypeScript/Python and want programming language features.

**When to use Terraform:**
You want the standard, battle-tested IaC tool with the largest ecosystem.

---

### TF-007 — When NOT to Use Terraform

**Don't use Terraform for:**

**1. Configuration Management**
- Installing packages on servers
- Managing application configs
- User management on individual hosts
→ Use Ansible, Chef, or Puppet

**2. Application Deployment**
- Deploying Docker containers to Kubernetes
- Rolling out application code
- Managing application state
→ Use Helm, ArgoCD, or CI/CD pipelines

**3. Dynamic, Ephemeral Resources**
- Creating resources that change every minute
- Managing resources with very short lifecycles
→ Use API calls or application logic

**4. Real-Time Changes**
- Responding to metrics or events
- Auto-scaling based on load (use cloud native auto-scaling)
→ Use cloud-native solutions

**Terraform is for:**
- Long-lived infrastructure
- Networking (VPCs, subnets, routes)
- Compute (EC2, clusters)
- Databases (RDS, DynamoDB)
- Storage (S3, EBS)
- Security (IAM, Security Groups)

</div>

</details>

---

<details>
<summary><strong>5. Installation and Setup</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-008 — Installing Terraform

**Linux (Ubuntu/Debian):**
```bash copy
wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt update
sudo apt install terraform
```

**Linux (RHEL/CentOS/Fedora):**
```bash copy
sudo yum install -y yum-utils
sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/RHEL/hashicorp.repo
sudo yum install terraform
```

**macOS (Homebrew):**
```bash copy
brew tap hashicorp/tap
brew install hashicorp/tap/terraform
```

**Verify Installation:**
```bash copy
terraform version
```

You should see:
```
Terraform v1.9.x
```

---

### TF-009 — Manual Installation (Binary)

Sometimes you need a specific version or don't have package managers.

**Download and Install:**
```bash copy
# Download (replace with desired version)
wget https://releases.hashicorp.com/terraform/1.9.0/terraform_1.9.0_linux_amd64.zip

# Extract
unzip terraform_1.9.0_linux_amd64.zip

# Move to PATH
sudo mv terraform /usr/local/bin/

# Verify
terraform version
```

**Why Manual Installation:**
- Specific version requirements
- Air-gapped environments
- CI/CD pipelines with version pinning

---

### TF-010 — Setting Up Your Workspace

**Create a Project Directory:**
```bash copy
mkdir -p ~/terraform-projects/first-project
cd ~/terraform-projects/first-project
```

**Directory Structure (Basic):**
```
first-project/
├── main.tf           # Primary resource definitions
├── variables.tf      # Input variable declarations
├── outputs.tf        # Output value definitions
├── terraform.tfvars  # Variable values
└── .gitignore        # Exclude state files
```

**Create .gitignore:**
```bash copy
cat > .gitignore << 'EOF'
# Terraform state files
*.tfstate
*.tfstate.*
*.tfstate.backup

# Crash logs
crash.log
crash.*.log

# Variable files (may contain secrets)
*.tfvars
*.tfvars.json
terraform.tfvars

# CLI config
.terraformrc
terraform.rc

# Directory for plugins
.terraform/
.terraform.lock.hcl

# Override files
override.tf
override.tf.json
*_override.tf
*_override.tf.json

# Plan files
*.tfplan
EOF
```

**Why .gitignore Matters:**
- State files contain sensitive data
- `.terraform/` directory is large (plugins)
- tfvars may contain secrets

</div>

</details>

---

<details>
<summary><strong>6. Your First Terraform Init</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-011 — terraform init (The First Command)

`terraform init` is the first command you run in any Terraform project.

**What It Does:**
1. Downloads required provider plugins
2. Sets up backend for state storage
3. Installs modules if any are referenced
4. Creates `.terraform/` directory

**Example:**
```bash copy
cd ~/terraform-projects/first-project
terraform init
```

**Output:**
```
Initializing the backend...
Initializing provider plugins...
- Finding latest version of hashicorp/aws...
- Installing hashicorp/aws v5.31.0...
- Installed hashicorp/aws v5.31.0

Terraform has been successfully initialized!
```

**What Just Happened:**
- Terraform read your `.tf` files
- Identified required providers (e.g., AWS)
- Downloaded provider binaries to `.terraform/providers/`
- Created lock file (`.terraform.lock.hcl`)

---

### TF-012 — Understanding .terraform Directory

After `terraform init`, you'll see:

```
.terraform/
├── providers/
│   └── registry.terraform.io/
│       └── hashicorp/
│           └── aws/
│               └── 5.31.0/
│                   └── linux_amd64/
│                       └── terraform-provider-aws_v5.31.0
└── terraform.tfstate (if local backend)
```

**Key Files:**
- `providers/` → Downloaded provider binaries
- `terraform.tfstate` → State file (if local backend)

**Important:**
This directory is **not** committed to Git. It's regenerated by `terraform init`.

---

### TF-013 — The Lock File (.terraform.lock.hcl)

After init, Terraform creates `.terraform.lock.hcl`.

**Purpose:**
- Locks provider versions
- Ensures consistent provider versions across team
- Records checksums for security

**Example:**
```hcl
provider "registry.terraform.io/hashicorp/aws" {
  version     = "5.31.0"
  constraints = "~> 5.0"
  hashes = [
    "h1:abc123...",
    "zh:def456...",
  ]
}
```

**Why It Matters:**
- Team members get same provider versions
- CI/CD pipelines use consistent versions
- Prevents "works on my machine" issues

**Should You Commit It?**
**Yes.** Commit `.terraform.lock.hcl` to Git.

---

### TF-014 — When to Re-run terraform init

**Run `terraform init` when:**
- Starting a new Terraform project
- Adding new providers
- Changing backend configuration
- Cloning a repo with Terraform code
- Upgrading provider versions

**Example:**
```bash copy
# Added a new provider to main.tf
terraform init
```

**Safe to Run Multiple Times:**
`terraform init` is idempotent. Running it multiple times is safe.

</div>

</details>

---

<details>
<summary><strong>7. Understanding the Workflow</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-015 — The Core Terraform Workflow

Every Terraform interaction follows this pattern:

```
Write → Init → Plan → Apply → Destroy (optional)
```

**1. Write**
```bash copy
# Create main.tf with your infrastructure code
cat > main.tf << 'EOF'
resource "aws_instance" "example" {
  ami           = "ami-0c55b159cbfafe1f0"
  instance_type = "t3.micro"
}
EOF
```

**2. Init**
```bash copy
terraform init
```
Downloads providers, sets up backend.

**3. Plan**
```bash copy
terraform plan
```
Shows what Terraform will do (preview).

**4. Apply**
```bash copy
terraform apply
```
Creates/updates infrastructure.

**5. Destroy (when done)**
```bash copy
terraform destroy
```
Removes all managed infrastructure.

---

### TF-016 — terraform plan (Preview Changes)

`terraform plan` shows what Terraform will do WITHOUT making changes.

**Example:**
```bash copy
terraform plan
```

**Output:**
```
Terraform will perform the following actions:

  # aws_instance.example will be created
  + resource "aws_instance" "example" {
      + ami                          = "ami-0c55b159cbfafe1f0"
      + instance_type                = "t3.micro"
      + id                           = (known after apply)
      + private_ip                   = (known after apply)
      + public_ip                    = (known after apply)
      ...
    }

Plan: 1 to add, 0 to change, 0 to destroy.
```

**Symbols:**
- `+` = will be created
- `-` = will be destroyed
- `~` = will be updated in-place
- `-/+` = will be destroyed and recreated

**Why Plan First:**
- Catch mistakes before applying
- Review changes with team
- Save plan file for review

---

### TF-017 — terraform apply (Make Changes)

`terraform apply` executes the changes.

**Interactive Apply:**
```bash copy
terraform apply
```

Terraform shows the plan and asks:
```
Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.

  Enter a value: yes
```

**Auto-Approve (Non-Interactive):**
```bash copy
terraform apply -auto-approve
```

**Use Cases:**
- CI/CD pipelines
- Automation scripts
- When you're confident in the plan

**Caution:**
Always review the plan before auto-approving in production.

---

### TF-018 — terraform destroy (Remove Infrastructure)

`terraform destroy` removes all managed infrastructure.

**Example:**
```bash copy
terraform destroy
```

**Output:**
```
Terraform will perform the following actions:

  # aws_instance.example will be destroyed
  - resource "aws_instance" "example" {
      - ami                          = "ami-0c55b159cbfafe1f0"
      ...
    }

Plan: 0 to add, 0 to change, 1 to destroy.

Do you really want to destroy all resources?
  Enter a value: yes
```

**Auto-Approve:**
```bash copy
terraform destroy -auto-approve
```

**Destroy Specific Resources:**
```bash copy
terraform destroy -target=aws_instance.example
```

**When to Use:**
- Tearing down test environments
- Cleaning up after demos
- Removing all infrastructure

**Warning:**
`terraform destroy` is irreversible. It deletes real infrastructure.

</div>

</details>

---

<details>
<summary><strong>8. Directory Structure</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### TF-019 — Basic Project Structure

**Single File (Simple Projects):**
```
project/
├── main.tf           # Everything in one file
└── .gitignore
```

**Multi-File (Recommended):**
```
project/
├── main.tf           # Primary resources
├── variables.tf      # Input variables
├── outputs.tf        # Output values
├── providers.tf      # Provider configurations
├── terraform.tfvars  # Variable values
└── .gitignore
```

**Why Split Files:**
- Easier to navigate
- Logical separation of concerns
- Team can work on different files
- Clearer code review

---

### TF-020 — File Naming Conventions

Terraform loads all `.tf` files in a directory (alphabetical order doesn't matter for resources).

**Common Conventions:**

| File | Purpose |
|------|---------|
| `main.tf` | Primary resource definitions |
| `variables.tf` | Input variable declarations |
| `outputs.tf` | Output value definitions |
| `providers.tf` | Provider and version constraints |
| `versions.tf` | Terraform version requirements |
| `terraform.tfvars` | Variable values (not committed) |
| `backend.tf` | Backend configuration |
| `data.tf` | Data source definitions |
| `locals.tf` | Local value definitions |

**Example main.tf:**
```hcl
resource "aws_vpc" "main" {
  cidr_block = var.vpc_cidr
}

resource "aws_subnet" "public" {
  vpc_id     = aws_vpc.main.id
  cidr_block = var.public_subnet_cidr
}
```

**Example variables.tf:**
```hcl
variable "vpc_cidr" {
  description = "CIDR block for VPC"
  type        = string
  default     = "10.0.0.0/16"
}

variable "public_subnet_cidr" {
  description = "CIDR block for public subnet"
  type        = string
  default     = "10.0.1.0/24"
}
```

**Example outputs.tf:**
```hcl
output "vpc_id" {
  description = "ID of the VPC"
  value       = aws_vpc.main.id
}

output "subnet_id" {
  description = "ID of the public subnet"
  value       = aws_subnet.public.id
}
```

---

### TF-021 — Environment Structure

**Per-Environment Directories (Common Pattern):**
```
terraform/
├── environments/
│   ├── dev/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── terraform.tfvars
│   │   └── backend.tf
│   ├── staging/
│   │   ├── main.tf
│   │   ├── variables.tf
│   │   ├── terraform.tfvars
│   │   └── backend.tf
│   └── production/
│       ├── main.tf
│       ├── variables.tf
│       ├── terraform.tfvars
│       └── backend.tf
└── modules/
    ├── vpc/
    ├── compute/
    └── database/
```

**Why Separate Directories:**
- Isolated state files per environment
- Different variable values per environment
- Reduced blast radius (mistakes in dev don't affect prod)

</div>

</details>

---

<details>
<summary><strong>9. Real-World Scenarios</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

### Scenario 1: Starting a New Project

**Situation:**
You need to create AWS infrastructure for a new application.

**Steps:**
```bash copy
# Create project directory
mkdir ~/terraform/my-app
cd ~/terraform/my-app

# Create .gitignore
cat > .gitignore << 'EOF'
*.tfstate
*.tfstate.*
.terraform/
.terraform.lock.hcl
*.tfvars
EOF

# Create basic structure
touch main.tf variables.tf outputs.tf providers.tf

# Initialize Git
git init
git add .gitignore main.tf variables.tf outputs.tf providers.tf
git commit -m "Initial Terraform structure"

# Initialize Terraform
terraform init
```

**Result:**
Clean project structure ready for development.

---

### Scenario 2: Wrong Provider Version Installed

**Symptom:**
Team member gets different behavior than you.

**Cause:**
They're using a different provider version.

**Fix:**
```bash copy
# Generate lock file
terraform init

# Commit lock file
git add .terraform.lock.hcl
git commit -m "Lock provider versions"

# Team members run
git pull
terraform init  # Uses locked versions
```

**Confirm:**
```bash copy
terraform version
terraform providers
```

Everyone sees same versions.

---

### Scenario 3: Accidentally Deleted .terraform Directory

**Symptom:**
```
Error: Could not load plugin
```

**Cause:**
`.terraform/` directory deleted or not present (after git clone).

**Fix:**
```bash copy
terraform init
```

**Result:**
Terraform re-downloads providers and recreates directory.

**Why This Works:**
`.terraform/` is never committed to Git. It's always regenerated.

---

### Scenario 4: Checking What Terraform Will Do

**Situation:**
You modified some resources and want to verify changes before applying.

**Steps:**
```bash copy
# Make changes to main.tf
vim main.tf

# Preview changes
terraform plan

# Review output carefully
# If changes look good, apply
terraform apply

# If changes look wrong, fix code and plan again
```

**Best Practice:**
Always run `terraform plan` before `terraform apply` in production.

---

### Scenario 5: Cleaning Up Test Infrastructure

**Situation:**
You created test infrastructure that you no longer need.

**Steps:**
```bash copy
# Review what will be destroyed
terraform plan -destroy

# Destroy infrastructure
terraform destroy

# Confirm resources are gone (check AWS console or CLI)
aws ec2 describe-instances --filters "Name=tag:Name,Values=test-*"
```

**Result:**
All Terraform-managed resources removed. AWS bill reduced.

</div>

</details>

---

<details>
<summary><strong>10. Commands Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

```bash copy
terraform version
```
Check Terraform version

```bash copy
terraform init
```
Initialize project, download providers

```bash copy
terraform init -upgrade
```
Upgrade providers to latest allowed versions

```bash copy
terraform plan
```
Preview changes without applying

```bash copy
terraform plan -out=tfplan
```
Save plan to file for later apply

```bash copy
terraform apply
```
Apply changes (interactive, asks for confirmation)

```bash copy
terraform apply -auto-approve
```
Apply changes without confirmation

```bash copy
terraform apply tfplan
```
Apply saved plan file

```bash copy
terraform destroy
```
Destroy all managed infrastructure

```bash copy
terraform destroy -auto-approve
```
Destroy without confirmation

```bash copy
terraform destroy -target=aws_instance.example
```
Destroy specific resource

```bash copy
terraform fmt
```
Format all .tf files in directory

```bash copy
terraform validate
```
Validate syntax of .tf files

```bash copy
terraform show
```
Show current state or saved plan

```bash copy
terraform providers
```
Show required providers

```bash copy
terraform console
```
Interactive console for testing expressions

```bash copy
terraform output
```
Show all output values

```bash copy
terraform output vpc_id
```
Show specific output value

</div>

</details>

---

<details>
<summary><strong>11. Quick Reference</strong></summary>

<div style="margin-left: 16px; margin-right: 16px; margin-top: 8px; margin-bottom: 8px;">

**Key Concepts:**
- Infrastructure as Code → infrastructure defined in version-controlled files
- Declarative → describe WHAT you want, not HOW to build it
- State → Terraform's memory of what infrastructure exists
- Providers → plugins that talk to APIs (AWS, Azure, GCP, etc.)
- Idempotent → running same code multiple times produces same result

---

**Terraform Workflow:**

```
Write Code → Init → Plan → Apply → Destroy
```

| Step | Command | Purpose |
|------|---------|---------|
| Initialize | `terraform init` | Download providers, setup backend |
| Preview | `terraform plan` | See what will change |
| Apply | `terraform apply` | Create/update infrastructure |
| Destroy | `terraform destroy` | Remove infrastructure |

---

**File Structure:**

| File | Purpose | Commit to Git? |
|------|---------|----------------|
| `*.tf` | Terraform code | ✅ Yes |
| `.terraform.lock.hcl` | Provider version locks | ✅ Yes |
| `.gitignore` | Exclude sensitive files | ✅ Yes |
| `terraform.tfstate` | State file | ❌ No (use remote state) |
| `.terraform/` | Provider binaries | ❌ No |
| `*.tfvars` | Variable values | ❌ No (may contain secrets) |

---

**Command Symbols (in plan output):**

| Symbol | Meaning |
|--------|---------|
| `+` | Will be created |
| `-` | Will be destroyed |
| `~` | Will be updated in-place |
| `-/+` | Will be destroyed and recreated |

---

**Terraform vs Alternatives:**

| Tool | Best For | Model |
|------|----------|-------|
| Terraform | Infrastructure provisioning | Declarative |
| CloudFormation | AWS-only infrastructure | Declarative |
| Ansible | Server configuration | Procedural |
| Pulumi | Code-first IaC | Declarative |

---

**Common Mistakes:**

| Mistake | Problem | Solution |
|---------|---------|----------|
| Not running init | Providers not downloaded | Always `terraform init` first |
| Skipping plan | Unexpected changes | Always `plan` before `apply` |
| No .gitignore | Secrets in Git | Use proper .gitignore |
| Committing state | State in Git | Use remote state backend |
| Auto-approve in prod | No review of changes | Only auto-approve in CI/CD with safeguards |

---

**What's Next:**
Now that you understand Terraform foundations, the next file covers State — how Terraform tracks infrastructure and why state is the most critical concept in Terraform.

</div>

</details>

---
